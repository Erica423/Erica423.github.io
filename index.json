[{"content":" 基于Hugo搭建的个人静态博客，使用主题theme为Hugo_PaperMod 部署前提：\n安装Git 安装Hugo 1 搭建hugo博客 PaperMod主题创建及配置：line hugo server -D 启动服务，浏览器访问 http://localhost:1313 2 Github部署 重头戏来啦！GitHub Actions 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。这里给出的是Github Actions自动部署的过程，常规部署操作比较麻烦（第一次部署狠狠踩坑了只能全部删除重来\u0026hellip;）\n新建github仓库，命名为 {自己的github用户名}.github.io，设置为公开。这个仓库用来存public文件夹中的静态html文件，也就是展示博客的内容 打开当前仓库的Setting -\u0026gt; Pages -\u0026gt; Branch 选择main分支，save保存 再新建一个私有仓库，可以命名为xxx-blog（随意就可），用于存放hugo源文件 打开github主页（注意不是仓库的）的Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)。自主选择token的过期时间，并勾选repo和workflow选项。注意保存好生成的token，之后就查看不了了。 转到源文件仓库！将刚才生成的token存入仓库的变量中。打开Settings -\u0026gt; Secrets and variables -\u0026gt; Actions new一个secret。 在源文件中创建.github/workflows/deploy.yaml配置文件，复制以下配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: deploy on: push: branches: - main workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.自己的token变量名 }} EXTERNAL_REPOSITORY: 自己的github名/自己的github名.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_meassage: auto deploy # commit_message: ${{ github.event.head_commit.message }} 新建.gitignore 1 2 3 4 # 自动生成的文件 public resources .hugo_build.lock 最后就可以推送源文件到仓库啦，成功push后就会自动触发Github Actions自动部署。(新设备记得添加ssh秘钥) 1 2 3 4 5 6 7 8 # git config --global user.name \u0026#39;xxx\u0026#39; # git config --global user.email \u0026#39;xxx\u0026#39; git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {仓库地址} git push -u origin main 访问xxx.github.io看到博客页面就是部署成功啦！🥳🥳🥳 3 其他插件 添加阅读量、用户访问量功能（busuanzi计数器） 参考地址：\u0026ldquo;https://zhuanlan.zhihu.com/p/649952987\u0026quot;\n添加Waline评论功能 参考地址：\u0026ldquo;https://blog.grew.cc/posts/papermod-modify/\u0026quot;\n修改目录到侧边栏 参考地址：\u0026ldquo;https://www.sulvblog.cn/posts/blog/hugo_toc_side/\u0026quot;\n样式优化 参考地址：\u0026ldquo;https://kdjlyy.github.io/posts/site/hugo-papermod-optimization/\u0026quot;\n","permalink":"https://erica423.github.io/posts/first/","summary":"基于Hugo搭建的个人静态博客，使用主题theme为Hugo_PaperMod 部署前提： 安装Git 安装Hugo 1 搭建hugo博客 PaperM","title":"【完】使用Github Actions实现Hugo静态博客自动部署"},{"content":"消息队列 MQ是干嘛的？消息的中转站，能存很多消息。 应用场景：\n应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。 异步处理 ：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。 流量削锋 ：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。 日志处理 ：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。 消息通讯 ：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。 消息广播 ：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。 RocketMQ RocketMQ的相关组件和角色：\nproducer：生产者，消息的发送者。负责将消息发送给Broker producer group：生产者组，标记一类生产者 nameSrv：（看板）名字服务，一个路由注册中心。Broker会定时把自己的信息（IP等）上传给nameSrv，生产者和消费者就可以从nameSrv获取这些信息，才能顺利发送和接收消息 Broker：代理服务器，消息中转站，负责消息的存储、投递、查询 Broker cluster：代理服务器集群。可以是主主集群（集群内部Broker同级别同时对外提供服务），主从集群（主B对外提供服务，从B同步主B的消息作为备份防止主B宕机，不对外提供服务）。一个主可以有多个从 consumer：消费者，向Broker拉取自己想要消费的消息 consumer group：两个消费者组之间消费的消息互不干扰（比如一条消息可以被A组看也可以被B组看，想看多少各自随便） 对一个consumer group来说，消费的模式有：集群消费和广播消费\n集群模式：大家负载均衡地消费了这4条消息\n广播模式：组内每个消费组都收到了全部消息\nTopic：主题，消息的分类。这样对某一类消息感兴趣的消费者则可以订阅Topic-xxx，不会被无关的消息给冲烂了。\nTag：二级分类，更精细化区分消息\n思考：不同的消费组之间可以全量消费同Topic的消息，它们之间的消费进度又可以不一样，是Broker将信息复制了多份吗？\nmq两种基本实现模式 队列模式 生产者发送的消息被排成队列，然后消费者们竞争消费队列上的消息。按照队列的特性，消息被消费了等于出队，即从队列上被移除了，那么每条消息只会被一个消费者消费，因此消费者之间是竞争关系。\n缺点：一个消息可能有很多消费者都感兴趣，但是他们之间又不是竞争消费的关系，即这些消费者都想消费所有的消息。这时候普通的队列模式就不合适了。-\u0026gt; 复制到多队列，加重存储负担，冗余\n发布-订阅模式 生产者发布消息，消费者订阅消息。订阅依据就是Topic主题。\n想要实现的功能：比如我往 Topic-LOL 这个主题发布消息，那么订阅了这个主题的消费者都能收到这个消息，我往 Topic-DOTA 这个主题发布消息，那么订阅了 DOTA 主题的消费者都能收到 DOTA 相关的消息。\n具体实现：引入消息位置（offset），类比数组下标。我们的述求是消息可以被多个消费者消费，那么只需维护每个消费者已经消费到的位置，每当消费者消费一条消息，消费位置就+1，然后消费者根据记录的消息位置去消费对应的数据即可。\n问题：同一个消费组内的消费者如何消费消息？让他们竞争同一个消费位置吗？那岂不是需要等上一个消费者消费完了，组内其他消费者才能消费下一条消息？这效率就很低了。\n-\u0026gt; 引入：在 RocketMQ 中叫队列（这个跟数据结构上的队列在概念上要区分下），在Kafka中叫分区。\n可以看到，发往一个 Topic 的消息，实际上不是在一个队列里，而是分布在多个队列中。这样属于一个消费组的消费者们可以专门负责主题里面的一个队列。\n消费点位的记录维度就变成了 Topic-消费组-队列，比如现在一共有两个主题，分别是 Topic-LOL、Topic-DOTA，每个主题都有两个队列（分区）。\n如果c组有加了一人c，对应Topic也可以加一个队列；另一个c组人数不变，可以让其中一人多消费一个队列即可。\n处理消息堆积：加队列同时加消费者（面试常问）\n至此，我们就清晰了企业级消息队列实现的发布-订阅模式的核心原理：即 Topic 下分队列（分区），然后维护每个消费组在每个 Topic 下每个队列的消息位置，以消息位置（offset）来控制消息消费的进度。\n问题：一个Topic里有多个队列，生产者如何确定往哪个队列发消息？\n轮询：比如生产者-A，要往 Topic-LOL 发送消息，那么第一条发给队列-1，第二条发给队列-2，第三条发给队列-3，第四条发给队列-1，第五条发给队列-2。。。。如此往复即可。这样每个队列的消息量平均，对应消费者的工作量也平均。 指定发往某个队列：比如有关匹配的消息都发往队列-1，有关大乱斗的消息都发往队列-2，有关云顶之弈的消息都发给队列-3。 RabbitMQ 的底层就是队列模式，而 RocketMQ 和 Kafka 两者的实现都是发布-订阅模式。\nBroker消息存储 消息存储非常重要，mq一个关键功能就是削峰填谷。比如在大流量场景下（双十一），一下子涌入大量用户，造成请求高峰，使系统压力剧增。\n解决：把相关请求先发送到mq，然后直接返回success给用户。如：“业务受理成功，由于当前访问较多，详情约在xx-xx分钟后可查询“这样的话术。然后让系统平缓、匀速地拿取mq里的消息再进行业务处理。\n而这个过程的重点就是保证排队消息存储的可靠性。\nso，，Broker里的消息应该存到哪里呢？\n存数据库（MySQL）？zszz，性能不行； 那缓存Redis？性能是ok，but不靠谱； 对于一个中间件，mq本身轻量级也很关键，中间件依赖别的组件，就是强行使用者维护更多的组件，会变得更复杂。\n所以存本地硬盘。其实mysql保存和redis持久化的数据也都是在本地硬盘，所以直接跳过中介，把消息直接写入本地硬盘的文件上。现在硬盘都是RAID，即多块硬盘组成逻辑上的一块，也就是有备份。 那么mq中的消息要以什么格式存储到文件里呢？\ncommitlog ：类似记事本一样，一行一行的写\n每条消息的大小不固定；\n不同topic的消息都存在一个文件里（why都写进一个文件？涉及计组的底层机械硬盘结构）\n计组知识点\n寻道时间 旋转时间 在物理上，如果存储在硬盘上的数据在同一个磁道且相邻的扇区，那么根据硬盘的机械运行轨迹，读/写的顺序就非常快（省略寻道时间，顺应旋转的方向），甚至可以媲美内存的读写速度！顺序读 顺序写\n顺序写就是RocketMQ为什么性能好的原因（面试问）其他应用：mysql的redo log\nso，所有的消息不论是哪个 topic 都写入同一个文件，并且都是顺序追加写入，那么对应到硬盘上就是顺序写！（基本上一个文件的内容，如果空间足够，那么都是连续的）这样就大大提高了消息队列写消息的性能。\n如果将不同的 topic 存入不同的文件，我们无法保证这些文件在物理上的位置是连续的。(随机写)\n总结： RocketMQ 选择将消息写入到文件中，依赖机械硬盘（当然也可以是ssd）来保证消息存储的可靠性，并且根据机械硬盘的特性，把不同 topic 的消息都追加写入到一个叫 commitlog 的文件中，这样的顺序写性能很好。\n现在我们知道消息都存储在一个叫commitlog的文件里，那么队列呢？队列和commitlog是什么关系？消费者如何快速获取commitlog里的消息？\nConsumeQueue 当消息被写入commitlog时表示生产者成功发送了消息，消息也落入硬盘被持久化了。此时可以启动一个定时任务 (约1ms/次，几乎实时)，将新写入commitlog的消息转发给consumeQueue(就是Topic队列)\nconsumequeue有必要存全量的消息吗？完全copy一份commitlog也太消耗内存了。\n所以直接去cl里找。由于消息直接存入cl，且是追加写入，里面存储了连续的消息。引入偏移量作索引。\nconsumerQueue 实际存储的不是消息本身，而是存储消息在 commitlog 文件中的起始偏移量和本条消息的长度还有tagHash。\n时间换空间 也需要落盘存储\nconsumerOffset 和 commitlog offset：\nconsumeroffset 消息（逻辑）位置：在一个队列被多个消费者消费时，只需维护每个消费者已经消费到的位置。每当消费一条消息，offset（消费位置）+1，然后消费者根据记录的offset去队列里查找消费对应的消息。\ncommitlog里的offset：消息所在commitlog文件中的偏移位置。通过这个offset找到消息的起始位置再+size获取完整消息\n至此，消费者消费一条消息的流程：\n通过consumerOffset找到consumerQueue里的内容，这个内容存储了消息所在commitlog中的offset和size，然后通过这两个数据去commitlog里获取完整的消息内容。\n消息索引 IndexFile 通过输入索引快速定位到一条消息。\nHashMap，但文件不提供HashMap的功能\nIndexFile结构：\nhead：大小固定，存放一些元信息（当前文件中消息的最小和最大存储时间、当前文件中消息在commitlog的最小和最大偏移量、已用hash槽个数、已用index个数）\n每个槽大小固定4字节\n知道是第几个槽后，槽里存的是index item下标。每个index item大小固定20字节。一个indexFile文件有2000w个ii，存储了消息再commitlog中的物理offset。\n假如发生了hash冲突怎么办？\n更新槽的值为最新的index item下标，1。并且记录上一个index item 的下标，prevIndex = 0。同时index item里还要存储keyhash来判断跟当前计算的hash是否一致，不一致说明冲突，需要通过prevIndex值去得到上一个item的下标再去查找。 index item里还存了消息的时间，这个时间还是个差值：这条消息在commitlog写入的时间（IndexFile第一条消息的写入时间）\n消息发送 消息类型：\n普通消息\n同步消息：producer发送一条消息给Broker，需要等待Broker返回响应才会继续发送后续消息\nproducer.send(msg)\n要是没收到reaction，生产者会进行重试。默认重试3次，3次后还是失败就抛异常。此时需要我们捕获这个异常，进行日志记录或其他兜底操作。\n（类似TCP的单词握手，一次request过去，一个ack回来）\n但酱紫重试的缺点是消息重复发送\n这里要做好消息的防重，或幂等（？）\n问：如何保证消息一定发送成功？\n答：Broker接收成功后，返回ack给生产者，没接收到ack则不认为消息发送成功，进行重试。\n异步消息\n不需要阻塞等待上一条的ack可以紧接着发送后续消息\n假如前面的消息发送失败了，会有另外的线程来处理Broker的响应。成功响应就执行onSuccess逻辑，失败则执行onException\n1 2 3 4 5 6 7 8 9 10 11 producer.send(msg, new SendCallback(){ public void onSuccess(SendResult sendResult) { //do sth } public void onException(Throwable e) { //do sth // 失败信息记录 } }) 异步消息也能设置重试，问题和同步的一样（重复）。适合对响应时间敏感度的场景。\n单向消息\n生产者只管发消息，不关心Broker收没收到，也不用等ack\n适合对消息可靠性要求不高的场景: 大量日志收集（不在乎丢几条）\n顺序消息\n按顺序发布消息，按发布顺序消费消息\n场景：1. 创建订单 2. 支付 3. 发货 4. 完结订单\n由于一个Topic多队列的实现，普通消息没法保证先发送的一定先被消费。\n解决方案：把这几个消息都发一个队列里！把这几类消息都发进一个队列，这种叫全局顺序消息\n如果把同一笔订单的创建支付发货收货发往一个队列，不同订单发往不同队列，叫分区顺序消息. 能提高并发度和消费速度。\n分区依赖一个sharding key，比如订单场景中的订单号可以作为sharding key。\n1 2 queueIndex := orderId % len(queue) producer.send(msg, queueIndex) 默认普通消息是轮询选择队列。（上一个发队列1，下一个发队列2，。。。）\n延迟消息\n生产者发送了消息，希望延迟一段时间再被消费。\n实现：\n延迟消息一开始不放在正常的Topic中，有一个专门的Topic叫SCHEDULE_TOPIC_XXXX，放置所有的延迟消息。等到时间了再把该消息发回本身的Topic队列。这样就不会妨碍消费其他消息。\nRocketMQ中的延迟时间只能设定投递等级，不同等级固定对应一个时间。\n批量消息\n一次发包发送多条消息，适用对吞度量敏感的场景。\n100条打包成1条发，只调用一次接口，只等待一次reaction。吞度效率变高了，但一条消息有错就要一批重来。\n事务消息\nNameSrv 命名服务 NameSrv和Broker 在 Broker 启动之前，NameSrv 需要先启动。Broker 会定时的把自己关于 Topic 的信息上报至 NameSrv，NameSrv 会维护记录这些信息，并且将无用的 Broker 剔除。\nNameSrv和Producer 对于 Producer 来说，启动后它需要找到一台 NameSrv 建立长连接。Producer 需要从 NameSrv 或者有关 Topic 的路由信息，然后跟对应的 Broker 建立长连接，后面直接将消息发送给对应的 Topic。\n注意：Producer 不会缓存路由信息到本地文件中，只会放在内存里。所以如果 NameSrv 挂了，由于 Produer 是直接跟 Broker 建立长连接直接发送消息的，所以不影响现有的消息发送。\n但是如果这时候你将 Producer 重启了，那么在 NameSrv 挂了的情况下，消息就无法正常发送了，因为路由信息都丢了，也无法从 NameSrv 获取。不要随意重启Producer\nNameSrv和Consumer Consumer和Producer一样，启动后先和NameSrv建立长连接，获取topic和broker的映射。然后和有关broker建立长连接。发消息和消费消息的过程都不会经过中间商NameSrv，NameSrv 的作用就是“看板”，来记录维护路由信息，给 Consumer 和 Producer 指路。\nNameSrv和NameSrv 为了避免单点NameSrv挂了导致新P和C成瞎子，在生产中需要部署多台NameSrv形成集群。RocketMQ 实现的 NameSrv 非常轻量级，集群内的 NameSrv 是互相独立的存在，它们之间不会进行任何的信息交互。\nBroker需要给集群内的每一台NameSrv都上报路由信息。 对 Producer 和 Consumer 来说，因为多台 NameSrv 的数据都是一样的，因此它们只需要随机选择集群内的一台 NameSrv 进行长连接即可获取全量的路由信息。 总结：\nNameSrv 这个角色就是动态路由中心，会维护存活的 Broker 信息，记录 Topic 的路由关系，使得 Producer 和 Consumer 可以正确的找到对应的 Broker 。\nRocketMQ 简单的自己设计了一个轻量级路由中心而不是依赖于其他三方组件，这样对整个消息队列中间件而言更轻量和自主。\nkafka中对应NameSrv的角色是zookeeper。zk 集群中多台机器会进行数据同步，就会产生数据一致性问题，NameSrv 则直接每台都存储全量的数据，且之间不进行任何信息交互，完美地避开数据不一致的问题。\nkafka 在新版本中已经移除了 zk 的强依赖（强一致性在性能方面开销会比较大）。\n新问题：消息存储在Broker，是消费者去Broker拉取消息pull还是B主动给消费者推push呢？\n答：看需求\n消息vs快递 ：上门送货 = push， 自取 = pull\n推消息 Broker收到对应消息，立马推送给消费者\n优点：实时性超高，对消费者实现也简单；\n缺点：消费者在某个时段超忙，没空处理新消息；Broker疯狂push，可能直接把消费者干爆；这就违背了消息队列削峰填谷的初衷。所以Broker在push消息前可以先打探消费者的状态再推，但消费者太多的情况也不合适。\n使用场景：消费者不多、消息量不大、及时性要求高\n拉消息 优点：Broker轻松，只需要存储好生产者发来的消息，等消费者来拉就好了，想拉多少拉多少，不用维护其他关系；\n缺点：消息的消费可能不及时\n如果把定时时间调短一点，消费不及时可以改善，但又造成了消息忙请求。就是说几个小时都没消息过来，消费者还隔1s来要一次。\n目前RocketMQ和kafka用的都是拉模式 pull，但是长轮询：\n消费者发送拉取请求到Broker时，如果此时有消息，则Broker直接响应返回消息；如果没消息就hold这个请求，比如等待15s，15s内要是有消息过来了就立马响应返回。\n这样既避免了忙请求，也提升了消息的及时性ovo\nRMQ有pullConsumer和pushConsumer，但底层实现都是基于长连接的长轮询去拉取消息。\n消费者启动 怎么获取nameSrv？在开始时注入nameSrv地址\n接下来分赃：\n新来一个消费者分俩给它，减轻老消费者的压力同时提高消费效率。\n分赃的契机：新消费者启动并连上Broker\n分赃过程：由消费者遵循一定规则主动分配 （专名：==重平衡==，也是==客户端的负载均衡==）\n消费者5看似没活干了，会这么摸鱼吗？\n问：消息堆积时，增加消费者有用吗？\n答：我不好说。如果这个消费者组的消费者数量比Topic的队列数量小，此时可以加消费者来缓解消息堆积；如果消费者数量比队列还多，就没用力。\n不光在消费者启动时会触发重平衡，每个消费者会有个定时任务，每20s重平衡一下子，就负载均衡了，防止消费任务不均衡。 如果有消费者下线了，由于和Broker有连接，下线了Broker也知道，会通知所有消费者重平衡一下。 实现了动态负载均衡：业务高峰时增加消费者，业务低谷时减少消费者。\n怎么拉消息 最简单的想法是一个队列对应一个线程负责去pull，但上下文切换过于频繁。线程池？也用不上\nRocketMQ只用了一个线程（PullMessageService）来执行pull操作，所有的pull动作都会封装成pullRequest，扔到pullRequestQueue一个阻塞队列中。\npullRequest获取的结果会先缓存到ProcessQueue中，同时再构建一个消费任务consumerRequest 给ConsumeMessageService这个线程池来消费消息。\nProcessQueue: 起到暂缓消息的作用，用来流控。如果暂缓的消息很多，说明消息处理慢，消息在消费者这里有堆积，这时候就需要限制拉取速度。也就是不能一直构建pullRequest，要等一等（流控）\n消息点位 offset：之前提到的每个消费组需要维护Topic下的每个队列被消费到的点位，这个点位是怎么保存的呢？在什么时候提交呢？\n答：在不同模式下，保存方式不同\n广播模式：\n​\t广播模式下存储在消费者本地磁盘上，因为消息广播给每个消费者，不需要统一一个地方来管，每个消费者自己维护就行了。\n集群模式：\n​\t不能本地维护了，因为同个消费组内的消费者是互帮互助的关系。在新消费者顶替旧消费者时需要知晓前一个人的消费进度。所以集群模式下offset存储在Broker里，这样顶上的消费者可以从Broker获取offset。\n那么，消费者具体在什么时候将自己的消费位置告知Broker更新呢？\n答：拉取信息的时候顺带把消费点位提交给Broker。\n问题又来了：假设消费完了，还没来得及拉消息，消费者就挂了，此时存在Broker里的点位不就不准了吗？\n答：确实，按照这个设计此时如果发生了重平衡，就会导致消息重复消费。这个设计没法保证消息只会被消费一次。因此我们只能做好消费者的幂等，使得消费多次消息和消费一次达到的效果一样。\n扩展：常用的业务幂等性保证方法\n一文讲透消息队列RocketMQ实现消费幂等-腾讯云开发者社区-腾讯云 (tencent.com)\n只靠mq无法实现业务幂等性，要结合业务场景 利用数据库的唯一约束实现幂等：如将订单表中的订单编号设置为唯一索引，创建订单时，根据订单编号就可以保证幂等； 去重表：和上一个本质相同，首先在去重表上建唯一索引，其次操作时把业务表和去重表放在同个本地事务中，如果出现重现重复消费，数据库会抛唯一约束异常，操作就会回滚 利用redis的原子性：每次操作都直接set到redis里，然后将redis数据定时同步到数据库中； 多版本（乐观锁）控制：适用于更新场景。给业务数据增加一个版本号属性，每次更新数据前，比较当前数据的版本号是否和消息中的版本一致，如果不一致则拒绝更新数据，更新数据的同时将版本号+1 Token机制：生产者发送每条数据的时候，增加一个全局唯一的id，这个id通常是业务的唯一标识，比如订单编号。在消费端消费时，则验证该id是否被消费过，如果还没消费过，则进行业务处理。处理结束后，在把该id存入redis，同时设置状态为已消费。如果已经消费过了，则不进行处理。 状态机机制：多用于更新且业务场景存在多种状态流转的场景 怎么消费消息 前面提到 pull 到消息后会构建ConsumeRequest 提交到线程池 ConsumeMessageService。\n线程池有两个实现：\n并发消费（常用） 顺序消费 假设线程池消息消费失败了咋办？\nRMQ的实现是将消息消费失败的消息返回发送给Broker，这个消息会被发送给一个特定的重试Topic： “%RETRY%+consumerGroup”\n这样就失败消息就不会阻塞原来Topic上的其他消息，而是在重试队列上等待后续的重试消费；如果多次重试还是失败（默认16次），就会把它打入死信队列，需要人工介入处理。\n总结 消息在mq上生产、消费的关键链路流程:\nnameSrv启动，待命； Broker启动，把自己的IP、端口、Topic等上传给nameSrv，等待Producer发送消息，等待Consumer消费消息； Producer启动，连接nameSrv并获取Broker信息，跟对应Broker建立连接，连上之后发消息给Broker； Broker将消息存储到commitlog文件中，并分发到consumeQueue，等待consumer来拉取消息消费； Consumer启动，连接nameSrv并获取Broker信息，跟对应Broker建立连接，连上后发送pullRequest给Broker； Broker根据对应的Topic、队列ID和消息点位，找到consumeQueue中的消息，再解析找到对应commitlog得到消息内容，返回给Consumer; Consumer消费消息，随后上报自己的消费进度给Broker。 【持续更新\u0026hellip;】\n","permalink":"https://erica423.github.io/posts/mq/","summary":"消息队列 MQ是干嘛的？消息的中转站，能存很多消息。 应用场景： 应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而","title":"消息队列"},{"content":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位的默认 int 位数为 4。 int类型 数据范围 int8 -128 ~ 127 int16 -32768 ~ 32767 int32 -2147483648 ~ 2147483647 (2 * 10^9) int64 -9223372036854775808 ~ 9223372036854775807 (9 * 10^18) uint8 0 ~ 255 uint16 0 ~ 65535 uint32 0 ~ 4294967295 uint64 0 ~ 18446744073709551615 1.2 二分查找 前提：有序数组，无重复元素\n重点：区间的定义（区间就是不变量！)\n写法1 [left, right]\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的\nif (target \u0026lt; nums[middle]) right = middle - 1，因为当前这个nums[middle] 一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1. left = mid + 1.\n写法2 [left, right)\nwhile (left \u0026lt; right)\nright = mid, left = mid + 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // [l, r]版本 func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid - 1 } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } // [l, r) func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt; r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } Go二分查找库函数：index := sort.Search(n int, f func(i int) bool) int)\n该函数使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True。 如果无法找到该index值，则该方法为返回n. ⚠️常用场景: 一般用于从一个已经排序的数组中找到某个值所对应的索引。 或者从字符串数组中，找到满足某个条件的最小索引值，比如etcd中的键值范围查询就用到了该方法。 1.3 原地移除元素 要求：删除数组中值等于val的元素，不可以使用额外的空间。\n重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 暴力做法：两层for循环，第一个for查找值等于val的元素，第二层for依次将后续元素提前一位覆盖掉前一位元素。 复杂度：O(n^2) O(1)\n快慢指针做法 实现一个快指针一个慢指针，用一个for循环解决。复杂度：O(n) O(1) 定义： 快指针：寻找组成新数组的元素（不含=val的元素）； 慢指针：指向更新 新数组下标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func removeElement(nums []int, target int) int { slow := 0 for fast := 0; fast \u0026lt; len(nums); fast ++ { if nums[fast] != val { nums[slow] = nums[fast] slow ++ } } nums = nums[:slow] return nums } // 双向双指针 func removeElement(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { for l \u0026lt;= r \u0026amp;\u0026amp; nums[l] != val { l ++ } for l \u0026lt;= r \u0026amp;\u0026amp; nums[r] != val { r -- } // 找到左侧的val和右侧的非val后开始覆盖，覆盖后继续寻找 if l \u0026lt; r { nums[l] = nums[r] l ++ r -- } } return l } 1.4 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 暴力：每个数平方后排序，时间复杂度O(n + nlogn)\n双指针 i 指向起始位置，j 指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。\n如果A[i] * A[i] \u0026lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 。\n如果A[i] * A[i] \u0026gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func sortedSquares(nums []int) []int { n := len(nums) i, j, k := 0, n - 1, n - 1 res := make([]int, n) for i \u0026lt;= j { lm, rm := nums[i] * nums[i], nums[j] * nums[j] if lm \u0026gt; rm { res[k] = lm i ++ } else { res[k] = rm j -- } k -- } } 1.5 长度最小的连续子数组 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 暴力：两个for循环，时间复杂度 O(n^2)\n滑动窗口 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。 O(n)\n在本题中实现滑动窗口，主要确定如下三点：\n窗口内是什么？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n如何移动窗口的起始位置？ 如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n如何移动窗口的结束位置？ 窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n1 2 3 4 5 while (sum \u0026gt;= s) { subLen = (j - i + 1); res = min(res, subLen); sum -= nums[i ++ ];\t// 滑动窗口的精髓，不断变更起始位置 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func minSubArrayLen(target int, nums []int) int { n := len(nums) res := n + 1 i, sum := 0, 0 for j := 0; j \u0026lt; n; j ++ { sum += nums[j] for sum \u0026gt;= target { subLen := j - i + 1 res = min(res, subLen) sum -= nums[i] i ++ } } if res == n + 1 { return 0 } else { return res } } 1.6 (高频)螺旋矩阵II 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n示例:\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n求解本题依然是要坚持循环不变量原则。\n模拟顺时针画矩阵的过程:\n填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。\n可以看出拐角处是让给下一条边画的，也就是左闭右开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次 int mid = n / 2; // 矩阵的中心位置 int cnt = 1;// 用来给矩阵中每一个空格赋值 int offset = 1;// 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i, j; while (loop -- ) { i = startx; j = starty; // 上行 for (j; j \u0026lt; n - offset; j ++ ) { res[i][j] = cnt ++ ; } // 右列 for (i; i \u0026lt; n - offset; i ++ ) { res[i][j] = cnt ++ ; } // 下行 for (; j \u0026gt; starty; j -- ) { res[i][j] = cnt ++ ; } // 左列 for (; i \u0026gt; startx; i -- ) { res[i][j] = cnt ++ ; } // 第二圈开始的时候，起始位置要各自加1 startx ++ , startty ++ ; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } if (n % 2) { res[mid][mid] = cnt; } return res; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { startx, starty := 0, 0 var loop int = n / 2 var center int = n / 2 count := 1 offset := 1 res := make([][]int, n) for i := 0; i \u0026lt; n; i++ { res[i] = make([]int, n) } for loop \u0026gt; 0 { i, j := startx, starty //行数不变 列数在变 for j = starty; j \u0026lt; n-offset; j++ { res[startx][j] = count count++ } //列数不变是j 行数变 for i = startx; i \u0026lt; n-offset; i++ { res[i][j] = count count++ } //行数不变 i 列数变 j-- for ; j \u0026gt; starty; j-- { res[i][j] = count count++ } //列不变 行变 for ; i \u0026gt; startx; i-- { res[i][j] = count count++ } startx++ starty++ offset++ loop-- } if n % 2 == 1 { res[center][center] = n * n } return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u0026lt; n; i++ { matrix[i] = make([]int, n) } for num \u0026lt;= tar { for i := left; i \u0026lt;= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u0026lt;= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u0026gt;= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u0026gt;= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 空间复杂度 O(1) 2 链表 \u0026ldquo;https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\u0026quot;\n单链表：\n双链表：\n循环链表：解决约瑟夫环问题\n存储方式 链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义 C/C++ 定义链表节点\n1 2 3 4 5 6 7 8 9 // 单链表 struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 } // 初始化 ListNode* head = new ListNode(5) go 定义链表节点\n1 2 3 4 5 6 type ListNode struct { Val int Next *ListNode } head := new(ListNode) 2.1 删除链表元素 题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n如果删除的是头结点该怎么办呢？\n直接使用原来的链表来进行删除操作。 设置一个虚拟头结点在进行删除操作。 1 2 3 4 5 6 7 8 9 10 11 12 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { for head != nil \u0026amp;\u0026amp; head.Val == val { head = head.Next } } 这样移除了一个头结点，在单链表中移除头结点 和 移除其他节点的操作方式是不一样, 那么可不可以 以一种统一的逻辑来移除 链表的节点呢。\n可以设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026amp;ListNode{} dummyHead.Next = head cur := dummyHead // 当前的头指针 for cur != nil \u0026amp;\u0026amp; cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyHead.Next } 2.2 (基础) 设计链表 在链表类中实现这些功能：\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 设计五个接口：\n获取链表第index个节点的数值； 在链表的最前边插入一个节点 在最后插入一个节点 在第index个节点前面插入一个节点 删除第index个节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val) : val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while (index -- ) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size ++ ; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size ++ ; } void addAtIndex(int index, int val) { if (index \u0026gt; _size) return; if (index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size ++ ; } void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; tmp = nullptr; _size -- ; } // 打印 void printLinkedList() { LInkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package main import ( \u0026#34;fmt\u0026#34; ) type SingleNode struct { Val int Next *SingleNode } type MyLinkedList struct { dummyHead *SingleNode // 虚拟头结点 Size int // 链表大小 } func main() { list := Constructor() list.AddAtHead(100) list.AddAtTail(242) list.AddAtTail(777) list.AddAtIndex(1, 99999) list.printLinkedList() } // Initialize func Constuctor() MyLinkedList { newNode := \u0026amp;SingleNode { -999, nil, } return MyLinkedList{ dummyHead: newNode, Size: 0, } } func (m *MyLinkedList) Get(index int) int { if m == nil || index \u0026lt; 0 || index \u0026gt;= m.Size { return -1 } cur := m.dummyHead.Next for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } return cur.Val } func (m *MyLinkedList) AddAtHead(val int) { newNode := \u0026amp;SingleNode{Val: val} newNode.Next = m.dummyHead.Next m.dummyHead.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtTail(val int) { newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for cur.Next != nil { cur = cur.Next } cur.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtIndex(index int, val int) { if index \u0026lt; 0 { index = 0 } else index \u0026gt; m.Size { return } newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } newNode.Next = cur.Next cur.Next = newNode m.Size ++ } func (m *MyLinkedList) DeleteAtIndex(index int) { if index \u0026lt; 0 || index \u0026gt;= m.Size { return } cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } if cur.Next != nil { cur.Next = cur.Next.Next } m.Size -- } func (m *MyLinkedList) printLinkedList() { cur := m.dummyHead for cur.Next != nil { fmt.Println(cur.Next.Val) cur = cur.Next } } 循环双链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 type Node struct { Val int Next *Node Pre *Node } type MyLinkedList struct { dummy *Node } //仅保存哑节点，pre-\u0026gt; rear, next-\u0026gt; head /** Initialize your data structure here. */ func Constructor() MyLinkedList { rear := \u0026amp;Node{ Val: -1, Pre: nil, Next: nil, } rear.Next = rear rear.Pre = rear return MyLinkedList{rear} } func (m *MyLinkedList) Get(index int) int { head := m.dummy.Next for head != m.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { index -- head = head.Next } if 0 != index { return -1 } return head.Val } func (m *MyLinkedList) AddAtHead(val int) { dummy := m.dummy node := \u0026amp;Node{ Val: val, Pre: dummy, Next: dummy.Next, } dummy.Next.Pre = node dummy.Next = node } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { dummy := this.dummy rear := \u0026amp;Node{ Val: val, //rear.Next = dummy(哑节点) Next: dummy, //rear.Pre = ori_rear Pre: dummy.Pre, } //ori_rear.Next = rear dummy.Pre.Next = rear //update dummy dummy.Pre = rear //以上两步不能反 } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { head := this.dummy.Next //head = MyLinkedList[index] for head != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } if index \u0026gt; 0 { return } node := \u0026amp;Node{ Val: val, //node.Next = MyLinkedList[index] Next: head, //node.Pre = MyLinkedList[index-1] Pre: head.Pre, } //MyLinkedList[index-1].Next = node head.Pre.Next = node //MyLinkedList[index].Pre = node head.Pre = node //以上两步不能反 } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { //链表为空 if this.dummy.Next == this.dummy { return } head := this.dummy.Next //head = MyLinkedList[index] for head.Next != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } //验证index有效 if index == 0 { //MyLinkedList[index].Pre = index[index-2] head.Next.Pre = head.Pre //MyLinedList[index-2].Next = index[index] head.Pre.Next = head.Next //以上两步顺序无所谓 } } 2.3 (高频) 反转链表 思路：\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。 其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n双指针法 O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = null; while (cur) { temp = cur-\u0026gt;next; // 保存cur的下一个节点 cur-\u0026gt;next = pre; // 翻转操作 pre = cur; cur = temp; } } }; 递归法 不同的地方在初始化 O(n) O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: ListNode* reverse(ListNode* pre, ListNode* cur) { if (cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; return reverse(cur, temp); } ListNode* reverseList(ListNode* head) { return reverse(NULL, head); } }; Go版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 双指针写法 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } // 递归 func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode) *ListNode { if head == nil { return pre } tmp := head,Next head.Next = pre return help(head, tmp) } 2.4 两两交换相邻节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n用虚拟头结点，之后模拟就可以了。O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func swapPairs(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{ Next: head, } //head=list[i] //cur=list[i-1] cur := dummy for head != nil \u0026amp;\u0026amp; head.Next != nil { cur.Next = head.Next // cur-\u0026gt;2 tmp := head.Next.Next // tmp-\u0026gt;3 head.Next.Next = head // 3-\u0026gt;1 head.Next = tmp // 1-\u0026gt;3 //cur=list[(i+2)-1] cur = head //head=list[(i+2)] head = tmp // head-\u0026gt;3 } return dummy.Next } 2.5 删除链表的倒数第n个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n双指针 思路：双指针，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n定义fast和slow指针，初始值为虚拟头结点 fast走n + 1步，因为只有这样同时移动时slow才可以指向被删除节点的上一节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := \u0026amp;ListNode{0, head} fast, slow := dummy, dummy for i := 0; i \u0026lt;= n; i ++ {// 注意\u0026lt;=，否则快指针为空时，慢指针正好在倒数第n个上面 fast = fast.Next } for fast != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return dummy.Next } // O(n) O(1) 2.6 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目保证不存在环形，不能改变原链表。\n思路： 求两个链表交点节点的指针。（注意！是指针相等，不是数值相等）\ncurA指向链表A的头结点，curB指向链表B的头结点； 求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置； 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *curA = headA; ListNode *curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) { lenA ++ ; curA = curA -\u0026gt; next; } while (curB != NULL) { lenB ++ ; curB = curB -\u0026gt; next; } if (lenB \u0026gt; lenA) { // 让curA为最长链表的头 swap(lenA, lenB); swap(curA, curB); } int gap = lenA - lenB; while (gap -- ) { // 两链末尾对齐 curA = curA -\u0026gt; next; } while (curA != NULL) { // 遍历curA和curB，遇到相同则直接返回 if (curA == curB) return curA; curA = curA -\u0026gt; next; curB = curB -\u0026gt; next; } return NULL; } }; // O(n + m) O(1) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA, curB := headA, headB; lenA, lenB := 0, 0 for curA != nil { curA = curA.Next lenA ++ } for curB != nil { curB = curB.Next lenB ++ } var gap int var fast, slow *ListNode if lenA \u0026gt; lenB { gap = lenA - lenB fast, slow = headA, headB } else { gap = lenB - lenA fast, slow = headB, headA } for i := 0; i \u0026lt; gap; i ++ { fast = fast.Next } for fast != slow { // 遍历两个链表，遇到相同的就跳出遍历 fast = fast.Next slow = slow.Next } return fast } // 双指针 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { a, b := headA, headB for a != b { if a != nil { a = a.Next } else { a = headB } if b != nil { b = b.Next } else { b = headA } } return a } 2.7 环形链表II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n考察：\n判断链表是否有环\n快慢指针。fast += 2, slow ++ , 如果 fast 和 slow指针在途中相遇 （必在环中相遇），说明这个链表有环。 有环的话如何找到入口\n从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，此时从 head 和 相遇点，同时查找直至相遇 if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head // 返回环的入口 } } return nil } 哈希表（散列表） 一般哈希表都用快速判断一个元素是否出现在集合里。\nhash function：把某个信息映射到哈希表上的索引。\nhash collisions（哈希碰撞\\冲突）：e.g. 多个姓名都映射到了同一个索引下标。\n拉链法： 线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。 哈希结构：\n数组 集合 set 映射 map c++ 底层：\n集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) **go呢？**go中的hash结构通常是指map，底层是 数组+单链表\nhttps://blog.csdn.net/vince1998/article/details/137185380\n做题技巧：\n题目提示只有小写字母，暗示用数组做哈希。大小不受限，不用数组。 数组大小有限 或 数组空间大但哈希值少，分散，建议set。 要返回下标，不能排序，用map\u0026lt;key, value\u0026gt;结构返回两者。 哈希vs双指针：哈希法对于需要去重的题目效率较低，建议使用双指针。 3.1 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 输出: true\n示例 2: 输入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 输出: false\n说明: 你可以假设字符串只包含小写字母。\n暴力：两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。 哈希表：定一个数组叫做record，大小为26，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。O(n) O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 func isAnagram(s string, t string) bool { record := [26]int{} for _, v := range s { record[v - rune(\u0026#39;a\u0026#39;)] ++ } for _, v := range t { record[v - rune(\u0026#39;a\u0026#39;)] -- } return record == [26]int{} } 3.2 两个数组的交集 使用数组来做哈希的题目，是因为题目都限制了数值的大小。\n没有限制数值的大小就无法使用数组来做哈希表了。\n而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solultion { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; res; unordered_set\u0026lt;int\u0026gt; nums(nums1.begin(), nums1.end()); for (auto num: nums2) { if (nums.find(num) != nums.end()) { res.insert(num); } } return vector\u0026lt;int\u0026gt;(res.begin(), res.end()); } }; // O(n + m) m是最后要把set转成vector // O(n) go:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func intersection(nums1 []int, nums2 []int) []int { set := make(map[int]struct{}, 0) // map模拟set res := make([]int, 0) for _, v := range nums1 { if _, ok := set[v]; !ok { set[v] = struct{}{} } } for _, v := range nums2 { // if exists in the last array, insert into res, and delete this set value. if _, ok := set[v]; ok { res = append(res, v) delete(set, v) // delete(map, key) } } return res } // v2: use array when the number of data is small func intersection(nums1 []int, nums2 []int) []int { count1 := make([]int, 1001, 1001) count2 := make([]int, 1001, 1001) res := make([]int, 0) for _, v := range nums1 { count1[v] = 1 } for _, v := range nums2 { count2[v] = 1 } for i := 0; i \u0026lt;= 1000; i ++ { if count1[i] + count2[i] == 2 { res = append(res, i) } } return res } 3.3 快乐树 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n思路：判断sum是否重复出现过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while (1) { int sum = getSum(n); if (sum == 1) { return true; } if (set.find(sum) != set.end()) { return false; // sum出现过，死循环了 } else { set.insert(sum); } n = sum; } } // O(logn) O(logn) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getSum(n int) int { sum := 0 for n \u0026gt; 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } func isHappy(n int) bool { m := make(map[int]bool) for n != 1 \u0026amp;\u0026amp; m[n] == 0 { n, m[n] = getSum(n), true } return n == 1 } 3.4 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n242. 有效的字母异位词 (opens new window)这道题目是用数组作为哈希表来解决哈希问题，349. 两个数组的交集 (opens new window)这道题目是通过set作为哈希表来解决哈希问题。\n强调一下 什么时候使用哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n再来看一下使用数组和set来做哈希法的局限。（c++）\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 暴力 func twoSum(nums []int, target int) []int { for k1, _ := range nums { for k2 := k1 + 1; k2 \u0026lt; len(nums); k2 ++ { if target == nums[k1] + nums[k2] { return []int{k1, k2} } } } return []int{} } // map func twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if pre, ok := m[target - v]; ok { return []int{pre, i} } else { m[v] = i } } return []int{} } 3.5 四数相加II (经典题目) 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\n思路 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 最后返回统计值 count 就可以了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) // k: a+b v: a+b数值出现的次数 count := 0 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1 + v2] ++ } } for _, v3 := range nums3 { for _, v4 := range nums4 { count += m[-v3-v4] } } return count } 3.6 赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\nhttps://leetcode.cn/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func canConstruct(ransomNote string, magazine string) bool { if len(ransomNote) \u0026gt; len(magazine) { return false } cnt := [26]int{} for _, v := range magazine { cnt[v - \u0026#39;a\u0026#39;] ++ } for _, v := range ransomNote { cnt[v - \u0026#39;a\u0026#39;] -- if cnt[v - \u0026#39;a\u0026#39;] \u0026lt; 0 { return false } } return true } 3.7 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n要点：去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); // find a+b+c=0 for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (nums[i] \u0026gt; 0) return res; // 去重a，这里不能是nums[i] == nums[i + 1] if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int l = i + 1; int r = nums.size() - 1; while (r \u0026gt; l) { if (nums[i] + nums[l] + nums[r] \u0026gt; 0) r -- ; else if (nums[i] + nums[l] + nums[r]) l ++ ; else { res.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[l], nums[r]}); // 去重b和c放在找到一个三元组之后 while (r \u0026gt; l \u0026amp;\u0026amp; nums[r] == nums[r - 1]) r -- ; while (r \u0026gt; l \u0026amp;\u0026amp; nums[l] == nums[l + 1]) l ++ ; // 找到答案时双指针同时收缩 r -- , l ++ ; } } } return res; } 我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\n两数之和 就不能使用双指针法，因为1.两数之和 (opens new window)要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。\n如果1.两数之和 (opens new window)要求返回的是数值的话，就可以使用双指针法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func threeSum(nums []int) [][]int { sort.Ints(nums) res := [][]int{} for i := 0; i \u0026lt; len(nums) - 2; i ++ { n1 := nums[i] if n1 \u0026gt; 0 { return res } if i \u0026gt; 0 \u0026amp;\u0026amp; n1 == nums[i - 1] { continue } l, r := i + 1, len(nums) - 1 for l \u0026lt; r { n2, n3 := nums[l], nums[r] if n1 + n2 + n3 == 0 { res = append(res, []int{n1, n2, n3}) for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == n2 { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == n3 { r -- } } else if n1 + n2 + n3 \u0026gt; 0 { r -- } else { l ++ } } } return res } 3.8 四数之和 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n思路：和三数之和一样使用 双指针 ，基本思路就是在此基础上加一层for循环。\n细节：不能判断了nums[k] \u0026gt; target就返回，因为target是任意值，遇到负数就不好直接跳出了；\n但可以做剪枝， nums[i] \u0026gt; target \u0026amp;\u0026amp; (nums[i] \u0026gt;= 0 || target \u0026gt;= 0)\n15.三数之和 (opens new window)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。\n四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。\n那么一样的道理，五数之和、六数之和等等都采用这种解法。\n对于15.三数之和 (opens new window)双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。\n之前我们讲过哈希表的经典题目：454.四数相加II (opens new window)，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。\n双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func fourSum(nums []int, target int) [][]int { if len(nums) \u0026lt; 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u0026lt; len(nums) - 3; i ++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] { continue } for j := i + 1; j \u0026lt; len(nums) - 2; j ++ { if j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1] { continue } l, r := j + 1, len(nums) - 1 for l \u0026lt; r { sum := nums[i] + nums[j] + nums[l] + nums[r] if sum \u0026lt; target { l ++ } else if sum \u0026gt; target { r -- } else { res = append(res, []int{nums[i], nums[j], nums[l], nums[r]}) // 去重 for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == nums[l + 1] { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == nums[r - 1] { r -- } // 找到答案时，l r同时靠近 r -- l ++ } } } } return res } 4 字符串 4.1 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1： 输入：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\n思路：\n双指针。字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。\n对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。 1 2 3 4 5 6 7 8 func reverseString(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.2 反转2 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseStr(s string, k int) string { bs := []byte(s) for i := 0; i \u0026lt; len(s); i += 2 * k { if i + k \u0026lt; len(bs) { reverse(bs[i: i + k]) } else { reverse(bs[i: len(s)]) } } return string(bs) } func reverse(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.3 替换数字 go字符串和C++的区别：\ngo中的string类型是不可修改的，需要转换成[]byte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { var bs []byte fmt.Scanln(\u0026amp;bs) for i := 0; i \u0026lt; len(bs); i ++ { if bs[i] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; bs[i] \u0026gt;= \u0026#39;0\u0026#39; { insertNum := []byte{\u0026#39;n\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;r\u0026#39;} bs = append(bs[:i], append(insertNum, bs[i+1:]...)...) i = i + len(insertNum) - 1 } } fmt.Printf(string(bs)) } 4.4 翻转字符串里的单词（复杂题目） 给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1： 输入: \u0026ldquo;the sky is blue\u0026rdquo; 输出: \u0026ldquo;blue is sky the\u0026rdquo;\n示例 2： 输入: \u0026quot; hello world! \u0026quot; 输出: \u0026ldquo;world! hello\u0026rdquo; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: \u0026ldquo;a good example\u0026rdquo; 输出: \u0026ldquo;example good a\u0026rdquo; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n思路：\n移除多余空格\n整体翻转\n单词翻转\n要求：不适用辅助空间，空间复杂度O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func reverseWords(s string) string { b := []byte(s) // 移除前面、中间、后面存在的多余空格 slow := 0 for i := 0; i \u0026lt; len(b); i++ { if b[i] != \u0026#39; \u0026#39; { if slow != 0 { b[slow] = \u0026#39; \u0026#39; slow++ } for i \u0026lt; len(b) \u0026amp;\u0026amp; b[i] != \u0026#39; \u0026#39; { // 复制逻辑 b[slow] = b[i] slow++ i++ } } } b = b[0:slow] // 翻转整个字符串 reverse(b) // 翻转每个单词 last := 0 for i := 0; i \u0026lt;= len(b); i++ { if i == len(b) || b[i] == \u0026#39; \u0026#39; { reverse(b[last:i]) last = i + 1 } } return string(b) } func reverse(b []byte) { left := 0 right := len(b) - 1 for left \u0026lt; right { b[left], b[right] = b[right], b[left] left++ right-- } } 4.5 右旋字符串 字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。\n例如，对于输入字符串 \u0026ldquo;abcdefg\u0026rdquo; 和整数 2，函数应该将其转换为 \u0026ldquo;fgabcde\u0026rdquo;。\n思路：先整体反转，再局部反转。abcdefg =\u0026gt; gf | edcba =\u0026gt; fg | abcde\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func reverse(s []byte, l, r int) { for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } func main() { var s string var k int fmt.Scanln(\u0026amp;k) fmt.Scanln(\u0026amp;s) bs := []byte(s) reverse(bs, 0, len(s) - 1) reverse(bs, 0, k - 1) reverse(bs, k, len(s) - 1) fmt.Println(string(bs)) } 4.6 实现strStr() 实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n示例 1: 输入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 输出: 2\n示例 2: 输入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 输出: -1\n说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。\nKMP算法： 解决字符串匹配问题。当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n当前不匹配位置i前面（包括i）所有子串中的最长相等前后缀的长度，即模式串上重新匹配的位置\n前缀：包含首字母，但不包含尾字母的所有子串 后缀：反之\n为什么用前缀表？ 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。 e.g. 文本串：aabaabaaf 模式串：aabaaf，其前缀表为：010120 next数组| prefix数组\n实现：在匹配时，在模式串f处发生冲突，接下来看f前一位的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\nnext数组的不同实现 整体右移，首位添加-1 ： -1 0 1 0 1 2\n实现：在匹配时，在模式串f处发生冲突，看f的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\n整体减1： -1 0 -1 0 1 -1\n子串 最长相等前后缀长度 a 0 aa 1 (a a) aab 0 aaba 1 (a a) aabaa 2 (aa aa) aabaaf 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 前缀表不减一 or 右移 func getNext(next []int, s string) { j := 0 // j表示 最长相等前后缀长度 next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j] { j = next[j - 1] } if s[i] == s[j] { j ++ } next[i] = j // next[i]是i（包括i）之前的最长相等前后缀长度 } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := 0 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; hayStack[i] != needle[j] { j = next[j - 1] } if hayStack[i] == needle[j] { j ++ } if j == n { return i - n + 1 } } return -1 } // 减一实现 func getNext(next []int, s string) { j := -1 next[0] = -1 for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] // 回退前一位 } if s[i] == s[j + 1] { j ++ } next[i] = j } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := -1 // 模式串的起始位置 next为-1 因此也为-1 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; hayStack[i] != needle[j + 1] { j = next[j] } if hayStack[i] == needle[j + 1] { j ++ } if j == n - 1 { return i - n + 1 } } return -1 } 4.7 重复子串 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n示例 1:\n输入: \u0026ldquo;abab\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: \u0026ldquo;aba\u0026rdquo; 输出: False 示例 3:\n输入: \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或者子字符串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。 思路：\n1.移动匹配 判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。\n1 2 3 4 5 6 7 func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } t := s + s return strings.Contains(t[1:len(t)-1], s) } 2.KMP 最小重复子串：因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\nlen % (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func repeatedSubstringPattern(s string) bool { n := len(s) if len(s) == 0 { return false } j := -1 next := make([]int, len(s)) next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] } if s[i] == s[j + 1] { j ++ } next[i] = j } // next[n-1]+1 最长相同前后缀的长度 if next[n-1] != -1 \u0026amp;\u0026amp; n%(n-(next[n-1]+1)) == 0 { return true } return false } 双指针法（完） 1.3 移除元素\n4.1 反转字符串\n4.3 替换数字\n4.4 翻转串里的单词\n2.3 翻转链表\n2.5\n2.6\n2.7\n3.7\n3.8\n栈和队列（完） go栈\n1 2 3 4 5 6 7 8 9 // create stack stack := make([]int, 0) // push stack = append(stack, 10) // pop val := stack[len(stack)-1] stack = stack[:len(stack)-1] // empty len(stack) == 0 go queue\n1 2 3 4 5 6 7 8 9 // create queue := make([]int, 0) // enqueue queue = append(queue, 10) // dequeue val := queue[0] queue = queue[1:] // empty len(queue) == 0 6.1 栈模拟队列 1 queue = 1 输入stack + 1 输出stack\npush：入队 = 入栈 pop：if输出栈空，就将输入栈中数据all导入输出栈，再从输出栈pop；if输出栈不空，就直接pop empty：if输入栈和输出栈都为空了，则模拟的队列为空。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // ------------stack------------- type MyStack []int func (s *MyStack) Push(v int) { *s = append(*s, v) } func (s *MyStack) Pop() int { val := (*s)[len(*s) - 1] *s = (*s)[:len(*s) - 1] return val } func (s *MyStack) Peek() int { return (*s)[len(*s) - 1] } func (s *MyStack) Size() int { return len(*s) } func (s *MyStack) Empty() bool { return s.Size() == 0 } // ------------queue------------- type MyQueue struct { stackIn *MyStack stackOut *MyStack } func Constructor() MyQueue { return MyQueue { stackIn: \u0026amp;MyStack{}, stackOut: \u0026amp;MyStack{}, } } func (this *MyQueue) Push(x int) { this.stackIn.Push(x) } func (this *MyQueue) Pop() int { this.fillStackOut() return this.stackOut.Pop() } func (this *MyQueue) Peek() int { this.fillStackOut() return this.stackOut.Peek() } func (this *MyQueue) Empty() bool { return this.stackIn.Empty() \u0026amp;\u0026amp; this.stackOut.Empty() } // 填充输出栈 func (this *MyQueue) fillStackOut() { if this.stackOut.Empty() { for !this.stackIn.Empty() { val := this.stackIn.Pop() this.stackOut.Push(val) } } } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 6.2 队列模拟栈 一个队列就可以模拟栈 （如果非要用两个队列，另一个队列仅起到保存元素的作用）\npush：=入栈 pop：将队头元素重新加入队列尾，再弹出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type MyStack struct { queue []int } func Constructor() MyStack { return MyStack { queue: make([]int, 0), } } func (this *MyStack) Push(x int) { this.queue = append(this.queue, x) } func (this *MyStack) Pop() int { n := len(this.queue) - 1 for n != 0 { val := this.queue[0] this.queue = this.queue[1:] this.queue = append(this.queue, val) n -- } val := this.queue[0] this.queue = this.queue[1:] return val } func (this *MyStack) Top() int { val := this.Pop() this.queue = append(this.queue, val) // pop完要重新添加回去 return val } func (this *MyStack) Empty() bool { return len(this.queue) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 6.3 括号匹配 在写代码之前要分析好有哪几种不匹配的情况:\n第一种情况，字符串里左方向的括号多余了 ，所以不匹配。\n第二种情况，括号没有多余，但是 括号的类型没有匹配上。\n第三种情况，字符串里右方向的括号多余了，所以不匹配。\n还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // O(n) O(n) func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } stk := make([]rune, 0) for i := 0; i \u0026lt; n; i ++ { if s[i] == \u0026#39;[\u0026#39; { stk = append(stk, \u0026#39;]\u0026#39;) } else if s[i] == \u0026#39;(\u0026#39; { stk = append(stk, \u0026#39;)\u0026#39;) } else if s[i] == \u0026#39;{\u0026#39; { stk = append(stk, \u0026#39;}\u0026#39;) } else if len(stk) == 0 || stk[len(stk) - 1] != rune(s[i]) { // 如果是右括号，如果栈空 或 栈里没有可以匹配的元素 return false } else { stk = stk[:len(stk) - 1] // pop } } // 遍历完了看时候有剩余 return len(stk) == 0 } 6.4 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\n输入：\u0026ldquo;abbaca\u0026rdquo; 输出：\u0026ldquo;ca\u0026rdquo; 解释：例如，在 \u0026ldquo;abbaca\u0026rdquo; 中，我们可以删除 \u0026ldquo;bb\u0026rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \u0026ldquo;aaca\u0026rdquo;，其中又只有 \u0026ldquo;aa\u0026rdquo; 可以执行重复项删除操作，所以最后的字符串为 \u0026ldquo;ca\u0026rdquo;。 提示：\n1 \u0026lt;= S.length \u0026lt;= 20000 S 仅由小写英文字母组成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func removeDuplicates(s string) string { stack := make([]rune, 0) for _, val := range s { if len(stack) == 0 || val != stack[len(stack)-1] { stack = append(stack, val) } else { stack = stack[:len(stack)-1] } } var res []rune for len(stack) != 0 { // 将栈中元素放到result字符串汇总 res = append(res, stack[len(stack)-1]) stack = stack[:len(stack)-1] } // 此时字符串需要反转一下 l, r := 0, len(res)-1 for l \u0026lt; r { res[l], res[r] = res[r], res[l] l++ r-- } return string(res) } 这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。\n可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。\n此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。\n游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。\n而且在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）\n6.5 逆波兰式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { // is operation c1, c2 := stack[len(stack) - 2], stack[len(stack) - 1] stack = stack[:len(stack) - 2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, c1 + c2) case \u0026#34;-\u0026#34;: stack = append(stack, c1 - c2) case \u0026#34;*\u0026#34;: stack = append(stack, c1 * c2) case \u0026#34;/\u0026#34;: stack = append(stack, c1 / c2) } } } return stack[0] } 6.6 滑动窗口最大值 （经典：单调队列） 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值。\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 1 \u0026lt;= k \u0026lt;= nums.length 进阶：你能在线性时间复杂度内解决此题吗？\n用一个队列维护当前窗口，随着窗口移动，队列一进一出，希望队头是最大元素。\n要保证队列内元素单调递减（增） –》 单调队列\n但不需要维护窗口里的所有元素，只需要维护可能成为最大值的元素。如果下一个元素比上一个大，那么上一个出队，保存下一个，直到遇到比上一个小的，上一个元素不动，继续保留小于当前值的最大值。\n设计单调队列的时候，pop，和push操作要保持如下规则：\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // O(n) O(k) // 封装单调队列的方式解题 type MyQueue struct { queue []int } func NewMyQueue() *MyQueue { return \u0026amp;MyQueue{ queue: make([]int, 0), } } func (m *MyQueue) Front() int { return m.queue[0] } func (m *MyQueue) Back() int { return m.queue[len(m.queue)-1] } func (m *MyQueue) Empty() bool { return len(m.queue) == 0 } func (m *MyQueue) Push(val int) { for !m.Empty() \u0026amp;\u0026amp; val \u0026gt; m.Back() { m.queue = m.queue[:len(m.queue)-1] } m.queue = append(m.queue, val) } func (m *MyQueue) Pop(val int) { if !m.Empty() \u0026amp;\u0026amp; val == m.Front() { m.queue = m.queue[1:] } } func maxSlidingWindow(nums []int, k int) []int { queue := NewMyQueue() length := len(nums) res := make([]int, 0) // 先将前k个元素放入队列 for i := 0; i \u0026lt; k; i++ { queue.Push(nums[i]) } // 记录前k个元素的最大值 res = append(res, queue.Front()) for i := k; i \u0026lt; length; i++ { // 滑动窗口移除最前面的元素 queue.Pop(nums[i-k]) // 滑动窗口添加最后面的元素 queue.Push(nums[i]) // 记录最大值 res = append(res, queue.Front()) } return res } 6.7 前k个高频元素（经典：优先队列/堆） 统计出现元素的频率 map:[key, value] 对频率排序 priority queue / 取前k个频率的元素 什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。\n那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。\n而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？\n所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 快排 func topKFrequent(nums []int, k int) []int { res := []int{} cnt := make(map[int]int) for _, val := range nums { cnt[val] ++ } for k, _ := range cnt { res = append(res, k) } sort.Slice(res, func(a, b int) bool { return cnt[res[a]] \u0026gt; cnt[res[b]] }) return res[:k] // qian k } // 小顶堆 func topKFrequent(nums []int, k int) []int { map_num:=map[int]int{} //记录每个元素出现的次数 for _,item:=range nums{ map_num[item]++ } h:=\u0026amp;IHeap{} heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num{ heap.Push(h,[2]int{key,value}) if h.Len()\u0026gt;k{ heap.Pop(h) } } res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i\u0026lt;k;i++{ res[k-i-1]=heap.Pop(h).([2]int)[0] } return res } //构建小顶堆 type IHeap [][2]int func (h IHeap) Len()int { return len(h) } func (h IHeap) Less (i,j int) bool { return h[i][1]\u0026lt;h[j][1] } func (h IHeap) Swap(i,j int) { h[i],h[j]=h[j],h[i] } func (h *IHeap) Push(x interface{}){ *h=append(*h,x.([2]int)) } func (h *IHeap) Pop() interface{}{ old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x } Go: 深入理解堆实现及应用-腾讯云开发者社区-腾讯云 (tencent.com)\n堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或小于等于（最小堆）其子节点。Go语言中的堆通过container/heap包实现，该包提供了对数据结构进行堆操作的接口和方法。\n其他例题： 一维的堆实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func minRefuelStops(target, startFuel int, stations [][]int) (ans int) { stations = append(stations, []int{target, 0}) prePosition, curFuel := 0, startFuel fuelHeap := \u0026amp;hp{} for _, station := range stations { position, fuel := station[0], station[1] curFuel -= position - prePosition // 每行驶 1 英里用掉 1 升汽油 for fuelHeap.Len() \u0026gt; 0 \u0026amp;\u0026amp; curFuel \u0026lt; 0 { // 没油了 curFuel += heap.Pop(fuelHeap).(int) // 选油量最多的油桶 ans++ } if curFuel \u0026lt; 0 { // 无法到达 return -1 } heap.Push(fuelHeap, fuel) // 留着后面加油 prePosition = position } return } type hp struct{ sort.IntSlice } func (h hp) Less(i, j int) bool { return h.IntSlice[i] \u0026gt; h.IntSlice[j] } // 最大堆 func (h *hp) Push(v any) { h.IntSlice = append(h.IntSlice, v.(int)) } func (h *hp) Pop() any { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v } 二叉树 满二叉树 完全二叉树 二叉搜索树 平衡二叉搜索树 AVL 二叉树存储：\n链式 顺序：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树主要有两种遍历方式：\n深度优先遍历：先往深走，遇到叶子节点再往回走。 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历：一层一层的去遍历。 层次遍历（迭代法） 之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n二叉树定义\n1 2 3 4 5 6 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} } 1 2 3 4 5 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 7.1 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { // 注意入参 if node == nil { // 注意终止条件 return } // 前序遍历 res = append(res, node.Val) traversal(node.Left) traversal(node.Right) // 中序遍历 // ntraversal(node.Left) // res = append(res, node.Val) // traversal(node.Right) // 后序遍历 // traversal(node.Left) // traversal(node.Right) // res = append(res, node.Val) } traversal(root) return } 7.2 二叉树递归 确定递归函数入参和返回值 确定递归退出条件 确定单次递归内容 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n7.3 二叉树迭代 前后序用栈，后序用指针\nstk.Len()\nstk.PushBack(ndoe)\nstk.Back() 返回栈中的最后一个元素，即栈顶元素。\nstk.Remove(stk.Back()) 从栈中移除并返回最后一个元素。这里移除的元素是栈顶元素。\n(*TreeNode) 是类型断言，将移除的元素转换为 *TreeNode 类型。\n统一迭代 8 单调栈 最常见应用：找到序列中每个数左边（右边）离他最近的比他大（小或满足某条件）的数在哪\n8.1 每日温度 739.请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n思路：找到右边第一个比自己大的数\n在遍历过程中用栈记录右边第一个比当前大的元素，O(n). 栈中只存对应元素下标即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 暴力 func dailyTemperatures(t []int) []int { var res []int for i := 0; i \u0026lt; len(t) - 1; i ++ { j := i + 1 for ; j \u0026lt; len(t); j ++ { if t[j] \u0026gt; t[i] { res = append(res, j - i) break // 找到第一个就退出 } } if j == len(t) { // 如果找完了都没有 res = append(res, 0) } } return append(res, 0) // 最后一日肯定是0 } // 单调栈(增) func dailyTemperatures(t []int) []int { res := make([]int, len(t)) stk := []int{0} // 初始化栈顶元素为第一个下标索引0 for i := 1; i \u0026lt; len(t); i ++ { top := stk[len(stk) - 1] // 当前栈顶 if t[top] \u0026gt;= t[i] { stk = append(stk, i) } else { for len(stk) != 0 \u0026amp;\u0026amp; t[i] \u0026gt; t[top] { res[top] = i - top stk = stl[:len(stk)-1] // pop if len(stk) != 0 { top = stk[len(stk) - 1] // 更新栈顶 } } stk = append(stk, i) } } return res } // 单调栈(递减) func dailyTemperatures(t []int) []int { res: := make([]int, len(t)) stk := []int{} for i, v := range t { // 栈不空且当前遍历元素 v 破坏了栈的单调性 for len(stk) != 0 \u0026amp;\u0026amp; v \u0026gt; t[stk[len(stk)-1]] { // 大于当前栈顶，就pop，更新 top := stk[len(stk)-1] stk = stk[:len(stk)-1] res[top] = i - top } stk = append(stk, i) } return res } 8.2 下一个更大元素 I 496.给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n示例 1:\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1]\n没有重复元素，可以用map来做映射，可以根据数值快速找下标，并且可以判断nums2[i]是否在nums1中出现过。\nres数组默认值为-1（找不到）。\n遍历哪个数组呢？要在nums2里找比1里对应位置元素大的，所以遍历nums2\n情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况：此时满足递增栈（栈头到栈底的顺序），所以直接入栈。\n情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于\n情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。\n判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func nextGreaterElement(nums1 []int, nums2 []int) []int { res := make([]int, len(nums1)) for i := range res { res[i] = -1 } mp := map[int]int{} for i, v := range nums1 { mp[v] = i } stack := []int{} stack = append(stack, 0) // nums2下标 for i := 1; i \u0026lt; len(nums2); i ++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums2[i] \u0026gt; nums2[stack[len(stack)-1]] { top := stack[len(stack)-1] if _, ok := mp[nums2[top]]; ok { // 看map里是否存在这个元素 index := mp[nums2[top]] // 根据map找到nums2[top] 在 nums1中的下标 res[index] = nums2[i] } stack = stack[:len(stack)-1] } stack = append(stack, i) // \u0026lt;= } return res } 8.3 下一个更大元素 II 503.给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n示例 1:\n输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func nextGreaterElements(nums []int) []int { n := len(nums) res := make([]int, n) for i := range nums { res[i] = -1 } // 单调递减，存储数组下标 stk := make([]int, 0) for i := 0; i \u0026lt; n * 2; i ++ { for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[stk[len(stk)-1]] { index := stk[len(stk)-1] stk = stk[:len(stk)-1] res[index] = nums[i % n] } stk = append(stk, i % n) } return res } 8.4 接雨水（经典） 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 暴力双指针 按列计算：宽度一定是1，再求每一列的雨水高度。每一列的雨水有多高取决于两侧柱子中最短的一个。\n注意第一个和最后一个柱子不接雨水。 在for中求左右两边最高的柱子。 最后计算该列的雨水高度: 当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func trap(height []int) (sum int) { n := len(height) for i, h := range height { if i == 0 || i == n - 1 { continue } ml, mr := h, h for r := i + 1; r \u0026lt; n; r ++ { if height[r] \u0026gt; mr { mr = height[r] } } for l := i - 1; l \u0026gt;= 0; l -- { if height[l] \u0026gt; ml { ml = height[l] } } if min(ml, mr) - h \u0026gt; 0 { sum += min(ml, mr) - h } } return } // 时间复杂度为O(n^2)，空间复杂度为O(1) 双指针优化 为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。\n当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。\n即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);\n从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);\n单调栈 单调栈就是保持栈内元素有序。我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。\n【单调栈是按行计算】\n从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。\n遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func trap(height []int) (sum int) { if len(height) \u0026lt;= 2 { return 0 } stack := []int{} stack = append(stack, 0) // 第一个柱子 for i := range height { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; height[i] \u0026gt; height[stack[len(stack)-1]] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u0026gt; 0 { h := min(height[i], height[stack[len(stack)-1]]) - height[mid] w := i - stack[len(stack)-1] - 1 sum += h * w } } stack = append(stack, i) } return } 8.5 柱状图中的最大矩形 84.给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n1 2 3 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 【与接雨水的区别】要记录每个柱子左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 暴力双指针 func largestRectangleArea(height []int) int { n := len(height) minl := make([]int, n) minr := make([]int, n) minl[0] = -1 for i := 1; i \u0026lt; n; i ++ { t := i - 1 for t \u0026gt;= 0 \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minl[t] = minl[t], t } } minr[n - 1] = n for i := n - 2; i \u0026gt;= 0; i -- { t := i + 1 for t \u0026lt; n \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minr[t] = minr[t], t } } sum := 0 for i := 0; i \u0026lt; n; i ++ { s := height[i] * (minr[i] - minl[i] - 1) sum = max(sum, s) } return sum } 单调栈 42. 接雨水 (opens new window)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度\n注：在height数组头尾加一个0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func largestRectangleArea(heights []int) (res int) { stack := make([]int, 0) heights = append([]int{0}, heights...) heights = append(heights, 0) stack = append(stack, 0) for i := 1; i \u0026lt; len(heights); i ++ { for heights[stack[len(stack)-1]] \u0026gt; heights[i] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] sum := heights[mid] * (i - left - 1) if sum \u0026gt; res { res = sum } } stack = append(stack, i) } return res } 贪心 DP 基础题 背包：01、完全、多重 打家劫舍系列 股票问题 子序列问题 动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。\n问题分解：\n确定dp数组以及下标的含义 确定状态转移方程（递推公式） dp数组如何初始化 确定遍历顺序 举例推导dp数组 如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。\n如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。\n如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。\n509. 斐波那契数（入门） 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给你n ，请计算 F(n) 。\n示例 1：\n输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 提示：\n0 \u0026lt;= n \u0026lt;= 30 思路：\n确定dp数组及下表的意义：dp[i] 定义为第i个数的斐波那契数值 递推公式：题目给了 dp[i] = dp[i - 1] + dp[i - 2] 初始化：题目给了 dp[0] = 0, dp[1] = 1 遍历顺序：从公式看出，dp[i] 依赖 dp[i - 1]和dp[i - 2]，所以是从前到后遍历 举例推导dp数组：N = 10时，dp数组应该是：0 1 1 2 3 5 8 13 21 34 55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 递归 func fib(n int) int { if n \u0026lt; 2 { return n } return fib(n - 1) + fib(n - 2) } // dp func fib(n int) int { if n \u0026lt; 2 { return n } dp0, dp1, dp := 0, 1, 0 for i := 1; i \u0026lt; n; i ++ { dp = dp0 + dp1 dp0, dp1 = dp1, dp } return dp } 70. 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。\n示例 1：\n输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：\n输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 思路：\ndp[i]: 爬到第i层时，有dp[i]种方法 dp[i] = dp[i - 1] + dp[i - 2] 不考虑dp[0], dp[1] = 1, dp[2] = 2, 从3开始递推 顺序：从前到后 举例：n = 5时， dp数组：1 2 3 5 8 1 2 3 4 5 6 7 8 9 10 11 func climbStairs(n int) int { if n == 1 { return n } dp := make([]int, n + 1) dp[1], dp[2] = 1, 2 for i := 3; i \u0026lt;= n; i ++ { dp[i] = dp[i - 1] + dp[i - 2] } return dp[n] } 746. 最小花费爬楼梯 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n思路：\ndp[i] ： 到达第i个台阶所花费的最少费用\ndp[i] = dp[i - 1] + cost[i - 1], dp[i - 1] = dp[i - 2] + cost[i - 2].\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n初始化：根据题目意思，dp[0] = dp[1] = 0 (因为从0或1开题跳都可以，意思就是不计费)\n遍历顺序：从前到后\n举例推导：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n0 0 1 2 2 3 3 4 4 5 6\n1 2 3 4 5 6 7 8 func minCostClimbingStairs(cost []int) int { f := make([]int, len(cost) + 1) f[0], f[1] = 0, 0 for i := 2; i \u0026lt;= len(cost); i ++ { f[i] = min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2]) } return f[len(cost)] } 62. 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\ndp[i ] [j] : 表示从（0,0）出发到（i,j)的不同路径数 公式：dp[ i ] [ j ] = dp[i] [j - 1] + dp[i - 1] [j] （从左边和上边来的） 初始化：dp[i] [0] = 1, dp[0] [j] = 1 遍历顺序：从左到右一层层遍历即可 举例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j \u0026lt; n; j ++ { dp[0][j] = 1 } for i := 1; i \u0026lt; m; i ++ { for j := 1; j \u0026lt; n; j ++ { dp[i][j] = dp[i - 1][j] + dp[i][j - 1] } } return dp[m - 1][n - 1] } // 优化：二维简化到一维，滚动数组 T: O(mn), S: O(mn) -\u0026gt; O(n) // 数论做法：对于m行n列的矩形，走到终点都需要m+n-2步。在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。C_(m+m-2)^(m-1) //需要在计算分子的时候，不断除以分母 func uniquePaths(m int, n int) int { numerator := 1 denominator := m - 1 // fenmu cnt := m - 1 t := m + n - 2 for cnt \u0026gt; 0 { numerator *= t t -- for denominator != 0 \u0026amp;\u0026amp; numerator % denominator == 0 { numerator /= denominator denominator -- } cnt -- } return numerator } // O(m) O(1) 求组合的时候，要防止两个int相乘溢出！ 所以不能把算式的分子都算出来，分母都算出来再做除法。\n数位DP 数的大小和复杂度没什么关系，数位变化有关。\nf[i, mask, isLimit, isNum]\n返回从i开始填数字，i前面的数字的集合是mask，共构造出的特殊数的数量；is_limit表示前面填的数是否都是n对应位置上的，if true，则当前位之多为s[i], 否则至多为’9’; is_num表示前面是否填了数字（是否跳过），if true则当前可以从0开始，false可以跳过或从1开始。\n1 2 3 func f(i int, mask int, is_limit bool, is_num bool) int { if i == len(s) } 集合可以用二进制表示，二进制从低到高第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 对应的二进制数为 1101 (2)\n设集合对应的二进制数为 x。本题需要用到两个位运算操作：\n判断元素 d 是否在集合中：x \u0026raquo; d \u0026amp; 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 \u0026laquo; d)。\n单调栈 单调队列 KMP 给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。\n模式串 P 在字符串 S 中多次作为子串出现。\n求出模式串 P 在字符串 S 中所有出现的位置的起始下标。\n输入格式： 第一行输入整数 N，表示字符串 P 的长度。 第二行输入字符串 P。 第三行输入整数 M，表示字符串 S 的长度。 第四行输入字符串 S。\n输出格式 共一行，输出所有出现位置的起始下标（下标从0 开始计数），整数之间用空格隔开。\n数据范围 1≤N≤105 1≤M≤106\n输入样例： 3 aba 5 ababa\n输出样例： 0 2\n暴力 1 2 3 4 5 6 7 8 9 10 11 // S[N] p[M] for i := 1; i \u0026lt;= n; i ++ { // 从s[i]开始匹配看能不能成功 flag := true for j := 1; j \u0026lt;= m; j ++ { if s[i] != p[j] { // 出现匹配失败 flag = false break } } } 优化 KMP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // S[M] p[N] next[N] // kmp: 下标从1开始 for i := 1, j := 0; i \u0026lt;= m; i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j + 1] { j = next[j] // 退 } if s[i] == p[j + 1] { j ++ } if j == n { // success fmt.Println(i - n) // 下标从0 j = next[j] } } // 构建next数组 next := make([]int, n) for i := 2, j := 0; i \u0026lt;= n; i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j + 1] { j = next[j] } if p[i] == p[j + 1] { j ++ } next[i] = j } Trie树 高效存储和查找字符串集合的数据结构（字典） son[N][26] : cnt[N] : 以当前点为结尾的单词有几个 idx // 下标是0的点，既是根节点又是空节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import \u0026#34;fmt\u0026#34; const N = 100010 var ( idx = 0 cnt []int son [][]int ) func init() { son = make([][]int, N) for i := range son { son[i] = make([]int, 26) } cnt = make([]int, N) } func insert(s string) { p := 0 // root for i := range s { u := s[i] - \u0026#39;a\u0026#39; // cur if son[p][u] == 0 { idx ++ son[p][u] = idx + 1 } p = son[p][u] // 走到刚插进来的节点 } cnt[p] ++ } func query(s string) int { p := 0 for i := range s { u := s[i] - \u0026#39;a\u0026#39; if son[p][u] == 0 { return 0 } p = son[p][u] } return cnt[p] } func main() { var n int fmt.Scan(\u0026amp;n) for i := 0; i \u0026lt; n; i ++ { var op rune var s string fmt.Scanf(\u0026#34;%c %s\u0026#34;, \u0026amp;op, \u0026amp;s) if op == \u0026#39;I\u0026#39; { insert(s) } else if op == \u0026#39;Q\u0026#39; { fmt.Println(query(s)) } } } 并查集 将两个集合合并 询问两个元素是否在一个集合中 前缀和 1 2 3 4 5 6 7 8 9 10 11 s[i] = a[1] + a[2] + ... + a[i] for i := 1; i \u0026lt;= n; i ++ { s[i] = s[i - 1] + a[i] } for i := range n { for j := range m { s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] } } DFS BFS ","permalink":"https://erica423.github.io/posts/algorithm/","summary":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位","title":"算法"},{"content":"Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx、go-micro 等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。\n从零实现 Go 语言官方的标准库 net/rpc，并在此基础上，新增了：\n协议交换(protocol exchange) 注册中心(registry) 服务发现(service discovery) 负载均衡(load balance) 超时处理(timeout processing)等特性。 消息的序列化和反序列化 RPC调用：\n1 err := client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) 其中，客户端发送的请求包括：服务名Arith，方法名Multiply，参数args；服务端的响应包括错误信息err和返回值reply。\n","permalink":"https://erica423.github.io/posts/rpc/","summary":"Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx、go-micro 等都是非常成熟的框架。一般而言，RP","title":"RPC相关"},{"content":" GO在线编译器：go playground\nTest-Driven Development(TDD) - 测试驱动开发 周期：\n编写一个测试\n让编译通过\n运行测试，查看失败原因并检查错误消息是很有意义的\n编写足够的代码以使测试通过\n重构\n常用功能 测试文件命名规则：xxx_test.go, 与xxx.go放在同一个package下\n测试函数命令以Test开头\n测试函数只接受一个*testing.T类型的参数t （t就是测试框架中的钩子hook）\nt.Errorf(): 格式化记录错误信息，但测试继续进行。f 表示格式化，允许我们构建一个字符串，并将值插入占位符值 %q 中。\nt.Fatalf(): 报告致命错误，并终止测试。\nt.Fail(): 标记测试结果为失败的，不同的是t.Fail只把测试结果标记为失败，不会终止当前测试，t.FailNow则会立即终止当前的测试函数，并标记为失败。\nt.Helper(): 告诉测试套件这个方法是辅助函数（helper）。通过这样做，当测试失败时所报告的行号将在函数调用中而不是在辅助函数内部。\nSubtest - 子测试 有时，对一个「事情」进行分组测试，然后再对不同场景进行子测试非常有效。\n1 2 3 4 5 6 7 8 9 func TestMain(t *testing.T) { t.Run(\u0026#34;show expected output of this function\u0026#34;, func(t *testing.T) { }) t.Run(\u0026#34;...\u0026#34;, func(t *testing.T) { }) } 这种方法的好处是，你可以建立在其他测试中也能够使用的共享代码。 重要的是，你的测试清楚地说明了代码需要做什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func TestHello(t *testing.T) { assertCorrectMessage := func(t *testing.T, got, want string) { t.Helper() if got != want { t.Errorf(\u0026#34;got \u0026#39;%q\u0026#39; want \u0026#39;%q\u0026#39;\u0026#34;, got, want) } } t.Run(\u0026#34;saying hello to people\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;Chris\u0026#34;) want := \u0026#34;Hello, Chris\u0026#34; assertCorrectMessage(t, got, want) }) t.Run(\u0026#34;empty string defaults to \u0026#39;world\u0026#39;\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;\u0026#34;) want := \u0026#34;Hello, World\u0026#34; assertCorrectMessage(t, got, want) }) } 及时添加注释，方便生成API文档 Swagger自动生成文档\nsyntax 句法\nAdd AND assignment operactor 自增赋值运算符 +=\n数组 \u0026amp; 切片 we are using the %v placeholder to print the \u0026ldquo;default\u0026rdquo; format, which works well for arrays.\n在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种比较简单的办法是使用 reflect.DeepEqual，它在判断两个变量是否相等时十分有用。但不是类型安全的。\n接口 在 Go 语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。\n测试覆盖率 1 go test -cover Table driven tests - 表格驱动测试 适合处理同质化的测试内容, 如果你要测试一个接口的不同实现，或者传入函数的数据有很多不同的测试需求，这个武器将非常给力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func TestArea(t *testing.T) { areaTests := []struct { shape Shape want float64 }{ {Rectangle{10.0, 20.0}, 200.0}, {Circle{10.0}, 314.1592653589793}, } for _, tt := range areaTests { got := tt.shape.Area() if got != tt.want { t.Errorf(\u0026#34;want %.2f but got %.2f\u0026#34;, tt.want, got) } } } 使用了匿名结构体 - anonymous struct, 用含有两个域 shape 和 want 的 []struct 声明了一个结构体切片。\n可以改进错误输出为 %#v got %.2f want %.2f. %#v，这样会打印结构体中域的值。能一眼看出被测试的属性。\n关于列表驱动测试的最后一点提示是使用 t.Run。\n在每个用例中使用 t.Run，测试用例的错误输出中会包含用例的名字：\n1 2 3 -------- FAIL: TestArea (0.00s) --- FAIL: TestArea/Rectangle (0.00s) shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10 运行列表中指定的测试用例：go test -run TestArea/Rectangle\n检查未经检查的error 有一种情况我们还没有测试过。要找到它，在一个终端中运行以下命令来安装 errcheck，这是许多可用的 linters（代码检测工具）之一。\ngo get -u github.com/kisielk/errcheck\n然后，在代码目录中运行 errcheck .\n依赖注入： io.Writer 是一个很好的通用接口，用于「将数据放在某个地方」。\nfmt.Fprintf 和 fmt.Printf 一样，只不过 fmt.Fprintf 会接收一个 Writer 参数，用于把字符串传递过去，而 fmt.Printf 默认是标准输出。\n注入 - Mocking 将依赖关系定义为一个接口。这样我们就可以在 main 使用 真实的 Sleeper，并且在我们的测试中使用 spy sleeper。通过使用接口，我们的 Countdown 函数忽略了这一点，并为调用者增加了一些灵活性。\nConcurrency 匿名函数有许多有用的特性。首先，它们可以在声明的同时执行 —— 这就是匿名函数末尾的 () 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。\n上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（WebsiteChecker 函数）同时发生，每个循环都会将结果添加到 results map 中。\n1 2 3 4 5 6 7 for _, url := range urls { go func() { results[url] = wc(url) }() } time.Sleep(2 * time.Second) 这里的问题是变量 url 被重复用于 for 循环的每次迭代 —— 每次都会从 urls 获取新值。但是我们的每个 goroutine 都是 url 变量的引用 —— 它们没有自己的独立副本。所以他们 都 会写入在迭代结束时的 url —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url。\n1 2 3 4 5 6 7 for _, url := range urls { go func(u string) { results[u] = wc(u) }(url) } time.Sleep(2 * time.Second) 通过给每个匿名函数一个参数 url(u)，然后用 url 作为参数调用匿名函数，我们确保 u 的值固定为循环迭代的 url 值，重新启动 goroutine。u 是 url 值的副本，因此无法更改。\n用channel解决数据竞争 data race\ngoroutines 是 Go 的基本并发单元，它让我们可以同时检查多个网站。\nanonymous functions（匿名函数），我们用它来启动每个检查网站的并发进程。\nchannels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。\nthe race detector（竞争探测器） 帮助我们调试并发代码的问题。\n使用 select 时，time.After 是一个很好用的函数。当你监听的 channel 永远不会返回一个值时你可以潜在地编写永远阻塞的代码，尽管在我们的案例中它没有发生。time.After 会在你定义的时间过后发送一个信号给 channel 并返回一个 chan 类型（就像 ping 那样）。\nvalue 有一个方法 NumField，它返回值中的字段数\nSync Sync\nWaitGroup 等待 goroutine 集合完成。主 goroutine 调用 Add 设置等待的 goroutine 数量。然后每个 goroutine 运行并在完成时调用 Done。同时，Wait 可以用来阻塞，直到所有 goroutine 都完成。\n通过在做出断言之前等待wg.Wait()完成，我们可以确定所有的 goroutine 都已尝试Inc过Counter。\nA Mutex must not be copied after first use. Use channels when passing ownership of data\nUse mutexes for managing state\nContext context\n我们所做的是从我们的request中派生一个新的 cancellingCtx，它返回一个cancel函数。然后，我们使用 time.AfterFunc 安排在 5 毫秒内调用该函数。最后，我们通过调用 request.WithContext 在请求中使用这个新上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func Server(store Store) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { ctx := r.Context() data := make(chan string, 1) go func() { data \u0026lt;- store.Fetch() }() select { case d := \u0026lt;-data: fmt.Fprint(w, d) case \u0026lt;-ctx.Done(): store.Cancel() } } } context有一个方法Done()返回一个channel，当context“完成”或“取消”时，该通道会发送信号。 我们想要监听该信号并在收到该信号时调用 store.Cancel，但如果我们Store设法在Fetch它之前就忽略它。\n对服务器的传入请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传播上下文，可以选择将其替换为使用 WithCancel、WithDeadline、WithTimeout 或 WithValue 创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。\nProperty based tests strings.Builder 用于使用写入方法高效构建字符串。它最大限度地减少了内存复制。\n罗马数字的规则是同一字符不能在一行中重复超过 3 次。 取而代之的是取下一个最高的符号，然后在其左侧放置一个符号来 “减去”。 并非所有符号都可以用作减法器；只有 I (1)、X (10) 和 C (100)。\n例如，罗马数字中的 5 是 V。要创建 4，您不执行 IIII，而是执行 IV。\nRomanNumeral规则：\n不能有超过 3 个连续的符号\n只有 I (1), X (10) 和 C (100) 是 「减法器」\n将 ConvertToRoman(N) 的结果传递给 ConvertToArabic ，应该返回 N。\n基于属性的测试通过向代码中抛出随机数据并验证所描述的规则始终为真来帮助您做到这一点。很多人认为基于属性的测试主要是关于随机数据的，但他们是错误的。 基于属性的测试面临的真正挑战是你对你的领域有「很好的」理解，这样您就可以编写这些属性。\n从底部读取，我们为 quick.Check 提供了一个函数，它将运行一些随机的输入，如果函数返回 false，它将被视为检查失败。\n上面的 assertion 函数接受随机数并运行函数来测试属性。\n你不能用罗马数字表示负数\n根据我们最多 3 个连续符号的规则，我们不能表示大于 3999 的值 (罗马数字的最大值)，而 int 的最大值比 3999 大得多。 因此使用uint16\n内置的路由机制叫做 ServeMux（request multiplexer，多路请求复用器），它允许你将 http.Handler 附加到特定的请求路径。\nWe changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.\nGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.\n这意味着我们的 PlayerServer 现在已经有了 http.Handler 所有的方法，也就是 ServeHTTP。\n为了 “填充” http.Handler，我们将它分配给我们在 NewPlayerServer 中创建的 router。我们可以这样做是因为 http.ServeMux 具有 ServeHTTP 方法。\n这允许我们删除我们的 ServeHTTP 方法，因为我们已经通过嵌入类型公开了它。\n嵌入是一个非常有意思的语法特性。你可以用它将接口组成新的接口。\nIO和排序 服务器重启会重置积分\nos.OpenFile 允许你定义打开文件的权限，在我们的例子中，O_RDWR 意味着我们想要读写权限，os.O_CREATE 是指如果文件不存在，则创建该文件。\n创建一个新类型来封装我们的「当写入时，从头部开始」功能。我把它叫做 Tape.\nfile.Stat 返回我们的文件的统计数据。我们可以检查文件的大小，如果它是空的，我们就会编写一个空的 JSON 数组，然后 Seek 到开始位置，为剩下的代码做准备。\n命令行和项目结构 当用户输入 Ruth wins 时，它只需要能够记录玩家的胜出情况，最终目的是作为一个帮助用户玩扑克的工具。\n产品负责人希望在两个应用程序之间共享数据库，以便玩家league根据新程序中记录的wins进行更新。\n第一个需求就是当用户输入 {PlayerName} wins 时记录一次胜利。\nbufio 包实现了 I/O 缓冲。它封装了一个 io.Reader 或 io.Writer 对象，创建了另一个对象（Reader 或 Writer），也实现了接口，并为文本 I/O 提供了缓冲和一些帮助。\nScanner.Scan() 会逐行读取内容。 然后使用 Scanner.Text() 来返回 scanner 读取的 string。 我们将它封装到一个名为 readLine() 的函数中。\nBenchmarking - 基准测试 用 go test -bench=. 来运行基准测试。 (如果在 Windows Powershell 环境下使用 go test -bench=\u0026quot;.\u0026quot;)\nTips: benchmarks默认顺序执行。\n1 2 3 4 5 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u0026lt; b.N; i ++ { Repeat(\u0026#34;A\u0026#34;) } } testing.B 可使你访问隐性命名（cryptically named）b.N。\n基准测试运行时，代码会运行 b.N 次，并测量需要多长时间。\n代码运行的次数不会对你产生影响，测试框架会选择一个它所认为的最佳值，以便让你获得更合理的结果。\nGoConvey（测试框架） 1 2 import \u0026#34;github.com/smartystreets/goconvey/convey\u0026#34; go get github.com/smartystreets/goconvey convey.Convey 定义了测试用例名称、t 指针、测试代码。 convey.So` 用来判断预期结果。 convey 提供了大量的断言函数，比如刚才使用的 convey.ShouldBeTrue，就是判断 ok 的值应该为 true。\n1 2 3 4 5 6 func TestCheckUrl(t *testing.T) { convey.Convey(\u0026#34;TestCheckTeachUrl\u0026#34;, t, func() { ok:=CheckUrl(\u0026#34;learnku.com\u0026#34;) convey.So(ok,convey.ShouldBeTrue) }) } GoConvey 官方文档：Assertions · smartystreets/goconvey Wiki · GitHub\nTestify（断言） Testify 也是一个断言库，功能相对于 GoConvey 而言比较简单，主要是在提供断言功能之外，提供了 mock 的功能。\n1 2 import \u0026#34;github.com/stretchr/testify\u0026#34; go get -t github.com/stretchr/testify eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func TestCheckUrl3(t *testing.T) { assert := assert.New(t) var tests = []struct { input string expected bool }{ {\u0026#34;xdcute.com\u0026#34;, true}, {\u0026#34;xxx.com\u0026#34;, false}, } for _, test := range tests { fmt.Println(test.input) assert.Equal(CheckUrl(test.input), test.expected) } } GoMock（模拟接口） mock 工具的作用是指定函数的行为（模拟函数的行为）。可以对入参进行校验，对出参进行设定，还可以指定函数的返回值。\n并行测试 func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试。\nRunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。\n参考文章 \u0026ldquo;https://studygolang.gitbook.io/learn-go-with-tests/\u0026quot; \u0026ldquo;https://quii.gitbook.io/learn-go-with-tests/\u0026quot; ","permalink":"https://erica423.github.io/posts/singletest/","summary":"GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通","title":"单元测试"},{"content":" Go 1. 垃圾回收 (Garbage Collection) 垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。\n引用计数 标记 - 清除 缺点：需要STW（stop the world） 分代收集 GC的触发条件：\n主动触发：runtime.GC 被动触发：(1)步调算法pacing (2)系统控制 Go GC三色标记？【百度go二面】** 什么是GC三色标记法？ 一种垃圾回收算法，用于追踪和标记活跃对象。不活跃的就会被回收。\n三色标记法规则？ 黑：完全标记，确定活跃，不会回收\n白：初态，未标记和追踪，最后被回收\n灰：被发现但未完全追踪\n初始状态下所有对象都是白色的。GC开始，从根节点开始遍历所有对象，将直接可达的对象标记为灰色；\n遍历灰色集合，灰色对象直接可达的对象标记为灰色，自身标记为黑色；\n通过 写屏障(write-barrier) 检测对象有变化，重复2，直到灰色对象全部变成黑色；\n回收白色对象(垃圾)\n什么是强弱三色不变式？ 强三色不变式：不存在黑色对象引用白色对象；\n弱三色：所有被黑色引用的白色必须有灰色上游对象；\n目的：他们都解决的都是漏标问题（黑对白的引用)\n什么是写屏障？ 在特定程序运行时刻，当对对象的指针进行写操作（修改引用关系）时触发的处理机制。目的是确保GC过程能正确追踪对象的引用关系，防止错误或遗漏回收，仅作用于堆上的内存回收。\n插入写屏障：如果有黑指白，则把白变灰；\n删除写屏障：当灰色删除一个指向白色的关系，白色标记为灰色。\n什么是混合写屏障？\n插入+删除:\n在GC开始时将栈上对象全部扫描并标记为黑色（不进行二次scan） 在GC期间任何栈上创建的对象都标记为黑色，避免二次scan 在GC期间删除任何的对象都标记为灰色 在GC期间创建的任何对象都标记为灰色 栈区没有写屏障逻辑，加重运行负担；把新加进栈的直接标成黑色（减少stw次数）\n为什么面试会问这个？\n基本用不到，可能就调调参数回收时间等。\nSTW (Stop The World) 为了避免在垃圾回收 (GC) 的过程中，对象之间的引用关系发生新的变更，使GC的结果发生错误，停止所有正在运行的协程。 STW对性能有一些影响，但go目前已经可以做到1ms以下的STW。 写屏障 (Write Barrier) 为了减小STW对程序的影响，要通过写屏障尽可能缩短STW时间。\n造成引用对象丢失的条件: 一个黑色的节点A新增了指向白色节点C的引用，并且白色节点C没有除了A之外的其他灰色节点的引用，或者存在但是在GC过程中被删除了。以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明白色节点C无其他灰色节点的引用了，即扫描结束后会被忽略 。\n写屏障破坏两个条件其一即可\n破坏条件1：Dijistra写屏障\n满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色\n破坏条件2：Yuasa写屏障 满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色\nselect可以用于什么？ golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。每个case语句里必须是一个面向channel的IO操作。\nGo函数中为什么发生内存泄漏？ goroutine需要维护执行用户代码的上下文信息，在运行过程中需要消耗一定的内存来保存这类信息。如果一个程序持续不断地产生新的goroutine且不结束已创建的goroutine并复用这部分内存，就会造成内存泄漏。\nGoroutine发生了泄漏如何检测？ Go自带的工具pprof或者使用Gops检测诊断当前在系统上运行的go进程占用的资源。\nGo内存对齐？ CPU访问内存时，不是逐个字节访问，而是以字长(word size)为单位进行访问。如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节。\nCPU始终以字长访问内存，如果不进行内存对齐，很可能增加CPU访问内存的次数。\n可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的。如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。\nGo函数传参是值类型还是引用类型？ Go中只存在值传递，要么传的是值的副本，要么是指针的副本。无论是值类型的变量还是引用类型的变量还是指针类型的变量，在作为参数传递时都会发生copy，开辟新的内存空间。\n另外值传递、引用传递和值类型、引用类型是两个不同的概念，不要混淆了。引用类型作为变量传递可以影响到函数外部是因为发生值拷贝后新旧变量指向了相同的内存地址。\nGo主协程如何等其余协程结束再操作？ 使用sync.WaitGroup，用来等待一组操作完成。WaitGroup内部实现了一个计数器，用来记录未完成的操作个数；Add()用来添加计数；Done()用来在操作结束时调用，使计数-1； Wait()用来等待所有的操作结束，在计数不为0时等待，为0时立即返回。\n","permalink":"https://erica423.github.io/posts/question/","summary":"Go 1. 垃圾回收 (Garbage Collection) 垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 引用计数 标记 - 清除 缺点：需要STW（stop the world） 分代收集","title":"Q\u0026A | 面经"},{"content":"go语言slice和map底层实现原理 slice和map都是引用类型，长度不固定。\nslice底层： slice指向一个底层array，声明时不需要指定长度。\nappend函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。\nmap底层： map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是int类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。\nmap是无序的，如何map进行有序的排序？ 开一个空切片，把key拿出来，对key进行排序，再按排好序的key中map中拿value。\nslice的扩容机制 在使用 append 向 slice 追加元素时，若 slice 空间不足则会发生扩容，扩容会重新分配一块更大的内存，将原 slice 拷贝到新 slice ，然后返回新 slice。扩容后再将数据追加进去。\n扩容操作只对容量，扩容后的 slice 长度不变，容量变化规则如下：\n1.18版本之前：若 slice 容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。 若 slice 容量够用，则将新元素追加进去，slice.len++，返回原 slice 若 slice 容量不够用，将 slice 先扩容，扩容得到新 slice，将新元素追加进新 slice，slice.len++，返回新 slice。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { s1 := make([]int64, 0) for i := 0; i \u0026lt; 1025; i++ { s1 = append(s1, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s1), cap(s1)) // output: len = 1025, cap = 1280 s2 := make([]int32, 0) for i := 0; i \u0026lt; 1025; i++ { s2 = append(s2, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s2), cap(s2)) // output: len = 1025, cap = 1344 } 原因是golang库下runtime/slice.go中的growslice函数的逻辑。核心是后半的内存对齐。switch的几个case分支，就是针对不同类型的slice。以et.size == sys.PtrSize分支为例，其思想就是首先计算出slice的内存大小，然后调用roundupsize函数内存对齐，然后计算出最终的容量。\nroundupsize函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var size_to_class8 = [1024/8 + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var class_to_size = [68]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} func roundupsize(size uintptr) uintptr { if size \u0026lt; _MaxSmallSize { // 32K内存以内 // class_to_size 68个不同的内存长度（包含0），对应runtime/sizeclasses.go中表格 // 当小于等于1016时，从size_to_class8中找，结果时1到32，对应class_to_size中的index // 否则从size_to_class128中找，结果是32到68。 最终都是根据index到class_to_size中最终的结果。 // 其作用就是67个内存长度中找到大于等于size的最接近的长度。 应该是为了效率考虑，直接查的方式，比挨个比较的效率更高。空间换时间 if size \u0026lt;= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { fmt.Println(divRoundUp(size-smallSizeMax, largeSizeDiv)) return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } if size+_PageSize \u0026lt; size { // 这种情况只会发生在溢出时，变成负数了 return size } return alignUp(size, _PageSize) } // 按8192的倍数向上取整，采用位运算的方式，更加高效 func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026amp;^ (a - 1) } 到这里就可以解释int32的切片扩容后为什么是1344了:\n正常情况下，按照1.25被扩容后，容量为1024 * 1.25 = 1280; int32占4字节，其切片内存大小为，1280 * 4 = 5120; 通过查下面的表，可以得出大于等于5120的最接近的是5376; 最终的容量为 5376 / 4 = 1344 同样，也可以算出int64的切片内存对齐后，和原来是没有变化，仍然是1280。简单计算下：\n1280 * 8 = 10240; 查表仍然是10240 10240 / 8 = 1280。所以没有变化。 go 1.18版本后的修改 小于256时，双倍扩容；大于等于256时，扩容后容量 = 1.25倍的原容量 + 192。目的主要为了是内存的变化更加平滑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func growslice(et *_type, old slice, cap int) slice { // 省略。。。 newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } // 省略。。。 } 补充： int 类型大小为 8 字节, go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节; 如果是64位操作系统，int类型的大小就是8个字节\nint8 类型大小为 1 字节\nint16 类型大小为 2 字节\nint32 类型大小为 4 字节\nint64 类型大小为 8 字节\n取值范围\nint8: -128 ~ 127\nint16: -32768 ~ 32767\nint32: -2147483648 ~ 2147483647\nint64: -9223372036854775808 ~ 9223372036854775807\n结构体里的变量不加tag可以转json字符串吗？ 如果变量首字母小写，即为private变量，无论加不加tag都不可能转为json字段，因为获取不到反射信息。 反射？\n如果变量首字母大写，为public变量： 不加tag：可以转，json内字段名和结构体内字段原名一致； 加tag，转json的字段名就是tag里的字段名（也就是别名）。 生成json：jsonInfo, err := json.Marshal(struct_J)\n展示json内容：string(jsonInfo)\njson对象只支持string作为key。channel、complex、function不能被编码成json。\ngo语言TCP、UDP具体实现原理 TCP (Transmission Connect Protocol, 传输控制协议) 面向连接的、可靠的、基于字节流的传输层通信协议。提供了全双工通信、流量控制、错误控制等功能。\nTCP基本原理： 三次握手：通过三次握手建立TCP连接。 (1) client向server发送SYN包，请求连接；\n(2) server收到SYN包，向client发送SYN+ACK包，同意连接并确认client的SYN包；\n(3) client收到SYN+ACK包后，向server发送ACK包，确认连接。\n四次挥手：通过四次挥手断开TCP连接。 (1) client向server发送FIN包，表示不再发送数据；\n(2) server收到FIN包，向client发送ACK包，确认收到FIN包；\n(3) server向client发送FIN包，表示不再接收数据；\n(4) client收到FIN包后，向server发送ACK包，确认断连。\n流量控制：TCP使用滑动窗口机制进行流量控制。 server向client发送数据时，需要考虑client的接收能力，避免数据溢出。\n错误控制：TCP使用ACK和NACK机制进行错误控制。 当client收到server发送的数据时，需要发送ACK包确认。如果收到的数据有错，就发送NACK包。\nUDP (User Datagram Protocol, 用户数据报协议) 面向事务的、无连接、不可靠的传输层通信协议。 提供了简单快速的数据传输功能。\nUDP基本原理： 无连接：UDP不需要建立连接，数据包直接发送到目的地址。 不可靠：不提供可靠性保证，数据包可能丢失、错误或重复。 简单快速：UDP数据包的head只有8 byte，相对于TCP的20byte head更加简单快速。 Go语言的网络编程主要涉及以下几个核心概念： net包：Go语言提供了net包，用于实现网络编程。net包提供了TCP/UDP的基本功能，包括创建、监听、连接、读写等\nconn：conn是net包中的一个类型，表示一个网络连接。conn包含了连接的两端的地址和数据缓冲区。\nio包：Go语言的io包提供了一系列的读写器接口，用于实现各种数据流操作。网络编程中，我们经常使用io包的Reader和Writer接口来处理网络数据。\nbufio包：bufio包提供了基于缓冲的I/O功能，可以提高网络编程的性能。我们可以使用bufio包的Reader和Writer来实现高效的网络数据处理。\nTCP：使用 net.Dial/ net.Listen / conn.Write / conn.Read 等 UDP：使用 net.Dial / net.Listen / conn.Write / conn.ReadFrom / conn.SetReadDeadline 问：net.Listen和net.ListenTCPandnet.ListenUDP有啥区别？？\nnet.Listen()返回一个接口net.Listener，该接口只保证它支持以下方法：Accept()、Close()和Addr()。\nnet.ListenTCP()返回一个支持上述三种方法的类型*net.TCPListener，因此(鸭子类型duckTyping)它支持net.Listener接口。但是，它还支持更多特定于TCP的功能，并且可以控制连接接受的低级别方面。像设置SetDeadline()之类的事情。\n使用场景 Web服务：使用net/http包构建Web服务，提供RESTful API接口。 聊天室：使用TCP协议实现客户端和服务器之间的实时通信。 文件传输：使用UDP协议实现高速文件传输，例如P2P文件共享。 游戏服务器：使用TCP协议实现在线游戏服务器，处理玩家之间的实时通信和数据同步。 TCP和UDP的客户端实现 一致，只有net.Dial()的第一个参数不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Connect TCP conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) // Connect udp conn, err := net.Dial(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) TCP和UDP的服务端实现： 不同，在实现TCP时要用Listener接口监听和建立TCP连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // TCP l, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer l.Close() for { conn, err := l.Accept() if err != nil { return err } go handleConnection(conn) } func handleConnection(conn net.Conn) { // ... buffer := make([]byte, 1024) conn.Read(buffer) conn.Write([]byte(\u0026#34;Hello from server\u0026#34;)) } 实现UDP时用PacketConn接口取代了Conn接口和Listener。\n与类型Conn不同的是，PackerConn并不支持io.reader和io.writer接口，但是它支持两个特殊的读写方法ReadFrom() 和 WriteTo() 。WriteTo()方法需要提供一个参数作为发送的数据到哪个地址，ReadFrom()则返回数据是从哪个地址接收的。 1 2 3 4 5 6 7 8 9 10 // UDP pc, err := net.ListenPacket(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { log.Fatal(err) } buffer := make([]byte, 1024) pc.ReadFrom(buffer) pc.WriteTo([]byte(\u0026#34;Hello from client\u0026#34;), addr) go协程调度原理，协程为什么快？ goroutine的理解： goroutine，协程，是一种轻量级的用户线程（可以避免用户态到内核态的切换，从而节省了资源开销），由Go运行时调度器进行管理。Go中的每一个协程都会被分配到一个较小的栈空间（默认大小2KB），以非常低的成本进行创建和销毁。\ngoroutine的运行： Go运行时调度器采用了 M:N 的模型，即在M个操作系统线程上运行N个协程。具体来说，Go运行时初始化了一个或多个GOMAXPROCS指定数量的操作系统线程，并在这些线程上运行协程。\n​当一个协程阻塞时，调度器会自动将其与当前协程解除绑定，并将其转移到等待队列中，然后运行其它的协程，从而实现了高效地利用了CPU的时间片。\ngoroutine的优势： 协程不像传统多线程编程那样必须避免线程竞争和加锁解锁等操作。\n在Go中通常通过channel实现协程之间的同步和通信。Go的channel机制提供了一种非常有效且安全的协程同步方式，可以避免竞争条件和死锁等问题。\n同时，协程可以自我调节、自我管理，从而可以避免了频繁的线程切换带来的性能损耗。这使得协程有非常快的相应速度和高效的并发处理能力。\n扩展：\n并发(concurrency) vs 并行(parallelism) 在单个CPU 核上，线程通过时间片或者让出控制权来实现任务切换，达到 \u0026ldquo;同时\u0026rdquo; 运行多个任务的目的，这就是所谓的并发。但实际上任何时刻都只有一个任务被执行，其他任务通过某种算法来排队。\n只用多核CPU可以让同一进程内的\u0026quot;多个线程\u0026quot; 做到真正意义上的同时运行。\n进程 vs 线程 vs 协程 进程：系统进行资源分配的基本单位，占有独立的内存空间。\n线程：CPU调度和分配的基本单位，依附于进程存在，每个线程共享父进程的资源。\n线程的上下文切换？\n由于中断处理，多任务处理，用户态切换等原因会导致 CPU 从一个线程切换到另一个线程，切换过程需要保存当前进程的状态并恢复另一个进程的状态。代价是高昂的。\n协程：用户态的轻量级线程，调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。\nGoroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；\n线程栈空间通常是 2M，Goroutine 栈空间最小 2K；\nGolang 程序中可以轻松支持10w 级别的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。\nGo调度器是啥？ Go调度器模型通常叫做GPM模型，Go程序通过调度器来调度goroutine在内核线程上执行，但是goroutine（G）不直接绑定os线程（M）运行，而是由 goroutine scheduler 中的逻辑处理器（P）来作为获取内核线程资源的“中介”。\n包括4个重要结构，分别是G、P、M、Sched：(G砖头 M地鼠 P小车)\nG: Goroutine，协程，运行在线程上；每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。\nM: Machine，thread，即线程，循环调取协程并执行；OS 内核线程抽象，代表着真正执行计算的资源。在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取。\nM 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。\nM 并不保留 G 状态，这是 G 可以跨 M 调度的基础。\nP: Processor，处理器；对 G 来说，P 相当于 CPU 核，G 只有绑定到 P 才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 \u0026gt;= P 的数量）。\nP 的数量由用户设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256。\nSched: Go 调度器，它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复。\n具体讲解地址\ngo实现基本的排序和查找算法 详细内容\n（1）基本排序算法 基于Big-O(n^2)的排序\n选择排序：选数组中最小的元素和第一个元素交换；再选剩下元素中最小的和第二个元素交换，\u0026hellip; 空间O(1)，不稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func selectSort(arr []int) { for i := 0; i \u0026lt; len(arr); i ++ { minIndex := i for j := i + 1; j \u0026lt; len(arr); j ++ { if arr[minIndex] \u0026gt; arr[j] { minIndex = j; } } swap(arr, i, minIndex) } } func swap(arr []int, i, j int) { temp := arr[i] arr[i] = arr[j] arr[j] = temp } 冒泡排序: 从第一个元素开始，每次比较相邻元素，按顺序交换，否则继续往后比较下一对，\u0026hellip; 空间O(1)，稳定 1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { for e := len(arr) - 1; e \u0026gt; 0; e -- { for i := 0; i \u0026lt; e; i ++ { // 升序 if arr[i] \u0026gt; arr[i + 1] { swap(arr, i, i + 1) } } } } 插入排序：冒泡的每一次冒，都要把无序序列轮一遍；插入排序恰恰相反，一旦你遇到比自己大或小的了，你就知道，后面都是比自己大或小的，现在坐下，当前元素就进入了有序序列。插入的每一次插，都不一定要轮一遍有序序列。 1 2 3 4 5 6 7 8 9 10 11 func insertSort(arr []int) { // 未排序区间 for i := 1; i \u0026lt; len(arr); i ++ { // 已排序区间 for j := i - 1; j \u0026gt;= 0; j -- { if arr[j] \u0026gt; arr[j + 1] { swap(arr, j, j + 1) } } } } 基于Big-O(nlogn)的排序\n快排：分治思想，空间O(logn), 不稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func quickSort(arr []int, L int, R int) { if(L \u0026lt; R){ lF, rF := float32(L), float32(R) rand.Seed(time.Now().UnixNano()) randomIndex := int(lF + rand.Float32() * (rF - lF + 1))//数组中随机获取下标 swap(arr, randomIndex, R) var p []int = partition(arr, L, R) //partition操作返回p[0]和p[1] quickSort(arr, L, p[0] - 1) //p[0]-1为随机下标对应的值的左边 quickSort(arr, p[1] + 1, R) //p[1]+1为随机下标对应的值的右边 } } func partition(arr []int, L int, R int) []int { less, more := L - 1, R //less区域为小于随机下标对应的值，more区域为大于随机下标对应的值 for L \u0026lt; more { if arr[L] \u0026lt; arr[R] { less++ swap(arr, less, L) L++ } else if arr[L] \u0026gt; arr[R]{ more-- swap(arr, more, L) } else { L++ } } swap(arr, more, R) return []int {less + 1, more} } 归并排：空间复杂度O(n)，稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func mergeSort(arr []int, L int, Mid int, R int) { if len(arr) \u0026lt; 2 { return } help := make([]int, 0, R - L + 1) p1, p2 := L, Mid + 1 for p1 \u0026lt;= Mid \u0026amp;\u0026amp; p2 \u0026lt;= R { if arr[p1] \u0026lt;= arr[p2] { help = append(help, arr[p1]) p1++ } else { help = append(help, arr[p2]) p2++ } } for p1 \u0026lt;= Mid { help = append(help, arr[p1]) p1++ } for p2 \u0026lt;= R { help = append(help, arr[p2]) p2++ } for i := 0; i \u0026lt; len(help); i++ { arr[L + i] = help[i] } } 堆排（优先队列）： heapInsert(arr []int, index int) 建立大根堆，(index * 2) + 1为该节点左孩子，(index * 2) + 2 为该节点右孩子，(index - 1) / 2 为该节点的父节点。若该节点大于父节点，就交换，并且index = (index - 1) / 2。\nheapify(arr []int, index int, heapSize int), 找到最后一个节点lastNode，该节点与当前根节点交换，同时heap\u0026ndash;，即最后位置上为最大值，根节点为极小值。此时从根结点出发，继续heapify的过程(左孩子右孩子较大者与根节点交换, lastNode节点 来到孩子节点较大者位置，继续左右孩子较大者比较，直至没有左右孩子)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func heapInsert(arr []int, index int){ for arr[index] \u0026gt; arr[(index - 1) / 2] { swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 } } //index * 2 + 1 左孩子节点 //index * 2 + 2 右孩子节点 //(index - 1) / 2 父节点 func heapify(arr []int, index int, heapSize int){ var largestIndex int leftNode := index * 2 + 1 for leftNode \u0026lt; heapSize { if leftNode + 1 \u0026lt; heapSize \u0026amp;\u0026amp; arr[leftNode + 1] \u0026gt; arr[leftNode] { largestIndex = leftNode + 1 } else { largestIndex = leftNode } if arr[largestIndex] \u0026lt; arr[index] { largestIndex = index } if largestIndex == index { break } swap(arr, largestIndex, index) index = largestIndex leftNode = index * 2 + 1 } } （2）基本查找算法 博文link\n七大查找算法： 顺序查找、二分查找、差值查找、斐波那契查找、 树表查找 (二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树)、分块查找、哈希查找、图查找 (广度优先查找、深度优先查找)\n分类： 静态查找 vs 动态查找\n有序查找 vs 无序查找\nmysql索引分为几种？ 按数据结构：B+tree索引、Hash索引、Full-text索引。\n按物理存储：聚簇索引、二级索引（辅助索引或者非主键索引）。\nMySQL索引按叶子节点存储的是否为完整表数据分为：聚簇索引、二级索引（辅助索引）。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。\n按字段特性：主键索引、普通索引、前缀索引。\n按字段个数：单列索引、联合索引（复合索引、组合索引）。\nRedis vs MySQL 区别： 数据类型 mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。\nredis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。\n本质区别 Redis：基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，而内存成本较高；\nMySQL：基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高；\nredis优缺点 优点 速度快：Redis 数据存储在内存中，读写速度非常快，适用于需要高速数据处理的场景。\n数据结构丰富：Redis 支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，可以满足不同类型的数据存储需求。\n支持分布式：Redis 可以通过主从复制和哨兵机制实现分布式部署，提高系统的可靠性和可用性。\n轻量级：Redis 相对其他数据库来说比较轻量级，占用资源少，启动速度快。\n可扩展性：Redis 可以通过插件或扩展机制实现更多的功能，如 Redis Modules。\n支持事务：Redis 提供了简单的事务机制，保证了数据的一致性。\n缺点 内存限制：由于数据存储在内存中，Redis 的内存容量有限，无法处理大量的数据\n数据持久性：Redis 默认情况下是将数据存储在内存中的，如果没有正确配置持久化机制，数据在服务器重启或故障时可能会丢失。\n复杂性：虽然 Redis 相对简单，但在分布式环境下的管理和配置可能会变得复杂。\n不支持复杂查询：Redis 主要用于简单的数据操作，对于复杂的查询和分析功能较弱。\n使用场景 缓存：Redis 最常见的用途之一是作为缓存服务器，将频繁访问的数据存储在内存中，以加速数据访问速度。由于 Redis 具有快速的读写速度和丰富的数据结构，适用于各种缓存场景，如网页缓存、会话缓存、对象缓存等。\n会话存储：Redis 可以用作会话存储，将用户会话数据存储在内存中，以提供快速的会话访问和管理。这对于需要跨多个服务器共享会话数据的 Web 应用程序非常有用。\n消息队列：Redis 支持发布/订阅模式（Pub/Sub），可以用作轻量级的消息队列系统，实现消息的发布和订阅，用于异步任务处理、事件通知等场景。\n计数器：Redis 的原子操作能力使其成为实现计数器功能的理想选择。它可以用于统计网站访问量、用户点击量、商品销量等。\n分布式锁：Redis 的分布式锁功能可以用于实现分布式系统中的互斥操作，确保共享资源的安全访问。这对于控制并发访问、避免资源竞争非常有用。\n实时数据分析：Redis 支持持久化和数据备份，可以用于实时数据分析和监控系统，存储实时数据，并支持数据的快速查询和分析。\n任务队列：Redis 可以用作任务队列，用于存储和管理需要异步处理的任务，如后台任务、定时任务等。\n地理位置服务：Redis 的地理位置数据类型（Geo）可以用于存储地理位置信息，并支持基于位置的搜索和查询，用于实现位置服务和地理信息系统。\nmysql优缺点 优点 开源和免费：MySQL 是开源软件，可以免费使用，降低了企业的成本负担。\n跨平台性：MySQL 可以在多种操作系统上运行，包括 Windows、Linux、Mac 等，具有良好的跨平台性。\n易于使用：MySQL 的安装和配置相对简单，具有良好的用户文档和社区支持，使得用户可以快速上手并进行数据库管理和查询。\n高性能：MySQL 具有较高的性能，能够处理大量的并发请求，提供高效的数据存取和查询能力。\n可扩展性：MySQL 支持主从复制、分区表、分布式数据库等功能，可以方便地进行系统扩展和负载均衡。\n缺点 性能瓶颈：在处理大规模数据和高并发请求时，MySQL 可能会遇到性能瓶颈，需要进行优化和调整以满足需求。\n单点故障：MySQL 在单机部署时存在单点故障的风险，需要采取合适的容错和备份策略来保证系统的可靠性和稳定性。\n复杂的管理：虽然 MySQL 相对易于使用，但在大规模部署和管理时，需要花费一定的时间和精力来进行数据库的管理和维护。\n存储引擎限制：MySQL 的存储引擎数量有限，不同的存储引擎具有不同的特性和性能，选择合适的存储引擎需要根据具体需求进行评估。\n事务支持有限：在某些场景下，MySQL 的事务支持可能有限，不适合要求严格事务一致性的应用场景。\n使用场景 Web 应用程序：MySQL 是许多 Web 应用程序的首选数据库，包括电子商务网站、博客、社交网络、论坛等。它能够处理大量的并发请求，并提供良好的性能和可靠性。\n日志和监控系统：MySQL 可以用于存储日志和监控数据，用于分析系统的运行状态和性能指标，帮助管理员监控和管理系统的运行情况。\n企业应用程序：许多企业级应用程序使用 MySQL 作为其关键的数据存储和管理工具。这些应用程序可能涉及客户关系管理（CRM）、企业资源规划（ERP）、人力资源管理（HRM）等各种业务功能。\n数据仓库和报告系统：MySQL 可以作为数据仓库和报告系统的后端存储，用于存储和管理大量的历史数据，并支持复杂的查询和报告生成。\nes具体的使用方法好在哪里？ Elasticsearch是一个开源的分布式全文搜索引擎，它构建在Apache Lucene库之上。它专注于提供快速、弹性和可靠的全文搜索、结构化搜索、分析和可视化功能。\n详细介绍\n分布式架构： Elasticsearch被设计为在多台服务器上运行，并自动管理数据的分片和复制。这使得它能够处理大规模的数据，并提供高可用性和容错性。\n全文搜索： Elasticsearch使用倒排索引技术，可以高效地进行全文搜索。它支持各种查询类型，包括匹配、模糊搜索、范围搜索等。\n实时数据： Elasticsearch对数据的更改几乎是实时的，通常在毫秒级别内就可以被索引并可查询。这使得它非常适合需要及时反馈的应用场景，如日志分析、监控数据处理等。\n多语言支持： Elasticsearch提供了广泛的语言客户端，使得开发人员可以使用自己熟悉的语言与之交互，如Java、Python、Node.js等。\n弹性扩展： Elasticsearch支持水平扩展，可以通过添加更多的节点来增加存储容量和负载能力。它还提供了自动分片和负载均衡机制，使得数据在集群中的分布更加均匀。\n多种数据类型支持： 除了文本数据，Elasticsearch也可以处理结构化数据和地理位置数据。它支持各种数据类型的索引和查询，包括字符串、数字、日期、布尔值、数组等。\n易于使用的API： Elasticsearch提供了RESTful风格的API，可以使用HTTP协议与之进行交互。这使得开发人员可以轻松地索引、查询、修改和删除数据。\n数据聚合与分析： Elasticsearch提供了丰富的聚合功能，可以对数据进行统计、分组、筛选和排序等操作。同时，它还集成了Kibana工具，用于可视化和分析数据。\nHTTP状态码 1XX - 提示信息 2XX - success 3XX - 重定向 4XX - 客户端错误，请求有语法错误or请求无法实现 400 - bad request 错误请求 服务器不理解请求的语法 401 - unauthorized 未授权 请求要求身份验证 402 - 为了将来可能的需求而预留的 403 - forbidden 禁止 服务器拒绝请求 404 - not found 未找到 服务器找不到请求的网页 5XX - 服务端错误，服务器未能实现合法的请求 ","permalink":"https://erica423.github.io/posts/tech/","summary":"go语言slice和map底层实现原理 slice和map都是引用类型，长度不固定。 slice底层： slice指向一个底层array，声明时不","title":"Go相关"},{"content":" 2024暑期找实习学习进度\n计划：golang后端开发 实习的准备程度:\n数据结构与算法: 代码随想录4 刷, 部分labuladong笔记 剑指offer1 leetcode 350\n计算机网络: 小林coding图解网络 计算机网络自顶向下\n操作系统: 小林coding图解系统 操作系统导论\nMysql: MySQL必知必会 从根上理解MySQL 小林MySQL图解\nRedis: Redis设计与实现 小林coding Redis部分\n编程语言:\nGo: Go语言圣经 GoWeb编程 Go语言设计与实现 Go专家编程\nC++: \u0026lt;C++ Primer\u0026gt; \u0026lt;Efficient C++\u0026gt; \u0026lt;TCP/IP网络编程\u0026gt;\n项目写一个Redis单机服务器, 另外还有一个就是https://betxin.one了\nGo 1. 语言基础 《Go语言学习笔记》（语法部分） 单测练手：learn-go-with-tests （全部部分） Go底层 b站视频 2. 进阶 《Go Web编程》link （5.9 finish） Gin (5.10) Gorm 文档 微服务框架：go-zero (√) / kratos 3. 项目 pacgo 吃豆子项目 7daysGolang link Gee link go-gin-example link 搭建自己的blog：静态Hugo，维护中\u0026hellip; 在学项目：基于go-zero的IM实时聊天项目 Go面经 Go大厂面试真题(130页-带答案).pdf Go后端开发大厂面试题(八股文-188页-带答案).pdf Golang修养之路.pdf Golang开发岗面试笔记(26页-带答案).pdf Go程序员面试笔试宝典.txt 链接 Golang常见面试题解析(129页-带答案).pdf 算法 代码随想录: 链接\n数组 链表 哈希表 字符串 双指针法 栈和队列 二叉树 回溯算法 贪心算法 动态规划 单调栈 图论 。。。 ","permalink":"https://erica423.github.io/posts/todo/","summary":"2024暑期找实习学习进度 计划：golang后端开发 实习的准备程度: 数据结构与算法: 代码随想录4 刷, 部分labuladong笔记 剑指offe","title":"ToDo List"}]