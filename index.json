[{"content":" åŸºäºHugoæ­å»ºçš„ä¸ªäººé™æ€åšå®¢ï¼Œä½¿ç”¨ä¸»é¢˜themeä¸ºHugo_PaperMod éƒ¨ç½²å‰æï¼š\nå®‰è£…Git å®‰è£…Hugo 1 æ­å»ºhugoåšå®¢ PaperModä¸»é¢˜åˆ›å»ºåŠé…ç½®ï¼šline hugo server -D å¯åŠ¨æœåŠ¡ï¼Œæµè§ˆå™¨è®¿é—® http://localhost:1313 2 Githubéƒ¨ç½² é‡å¤´æˆæ¥å•¦ï¼GitHub Actions æ˜¯ä¸€ä¸ªæŒç»­é›†æˆå’ŒæŒç»­äº¤ä»˜(CI/CD) å¹³å°ï¼Œå¯ç”¨äºè‡ªåŠ¨æ‰§è¡Œæ„å»ºã€æµ‹è¯•å’Œéƒ¨ç½²ç®¡é“ï¼Œç›®å‰å·²ç»æœ‰å¾ˆå¤šå¼€å‘å¥½çš„å·¥ä½œæµï¼Œå¯ä»¥é€šè¿‡ç®€å•çš„é…ç½®å³å¯ç›´æ¥ä½¿ç”¨ã€‚è¿™é‡Œç»™å‡ºçš„æ˜¯Github Actionsè‡ªåŠ¨éƒ¨ç½²çš„è¿‡ç¨‹ï¼Œå¸¸è§„éƒ¨ç½²æ“ä½œæ¯”è¾ƒéº»çƒ¦ï¼ˆç¬¬ä¸€æ¬¡éƒ¨ç½²ç‹ ç‹ è¸©å‘äº†åªèƒ½å…¨éƒ¨åˆ é™¤é‡æ¥\u0026hellip;ï¼‰\næ–°å»ºgithubä»“åº“ï¼Œå‘½åä¸º {è‡ªå·±çš„githubç”¨æˆ·å}.github.ioï¼Œè®¾ç½®ä¸ºå…¬å¼€ã€‚è¿™ä¸ªä»“åº“ç”¨æ¥å­˜publicæ–‡ä»¶å¤¹ä¸­çš„é™æ€htmlæ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯å±•ç¤ºåšå®¢çš„å†…å®¹ æ‰“å¼€å½“å‰ä»“åº“çš„Setting -\u0026gt; Pages -\u0026gt; Branch é€‰æ‹©mainåˆ†æ”¯ï¼Œsaveä¿å­˜ å†æ–°å»ºä¸€ä¸ªç§æœ‰ä»“åº“ï¼Œå¯ä»¥å‘½åä¸ºxxx-blogï¼ˆéšæ„å°±å¯ï¼‰ï¼Œç”¨äºå­˜æ”¾hugoæºæ–‡ä»¶ æ‰“å¼€githubä¸»é¡µï¼ˆæ³¨æ„ä¸æ˜¯ä»“åº“çš„ï¼‰çš„Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokensï¼Œåˆ›å»ºä¸€ä¸ªtoken(classic)ã€‚è‡ªä¸»é€‰æ‹©tokençš„è¿‡æœŸæ—¶é—´ï¼Œå¹¶å‹¾é€‰repoå’Œworkflowé€‰é¡¹ã€‚æ³¨æ„ä¿å­˜å¥½ç”Ÿæˆçš„tokenï¼Œä¹‹åå°±æŸ¥çœ‹ä¸äº†äº†ã€‚ è½¬åˆ°æºæ–‡ä»¶ä»“åº“ï¼å°†åˆšæ‰ç”Ÿæˆçš„tokenå­˜å…¥ä»“åº“çš„å˜é‡ä¸­ã€‚æ‰“å¼€Settings -\u0026gt; Secrets and variables -\u0026gt; Actions newä¸€ä¸ªsecretã€‚ åœ¨æºæ–‡ä»¶ä¸­åˆ›å»º.github/workflows/deploy.yamlé…ç½®æ–‡ä»¶ï¼Œå¤åˆ¶ä»¥ä¸‹é…ç½®ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: deploy on: push: branches: - main workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.è‡ªå·±çš„tokenå˜é‡å }} EXTERNAL_REPOSITORY: è‡ªå·±çš„githubå/è‡ªå·±çš„githubå.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_meassage: auto deploy # commit_message: ${{ github.event.head_commit.message }} æ–°å»º.gitignore 1 2 3 4 # è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ public resources .hugo_build.lock æœ€åå°±å¯ä»¥æ¨é€æºæ–‡ä»¶åˆ°ä»“åº“å•¦ï¼ŒæˆåŠŸpushåå°±ä¼šè‡ªåŠ¨è§¦å‘Github Actionsè‡ªåŠ¨éƒ¨ç½²ã€‚(æ–°è®¾å¤‡è®°å¾—æ·»åŠ sshç§˜é’¥) 1 2 3 4 5 6 7 8 # git config --global user.name \u0026#39;xxx\u0026#39; # git config --global user.email \u0026#39;xxx\u0026#39; git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {ä»“åº“åœ°å€} git push -u origin main è®¿é—®xxx.github.ioçœ‹åˆ°åšå®¢é¡µé¢å°±æ˜¯éƒ¨ç½²æˆåŠŸå•¦ï¼ğŸ¥³ğŸ¥³ğŸ¥³ 3 å…¶ä»–æ’ä»¶ äºŒç¼–ï¼šæ·»åŠ é˜…è¯»é‡ã€ç”¨æˆ·è®¿é—®é‡åŠŸèƒ½ï¼ˆbusuanziè®¡æ•°å™¨ï¼‰\nå‚è€ƒåœ°å€ï¼š\u0026ldquo;https://zhuanlan.zhihu.com/p/649952987\u0026quot;\n","permalink":"https://erica423.github.io/posts/first/","summary":"åŸºäºHugoæ­å»ºçš„ä¸ªäººé™æ€åšå®¢ï¼Œä½¿ç”¨ä¸»é¢˜themeä¸ºHugo_PaperMod éƒ¨ç½²å‰æï¼š å®‰è£…Git å®‰è£…Hugo 1 æ­å»ºhugoåšå®¢ PaperM","title":"ã€å®Œã€‘ä½¿ç”¨Github Actionså®ç°Hugoé™æ€åšå®¢è‡ªåŠ¨éƒ¨ç½²"},{"content":"1 æ•°ç»„ 1.1 æ•°ç»„å­˜å‚¨ ä¸è®ºä¸€ç»´æ•°ç»„è¿˜æ˜¯äºŒç»´æ•°ç»„ï¼Œå…¶å­˜å‚¨åœ°å€ç©ºé—´éƒ½æ˜¯çº¿æ€§è¿ç»­çš„ã€‚ goä¸­ int ç±»å‹é•¿åº¦å’Œæ“ä½œç³»ç»Ÿçš„ä½æ•°æœ‰å…³ï¼š64ä½çš„é»˜è®¤ int ä½æ•°ä¸º 8ï¼Œ32ä½çš„é»˜è®¤ int ä½æ•°ä¸º 4ã€‚ intç±»å‹ æ•°æ®èŒƒå›´ int8 -128 ~ 127 int16 -32768 ~ 32767 int32 -2147483648 ~ 2147483647 (2 * 10^9) int64 -9223372036854775808 ~ 9223372036854775807 (9 * 10^18) uint8 0 ~ 255 uint16 0 ~ 65535 uint32 0 ~ 4294967295 uint64 0 ~ 18446744073709551615 1.2 äºŒåˆ†æŸ¥æ‰¾ å‰æï¼šæœ‰åºæ•°ç»„ï¼Œæ— é‡å¤å…ƒç´ \né‡ç‚¹ï¼šåŒºé—´çš„å®šä¹‰ï¼ˆåŒºé—´å°±æ˜¯ä¸å˜é‡ï¼)\nå†™æ³•1 [left, right]\nwhile (left \u0026lt;= right) è¦ä½¿ç”¨ \u0026lt;= ï¼Œå› ä¸ºleft == rightæ˜¯æœ‰æ„ä¹‰çš„\nif (target \u0026lt; nums[middle]) right = middle - 1ï¼Œå› ä¸ºå½“å‰è¿™ä¸ªnums[middle] ä¸€å®šä¸æ˜¯targetï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥è¦æŸ¥æ‰¾çš„å·¦åŒºé—´ç»“æŸä¸‹æ ‡ä½ç½®å°±æ˜¯ middle - 1. left = mid + 1.\nå†™æ³•2 [left, right)\nwhile (left \u0026lt; right)\nright = mid, left = mid + 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // [l, r]ç‰ˆæœ¬ func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid - 1 } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } // [l, r) func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt; r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } GoäºŒåˆ†æŸ¥æ‰¾åº“å‡½æ•°ï¼šindex := sort.Search(n int, f func(i int) bool) int)\nè¯¥å‡½æ•°ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œä¼šä»[0, n)ä¸­å–å‡ºä¸€ä¸ªå€¼indexï¼Œindexä¸º[0, n)ä¸­æœ€å°çš„ä½¿å‡½æ•°f(index)ä¸ºTrueçš„å€¼ï¼Œå¹¶ä¸”f(index+1)ä¹Ÿä¸ºTrueã€‚ å¦‚æœæ— æ³•æ‰¾åˆ°è¯¥indexå€¼ï¼Œåˆ™è¯¥æ–¹æ³•ä¸ºè¿”å›n. âš ï¸å¸¸ç”¨åœºæ™¯: ä¸€èˆ¬ç”¨äºä»ä¸€ä¸ªå·²ç»æ’åºçš„æ•°ç»„ä¸­æ‰¾åˆ°æŸä¸ªå€¼æ‰€å¯¹åº”çš„ç´¢å¼•ã€‚ æˆ–è€…ä»å­—ç¬¦ä¸²æ•°ç»„ä¸­ï¼Œæ‰¾åˆ°æ»¡è¶³æŸä¸ªæ¡ä»¶çš„æœ€å°ç´¢å¼•å€¼ï¼Œæ¯”å¦‚etcdä¸­çš„é”®å€¼èŒƒå›´æŸ¥è¯¢å°±ç”¨åˆ°äº†è¯¥æ–¹æ³•ã€‚ 1.3 åŸåœ°ç§»é™¤å…ƒç´  è¦æ±‚ï¼šåˆ é™¤æ•°ç»„ä¸­å€¼ç­‰äºvalçš„å…ƒç´ ï¼Œä¸å¯ä»¥ä½¿ç”¨é¢å¤–çš„ç©ºé—´ã€‚\né‡ç‚¹ï¼šæ•°ç»„çš„å…ƒç´ åœ¨å†…å­˜åœ°å€ä¸­æ˜¯è¿ç»­çš„ï¼Œä¸èƒ½å•ç‹¬åˆ é™¤æ•°ç»„ä¸­çš„æŸä¸ªå…ƒç´ ï¼Œåªèƒ½è¦†ç›–ã€‚ æš´åŠ›åšæ³•ï¼šä¸¤å±‚forå¾ªç¯ï¼Œç¬¬ä¸€ä¸ªforæŸ¥æ‰¾å€¼ç­‰äºvalçš„å…ƒç´ ï¼Œç¬¬äºŒå±‚forä¾æ¬¡å°†åç»­å…ƒç´ æå‰ä¸€ä½è¦†ç›–æ‰å‰ä¸€ä½å…ƒç´ ã€‚ å¤æ‚åº¦ï¼šO(n^2) O(1)\nå¿«æ…¢æŒ‡é’ˆåšæ³• å®ç°ä¸€ä¸ªå¿«æŒ‡é’ˆä¸€ä¸ªæ…¢æŒ‡é’ˆï¼Œç”¨ä¸€ä¸ªforå¾ªç¯è§£å†³ã€‚å¤æ‚åº¦ï¼šO(n) O(1) å®šä¹‰ï¼š å¿«æŒ‡é’ˆï¼šå¯»æ‰¾ç»„æˆæ–°æ•°ç»„çš„å…ƒç´ ï¼ˆä¸å«=valçš„å…ƒç´ ï¼‰ï¼› æ…¢æŒ‡é’ˆï¼šæŒ‡å‘æ›´æ–° æ–°æ•°ç»„ä¸‹æ ‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func removeElement(nums []int, target int) int { slow := 0 for fast := 0; fast \u0026lt; len(nums); fast ++ { if nums[fast] != val { nums[slow] = nums[fast] slow ++ } } nums = nums[:slow] return nums } // åŒå‘åŒæŒ‡é’ˆ func removeElement(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { for l \u0026lt;= r \u0026amp;\u0026amp; nums[l] != val { l ++ } for l \u0026lt;= r \u0026amp;\u0026amp; nums[r] != val { r -- } // æ‰¾åˆ°å·¦ä¾§çš„valå’Œå³ä¾§çš„évalåå¼€å§‹è¦†ç›–ï¼Œè¦†ç›–åç»§ç»­å¯»æ‰¾ if l \u0026lt; r { nums[l] = nums[r] l ++ r -- } } return l } 1.4 æœ‰åºæ•°ç»„çš„å¹³æ–¹ ç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [-4,-1,0,3,10] è¾“å‡ºï¼š[0,1,9,16,100] è§£é‡Šï¼šå¹³æ–¹åï¼Œæ•°ç»„å˜ä¸º [16,1,0,9,100]ï¼Œæ’åºåï¼Œæ•°ç»„å˜ä¸º [0,1,9,16,100] ç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼šnums = [-7,-3,2,3,11] è¾“å‡ºï¼š[4,9,9,49,121] æš´åŠ›ï¼šæ¯ä¸ªæ•°å¹³æ–¹åæ’åºï¼Œæ—¶é—´å¤æ‚åº¦O(n + nlogn)\nåŒæŒ‡é’ˆ i æŒ‡å‘èµ·å§‹ä½ç½®ï¼Œj æŒ‡å‘ç»ˆæ­¢ä½ç½®ã€‚\nå®šä¹‰ä¸€ä¸ªæ–°æ•°ç»„resultï¼Œå’ŒAæ•°ç»„ä¸€æ ·çš„å¤§å°ï¼Œè®©kæŒ‡å‘resultæ•°ç»„ç»ˆæ­¢ä½ç½®ã€‚\nå¦‚æœA[i] * A[i] \u0026lt; A[j] * A[j] é‚£ä¹ˆresult[k--] = A[j] * A[j]; ã€‚\nå¦‚æœA[i] * A[i] \u0026gt;= A[j] * A[j] é‚£ä¹ˆresult[k--] = A[i] * A[i]; ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func sortedSquares(nums []int) []int { n := len(nums) i, j, k := 0, n - 1, n - 1 res := make([]int, n) for i \u0026lt;= j { lm, rm := nums[i] * nums[i], nums[j] * nums[j] if lm \u0026gt; rm { res[k] = lm i ++ } else { res[k] = rm j -- } k -- } } 1.5 é•¿åº¦æœ€å°çš„è¿ç»­å­æ•°ç»„ ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° s ï¼Œæ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ â‰¥ s çš„é•¿åº¦æœ€å°çš„ è¿ç»­ å­æ•°ç»„ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0ã€‚\nç¤ºä¾‹ï¼š\nè¾“å…¥ï¼šs = 7, nums = [2,3,1,2,4,3] è¾“å‡ºï¼š2 è§£é‡Šï¼šå­æ•°ç»„ [4,3] æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚ æç¤ºï¼š\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 æš´åŠ›ï¼šä¸¤ä¸ªforå¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)\næ»‘åŠ¨çª—å£ åªç”¨ä¸€ä¸ªforå¾ªç¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå¾ªç¯çš„ç´¢å¼•ï¼Œä¸€å®šæ˜¯è¡¨ç¤º æ»‘åŠ¨çª—å£çš„ç»ˆæ­¢ä½ç½®ã€‚ O(n)\nåœ¨æœ¬é¢˜ä¸­å®ç°æ»‘åŠ¨çª—å£ï¼Œä¸»è¦ç¡®å®šå¦‚ä¸‹ä¸‰ç‚¹ï¼š\nçª—å£å†…æ˜¯ä»€ä¹ˆï¼Ÿ çª—å£å°±æ˜¯ æ»¡è¶³å…¶å’Œ â‰¥ s çš„é•¿åº¦æœ€å°çš„ è¿ç»­ å­æ•°ç»„ã€‚\nå¦‚ä½•ç§»åŠ¨çª—å£çš„èµ·å§‹ä½ç½®ï¼Ÿ å¦‚æœå½“å‰çª—å£çš„å€¼å¤§äºç­‰äºsäº†ï¼Œçª—å£å°±è¦å‘å‰ç§»åŠ¨äº†ï¼ˆä¹Ÿå°±æ˜¯è¯¥ç¼©å°äº†ï¼‰ã€‚\nå¦‚ä½•ç§»åŠ¨çª—å£çš„ç»“æŸä½ç½®ï¼Ÿ çª—å£çš„ç»“æŸä½ç½®å°±æ˜¯éå†æ•°ç»„çš„æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯forå¾ªç¯é‡Œçš„ç´¢å¼•ã€‚\n1 2 3 4 5 while (sum \u0026gt;= s) { subLen = (j - i + 1); res = min(res, subLen); sum -= nums[i ++ ];\t// æ»‘åŠ¨çª—å£çš„ç²¾é«“ï¼Œä¸æ–­å˜æ›´èµ·å§‹ä½ç½® } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func minSubArrayLen(target int, nums []int) int { n := len(nums) res := n + 1 i, sum := 0, 0 for j := 0; j \u0026lt; n; j ++ { sum += nums[j] for sum \u0026gt;= target { subLen := j - i + 1 res = min(res, subLen) sum -= nums[i] i ++ } } if res == n + 1 { return 0 } else { return res } } 1.6 (é«˜é¢‘)èºæ—‹çŸ©é˜µII ç»™å®šä¸€ä¸ªæ­£æ•´æ•° nï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ° n^2 æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„æ­£æ–¹å½¢çŸ©é˜µã€‚\nç¤ºä¾‹:\nè¾“å…¥: 3 è¾“å‡º: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\næ±‚è§£æœ¬é¢˜ä¾ç„¶æ˜¯è¦åšæŒå¾ªç¯ä¸å˜é‡åŸåˆ™ã€‚\næ¨¡æ‹Ÿé¡ºæ—¶é’ˆç”»çŸ©é˜µçš„è¿‡ç¨‹:\nå¡«å……ä¸Šè¡Œä»å·¦åˆ°å³ å¡«å……å³åˆ—ä»ä¸Šåˆ°ä¸‹ å¡«å……ä¸‹è¡Œä»å³åˆ°å·¦ å¡«å……å·¦åˆ—ä»ä¸‹åˆ°ä¸Š ç”±å¤–å‘å†…ä¸€åœˆä¸€åœˆè¿™ä¹ˆç”»ä¸‹å»ã€‚è¿™é‡Œä¸€åœˆä¸‹æ¥ï¼Œæˆ‘ä»¬è¦ç”»æ¯å››æ¡è¾¹ï¼Œè¿™å››æ¡è¾¹æ€ä¹ˆç”»ï¼Œæ¯ç”»ä¸€æ¡è¾¹éƒ½è¦åšæŒä¸€è‡´çš„å·¦é—­å³å¼€ï¼Œæˆ–è€…å·¦å¼€å³é—­çš„åŸåˆ™ï¼Œè¿™æ ·è¿™ä¸€åœˆæ‰èƒ½æŒ‰ç…§ç»Ÿä¸€çš„è§„åˆ™ç”»ä¸‹æ¥ã€‚\nå¯ä»¥çœ‹å‡ºæ‹è§’å¤„æ˜¯è®©ç»™ä¸‹ä¸€æ¡è¾¹ç”»çš„ï¼Œä¹Ÿå°±æ˜¯å·¦é—­å³å¼€\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); int startx = 0, starty = 0; // å®šä¹‰æ¯å¾ªç¯ä¸€ä¸ªåœˆçš„èµ·å§‹ä½ç½® int loop = n / 2; // æ¯ä¸ªåœˆå¾ªç¯å‡ æ¬¡ int mid = n / 2; // çŸ©é˜µçš„ä¸­å¿ƒä½ç½® int cnt = 1;// ç”¨æ¥ç»™çŸ©é˜µä¸­æ¯ä¸€ä¸ªç©ºæ ¼èµ‹å€¼ int offset = 1;// éœ€è¦æ§åˆ¶æ¯ä¸€æ¡è¾¹éå†çš„é•¿åº¦ï¼Œæ¯æ¬¡å¾ªç¯å³è¾¹ç•Œæ”¶ç¼©ä¸€ä½ int i, j; while (loop -- ) { i = startx; j = starty; // ä¸Šè¡Œ for (j; j \u0026lt; n - offset; j ++ ) { res[i][j] = cnt ++ ; } // å³åˆ— for (i; i \u0026lt; n - offset; i ++ ) { res[i][j] = cnt ++ ; } // ä¸‹è¡Œ for (; j \u0026gt; starty; j -- ) { res[i][j] = cnt ++ ; } // å·¦åˆ— for (; i \u0026gt; startx; i -- ) { res[i][j] = cnt ++ ; } // ç¬¬äºŒåœˆå¼€å§‹çš„æ—¶å€™ï¼Œèµ·å§‹ä½ç½®è¦å„è‡ªåŠ 1 startx ++ , startty ++ ; // offset æ§åˆ¶æ¯ä¸€åœˆé‡Œæ¯ä¸€æ¡è¾¹éå†çš„é•¿åº¦ offset += 1; } if (n % 2) { res[mid][mid] = cnt; } return res; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { startx, starty := 0, 0 var loop int = n / 2 var center int = n / 2 count := 1 offset := 1 res := make([][]int, n) for i := 0; i \u0026lt; n; i++ { res[i] = make([]int, n) } for loop \u0026gt; 0 { i, j := startx, starty //è¡Œæ•°ä¸å˜ åˆ—æ•°åœ¨å˜ for j = starty; j \u0026lt; n-offset; j++ { res[startx][j] = count count++ } //åˆ—æ•°ä¸å˜æ˜¯j è¡Œæ•°å˜ for i = startx; i \u0026lt; n-offset; i++ { res[i][j] = count count++ } //è¡Œæ•°ä¸å˜ i åˆ—æ•°å˜ j-- for ; j \u0026gt; starty; j-- { res[i][j] = count count++ } //åˆ—ä¸å˜ è¡Œå˜ for ; i \u0026gt; startx; i-- { res[i][j] = count count++ } startx++ starty++ offset++ loop-- } if n % 2 == 1 { res[center][center] = n * n } return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u0026lt; n; i++ { matrix[i] = make([]int, n) } for num \u0026lt;= tar { for i := left; i \u0026lt;= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u0026lt;= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u0026gt;= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u0026gt;= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } æ—¶é—´å¤æ‚åº¦ O(n^2): æ¨¡æ‹Ÿéå†äºŒç»´çŸ©é˜µçš„æ—¶é—´ ç©ºé—´å¤æ‚åº¦ O(1) 2 é“¾è¡¨ https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\nå•é“¾è¡¨ï¼š\nåŒé“¾è¡¨ï¼š\nå¾ªç¯é“¾è¡¨ï¼šè§£å†³çº¦ç‘Ÿå¤«ç¯é—®é¢˜\nå­˜å‚¨æ–¹å¼ é“¾è¡¨æ˜¯é€šè¿‡æŒ‡é’ˆåŸŸçš„æŒ‡é’ˆé“¾æ¥åœ¨å†…å­˜ä¸­å„ä¸ªèŠ‚ç‚¹ã€‚\næ‰€ä»¥é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åœ¨å†…å­˜ä¸­ä¸æ˜¯è¿ç»­åˆ†å¸ƒçš„ ï¼Œè€Œæ˜¯æ•£ä¹±åˆ†å¸ƒåœ¨å†…å­˜ä¸­çš„æŸåœ°å€ä¸Šï¼Œåˆ†é…æœºåˆ¶å–å†³äºæ“ä½œç³»ç»Ÿçš„å†…å­˜ç®¡ç†ã€‚\né“¾è¡¨çš„å®šä¹‰ C/C++ å®šä¹‰é“¾è¡¨èŠ‚ç‚¹\n1 2 3 4 5 6 7 8 9 // å•é“¾è¡¨ struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} // èŠ‚ç‚¹çš„æ„é€ å‡½æ•° } // åˆå§‹åŒ– ListNode* head = new ListNode(5) go å®šä¹‰é“¾è¡¨èŠ‚ç‚¹\n1 2 3 4 5 6 type ListNode struct { Val int Next *ListNode } head := new(ListNode) 2.1 åˆ é™¤é“¾è¡¨å…ƒç´  é¢˜æ„ï¼šåˆ é™¤é“¾è¡¨ä¸­ç­‰äºç»™å®šå€¼ val çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚\nç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šhead = [1,2,6,3,4,5,6], val = 6 è¾“å‡ºï¼š[1,2,3,4,5]\nç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šhead = [], val = 1 è¾“å‡ºï¼š[]\nç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šhead = [7,7,7,7], val = 7 è¾“å‡ºï¼š[]\nå¦‚æœåˆ é™¤çš„æ˜¯å¤´ç»“ç‚¹è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ\nç›´æ¥ä½¿ç”¨åŸæ¥çš„é“¾è¡¨æ¥è¿›è¡Œåˆ é™¤æ“ä½œã€‚ è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´ç»“ç‚¹åœ¨è¿›è¡Œåˆ é™¤æ“ä½œã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { for head != nil \u0026amp;\u0026amp; head.Val == val { head = head.Next } } è¿™æ ·ç§»é™¤äº†ä¸€ä¸ªå¤´ç»“ç‚¹ï¼Œåœ¨å•é“¾è¡¨ä¸­ç§»é™¤å¤´ç»“ç‚¹ å’Œ ç§»é™¤å…¶ä»–èŠ‚ç‚¹çš„æ“ä½œæ–¹å¼æ˜¯ä¸ä¸€æ ·, é‚£ä¹ˆå¯ä¸å¯ä»¥ ä»¥ä¸€ç§ç»Ÿä¸€çš„é€»è¾‘æ¥ç§»é™¤ é“¾è¡¨çš„èŠ‚ç‚¹å‘¢ã€‚\nå¯ä»¥è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œè¿™æ ·åŸé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹å°±éƒ½å¯ä»¥æŒ‰ç…§ç»Ÿä¸€çš„æ–¹å¼è¿›è¡Œç§»é™¤äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026amp;ListNode{} dummyHead.Next = head cur := dummyHead // å½“å‰çš„å¤´æŒ‡é’ˆ for cur != nil \u0026amp;\u0026amp; cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyHead.Next } 2.2 (åŸºç¡€) è®¾è®¡é“¾è¡¨ åœ¨é“¾è¡¨ç±»ä¸­å®ç°è¿™äº›åŠŸèƒ½ï¼š\nget(index)ï¼šè·å–é“¾è¡¨ä¸­ç¬¬ index ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœç´¢å¼•æ— æ•ˆï¼Œåˆ™è¿”å›-1ã€‚ addAtHead(val)ï¼šåœ¨é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰æ·»åŠ ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹ã€‚æ’å…¥åï¼Œæ–°èŠ‚ç‚¹å°†æˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ addAtTail(val)ï¼šå°†å€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ addAtIndex(index,val)ï¼šåœ¨é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ä¹‹å‰æ·»åŠ å€¼ä¸º val çš„èŠ‚ç‚¹ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¯¥èŠ‚ç‚¹å°†é™„åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index å¤§äºé“¾è¡¨é•¿åº¦ï¼Œåˆ™ä¸ä¼šæ’å…¥èŠ‚ç‚¹ã€‚å¦‚æœindexå°äº0ï¼Œåˆ™åœ¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹ã€‚ deleteAtIndex(index)ï¼šå¦‚æœç´¢å¼• index æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ã€‚ è®¾è®¡äº”ä¸ªæ¥å£ï¼š\nè·å–é“¾è¡¨ç¬¬indexä¸ªèŠ‚ç‚¹çš„æ•°å€¼ï¼› åœ¨é“¾è¡¨çš„æœ€å‰è¾¹æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ åœ¨æœ€åæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ åœ¨ç¬¬indexä¸ªèŠ‚ç‚¹å‰é¢æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ åˆ é™¤ç¬¬indexä¸ªèŠ‚ç‚¹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val) : val(val), next(nullptr){} }; // åˆå§‹åŒ–é“¾è¡¨ MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while (index -- ) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size ++ ; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size ++ ; } void addAtIndex(int index, int val) { if (index \u0026gt; _size) return; if (index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size ++ ; } void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; tmp = nullptr; _size -- ; } // æ‰“å° void printLinkedList() { LInkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package main import ( \u0026#34;fmt\u0026#34; ) type SingleNode struct { Val int Next *SingleNode } type MyLinkedList struct { dummyHead *SingleNode // è™šæ‹Ÿå¤´ç»“ç‚¹ Size int // é“¾è¡¨å¤§å° } func main() { list := Constructor() list.AddAtHead(100) list.AddAtTail(242) list.AddAtTail(777) list.AddAtIndex(1, 99999) list.printLinkedList() } // Initialize func Constuctor() MyLinkedList { newNode := \u0026amp;SingleNode { -999, nil, } return MyLinkedList{ dummyHead: newNode, Size: 0, } } func (m *MyLinkedList) Get(index int) int { if m == nil || index \u0026lt; 0 || index \u0026gt;= m.Size { return -1 } cur := m.dummyHead.Next for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } return cur.Val } func (m *MyLinkedList) AddAtHead(val int) { newNode := \u0026amp;SingleNode{Val: val} newNode.Next = m.dummyHead.Next m.dummyHead.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtTail(val int) { newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for cur.Next != nil { cur = cur.Next } cur.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtIndex(index int, val int) { if index \u0026lt; 0 { index = 0 } else index \u0026gt; m.Size { return } newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } newNode.Next = cur.Next cur.Next = newNode m.Size ++ } func (m *MyLinkedList) DeleteAtIndex(index int) { if index \u0026lt; 0 || index \u0026gt;= m.Size { return } cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } if cur.Next != nil { cur.Next = cur.Next.Next } m.Size -- } func (m *MyLinkedList) printLinkedList() { cur := m.dummyHead for cur.Next != nil { fmt.Println(cur.Next.Val) cur = cur.Next } } å¾ªç¯åŒé“¾è¡¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 type Node struct { Val int Next *Node Pre *Node } type MyLinkedList struct { dummy *Node } //ä»…ä¿å­˜å“‘èŠ‚ç‚¹ï¼Œpre-\u0026gt; rear, next-\u0026gt; head /** Initialize your data structure here. */ func Constructor() MyLinkedList { rear := \u0026amp;Node{ Val: -1, Pre: nil, Next: nil, } rear.Next = rear rear.Pre = rear return MyLinkedList{rear} } func (m *MyLinkedList) Get(index int) int { head := m.dummy.Next for head != m.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { index -- head = head.Next } if 0 != index { return -1 } return head.Val } func (m *MyLinkedList) AddAtHead(val int) { dummy := m.dummy node := \u0026amp;Node{ Val: val, Pre: dummy, Next: dummy.Next, } dummy.Next.Pre = node dummy.Next = node } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { dummy := this.dummy rear := \u0026amp;Node{ Val: val, //rear.Next = dummy(å“‘èŠ‚ç‚¹) Next: dummy, //rear.Pre = ori_rear Pre: dummy.Pre, } //ori_rear.Next = rear dummy.Pre.Next = rear //update dummy dummy.Pre = rear //ä»¥ä¸Šä¸¤æ­¥ä¸èƒ½å } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { head := this.dummy.Next //head = MyLinkedList[index] for head != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } if index \u0026gt; 0 { return } node := \u0026amp;Node{ Val: val, //node.Next = MyLinkedList[index] Next: head, //node.Pre = MyLinkedList[index-1] Pre: head.Pre, } //MyLinkedList[index-1].Next = node head.Pre.Next = node //MyLinkedList[index].Pre = node head.Pre = node //ä»¥ä¸Šä¸¤æ­¥ä¸èƒ½å } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { //é“¾è¡¨ä¸ºç©º if this.dummy.Next == this.dummy { return } head := this.dummy.Next //head = MyLinkedList[index] for head.Next != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } //éªŒè¯indexæœ‰æ•ˆ if index == 0 { //MyLinkedList[index].Pre = index[index-2] head.Next.Pre = head.Pre //MyLinedList[index-2].Next = index[index] head.Pre.Next = head.Next //ä»¥ä¸Šä¸¤æ­¥é¡ºåºæ— æ‰€è°“ } } 2.3 (é«˜é¢‘) åè½¬é“¾è¡¨ æ€è·¯ï¼š\nå¦‚æœå†å®šä¹‰ä¸€ä¸ªæ–°çš„é“¾è¡¨ï¼Œå®ç°é“¾è¡¨å…ƒç´ çš„åè½¬ï¼Œå…¶å®è¿™æ˜¯å¯¹å†…å­˜ç©ºé—´çš„æµªè´¹ã€‚ å…¶å®åªéœ€è¦æ”¹å˜é“¾è¡¨çš„nextæŒ‡é’ˆçš„æŒ‡å‘ï¼Œç›´æ¥å°†é“¾è¡¨åè½¬ ï¼Œè€Œä¸ç”¨é‡æ–°å®šä¹‰ä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚\nåŒæŒ‡é’ˆæ³• O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = null; while (cur) { temp = cur-\u0026gt;next; // ä¿å­˜curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ cur-\u0026gt;next = pre; // ç¿»è½¬æ“ä½œ pre = cur; cur = temp; } } }; é€’å½’æ³• ä¸åŒçš„åœ°æ–¹åœ¨åˆå§‹åŒ– O(n) O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: ListNode* reverse(ListNode* pre, ListNode* cur) { if (cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; return reverse(cur, temp); } ListNode* reverseList(ListNode* head) { return reverse(NULL, head); } }; Goç‰ˆæœ¬ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // åŒæŒ‡é’ˆå†™æ³• func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } // é€’å½’ func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode) *ListNode { if head == nil { return pre } tmp := head,Next head.Next = pre return help(head, tmp) } 2.4 ä¸¤ä¸¤äº¤æ¢ç›¸é‚»èŠ‚ç‚¹ ç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åçš„é“¾è¡¨ã€‚\nä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…çš„è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚\nç”¨è™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œä¹‹åæ¨¡æ‹Ÿå°±å¯ä»¥äº†ã€‚O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func swapPairs(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{ Next: head, } //head=list[i] //cur=list[i-1] cur := dummy for head != nil \u0026amp;\u0026amp; head.Next != nil { cur.Next = head.Next // cur-\u0026gt;2 tmp := head.Next.Next // tmp-\u0026gt;3 head.Next.Next = head // 3-\u0026gt;1 head.Next = tmp // 1-\u0026gt;3 //cur=list[(i+2)-1] cur = head //head=list[(i+2)] head = tmp // head-\u0026gt;3 } return dummy.Next } 2.5 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚\nè¿›é˜¶ï¼šä½ èƒ½å°è¯•ä½¿ç”¨ä¸€è¶Ÿæ‰«æå®ç°å—ï¼Ÿ\næ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œå¦‚æœè¦åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼Œè®©fastç§»åŠ¨næ­¥ï¼Œç„¶åè®©fastå’ŒslowåŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ°fastæŒ‡å‘é“¾è¡¨æœ«å°¾ã€‚åˆ æ‰slowæ‰€æŒ‡å‘çš„èŠ‚ç‚¹å°±å¯ä»¥äº†ã€‚\nå®šä¹‰fastå’ŒslowæŒ‡é’ˆï¼Œåˆå§‹å€¼ä¸ºè™šæ‹Ÿå¤´ç»“ç‚¹ fastèµ°n + 1æ­¥ï¼Œå› ä¸ºåªæœ‰è¿™æ ·åŒæ—¶ç§»åŠ¨æ—¶slowæ‰å¯ä»¥æŒ‡å‘è¢«åˆ é™¤èŠ‚ç‚¹çš„ä¸Šä¸€èŠ‚ç‚¹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := \u0026amp;ListNode{0, head} fast, slow := dummy, dummy for i := 0; i \u0026lt;= n; i ++ {// æ³¨æ„\u0026lt;=ï¼Œå¦åˆ™å¿«æŒ‡é’ˆä¸ºç©ºæ—¶ï¼Œæ…¢æŒ‡é’ˆæ­£å¥½åœ¨å€’æ•°ç¬¬nä¸ªä¸Šé¢ fast = fast.Next } for fast != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return dummy.Next } // O(n) O(1) 2.6 é“¾è¡¨ç›¸äº¤ ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null ã€‚é¢˜ç›®ä¿è¯ä¸å­˜åœ¨ç¯å½¢ï¼Œä¸èƒ½æ”¹å˜åŸé“¾è¡¨ã€‚\næ€è·¯ï¼š æ±‚ä¸¤ä¸ªé“¾è¡¨äº¤ç‚¹èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ï¼ˆæ³¨æ„ï¼æ˜¯æŒ‡é’ˆç›¸ç­‰ï¼Œä¸æ˜¯æ•°å€¼ç›¸ç­‰ï¼‰\ncurAæŒ‡å‘é“¾è¡¨Açš„å¤´ç»“ç‚¹ï¼ŒcurBæŒ‡å‘é“¾è¡¨Bçš„å¤´ç»“ç‚¹ï¼› æ±‚å‡ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼Œå¹¶æ±‚å‡ºä¸¤ä¸ªé“¾è¡¨é•¿åº¦çš„å·®å€¼ï¼Œç„¶åè®©curAç§»åŠ¨åˆ°ï¼Œå’ŒcurB æœ«å°¾å¯¹é½çš„ä½ç½®ï¼› æ¯”è¾ƒcurAå’ŒcurBæ˜¯å¦ç›¸åŒï¼Œå¦‚æœä¸ç›¸åŒï¼ŒåŒæ—¶å‘åç§»åŠ¨curAå’ŒcurBï¼Œå¦‚æœé‡åˆ°curA == curBï¼Œåˆ™æ‰¾åˆ°äº¤ç‚¹ã€‚å¦åˆ™å¾ªç¯é€€å‡ºè¿”å›ç©ºæŒ‡é’ˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *curA = headA; ListNode *curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) { lenA ++ ; curA = curA -\u0026gt; next; } while (curB != NULL) { lenB ++ ; curB = curB -\u0026gt; next; } if (lenB \u0026gt; lenA) { // è®©curAä¸ºæœ€é•¿é“¾è¡¨çš„å¤´ swap(lenA, lenB); swap(curA, curB); } int gap = lenA - lenB; while (gap -- ) { // ä¸¤é“¾æœ«å°¾å¯¹é½ curA = curA -\u0026gt; next; } while (curA != NULL) { // éå†curAå’ŒcurBï¼Œé‡åˆ°ç›¸åŒåˆ™ç›´æ¥è¿”å› if (curA == curB) return curA; curA = curA -\u0026gt; next; curB = curB -\u0026gt; next; } return NULL; } }; // O(n + m) O(1) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA, curB := headA, headB; lenA, lenB := 0, 0 for curA != nil { curA = curA.Next lenA ++ } for curB != nil { curB = curB.Next lenB ++ } var gap int var fast, slow *ListNode if lenA \u0026gt; lenB { gap = lenA - lenB fast, slow = headA, headB } else { gap = lenB - lenA fast, slow = headB, headA } for i := 0; i \u0026lt; gap; i ++ { fast = fast.Next } for fast != slow { // éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œé‡åˆ°ç›¸åŒçš„å°±è·³å‡ºéå† fast = fast.Next slow = slow.Next } return fast } // åŒæŒ‡é’ˆ /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { a, b := headA, headB for a != b { if a != nil { a = a.Next } else { a = headB } if b != nil { b = b.Next } else { b = headA } } return a } 2.7 ç¯å½¢é“¾è¡¨II ç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚\nè€ƒå¯Ÿï¼š\nåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯\nå¿«æ…¢æŒ‡é’ˆã€‚fast += 2, slow ++ , å¦‚æœ fast å’Œ slowæŒ‡é’ˆåœ¨é€”ä¸­ç›¸é‡ ï¼ˆå¿…åœ¨ç¯ä¸­ç›¸é‡ï¼‰ï¼Œè¯´æ˜è¿™ä¸ªé“¾è¡¨æœ‰ç¯ã€‚ æœ‰ç¯çš„è¯å¦‚ä½•æ‰¾åˆ°å…¥å£\nä»å¤´ç»“ç‚¹å‡ºå‘ä¸€ä¸ªæŒ‡é’ˆï¼Œä»ç›¸é‡èŠ‚ç‚¹ ä¹Ÿå‡ºå‘ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™ä¸¤ä¸ªæŒ‡é’ˆæ¯æ¬¡åªèµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ é‚£ä¹ˆå½“è¿™ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡çš„æ—¶å€™å°±æ˜¯ ç¯å½¢å…¥å£çš„èŠ‚ç‚¹ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œæ­¤æ—¶ä» head å’Œ ç›¸é‡ç‚¹ï¼ŒåŒæ—¶æŸ¥æ‰¾ç›´è‡³ç›¸é‡ if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head // è¿”å›ç¯çš„å…¥å£ } } return nil } å“ˆå¸Œè¡¨ï¼ˆæ•£åˆ—è¡¨ï¼‰ ä¸€èˆ¬å“ˆå¸Œè¡¨éƒ½ç”¨å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°åœ¨é›†åˆé‡Œã€‚\nhash functionï¼šæŠŠæŸä¸ªä¿¡æ¯æ˜ å°„åˆ°å“ˆå¸Œè¡¨ä¸Šçš„ç´¢å¼•ã€‚\nhash collisionsï¼ˆå“ˆå¸Œç¢°æ’\\å†²çªï¼‰ï¼še.g. å¤šä¸ªå§“åéƒ½æ˜ å°„åˆ°äº†åŒä¸€ä¸ªç´¢å¼•ä¸‹æ ‡ã€‚\næ‹‰é“¾æ³•ï¼š çº¿æ€§æ¢æµ‹æ³•ï¼šä¸€å®šè¦ä¿è¯tableSizeå¤§äºdataSizeã€‚ éœ€è¦ä¾é å“ˆå¸Œè¡¨ä¸­çš„ç©ºä½æ¥è§£å†³ç¢°æ’é—®é¢˜ã€‚ å“ˆå¸Œç»“æ„ï¼š\næ•°ç»„ é›†åˆ set æ˜ å°„ map c++ åº•å±‚ï¼š\né›†åˆ åº•å±‚å®ç° æ˜¯å¦æœ‰åº æ•°å€¼æ˜¯å¦å¯ä»¥é‡å¤ èƒ½å¦æ›´æ”¹æ•°å€¼ æŸ¥è¯¢æ•ˆç‡ å¢åˆ æ•ˆç‡ std::set çº¢é»‘æ ‘ æœ‰åº å¦ å¦ O(log n) O(log n) std::multiset çº¢é»‘æ ‘ æœ‰åº æ˜¯ å¦ O(logn) O(logn) std::unordered_set å“ˆå¸Œè¡¨ æ— åº å¦ å¦ O(1) O(1) æ˜ å°„ åº•å±‚å®ç° æ˜¯å¦æœ‰åº æ•°å€¼æ˜¯å¦å¯ä»¥é‡å¤ èƒ½å¦æ›´æ”¹æ•°å€¼ æŸ¥è¯¢æ•ˆç‡ å¢åˆ æ•ˆç‡ std::map çº¢é»‘æ ‘ keyæœ‰åº keyä¸å¯é‡å¤ keyä¸å¯ä¿®æ”¹ O(logn) O(logn) std::multimap çº¢é»‘æ ‘ keyæœ‰åº keyå¯é‡å¤ keyä¸å¯ä¿®æ”¹ O(log n) O(log n) std::unordered_map å“ˆå¸Œè¡¨ keyæ— åº keyä¸å¯é‡å¤ keyä¸å¯ä¿®æ”¹ O(1) O(1) **goå‘¢ï¼Ÿ**goä¸­çš„hashç»“æ„é€šå¸¸æ˜¯æŒ‡mapï¼Œåº•å±‚æ˜¯ æ•°ç»„+å•é“¾è¡¨\nhttps://blog.csdn.net/vince1998/article/details/137185380\nåšé¢˜æŠ€å·§ï¼š\né¢˜ç›®æç¤ºåªæœ‰å°å†™å­—æ¯ï¼Œæš—ç¤ºç”¨æ•°ç»„åšå“ˆå¸Œã€‚å¤§å°ä¸å—é™ï¼Œä¸ç”¨æ•°ç»„ã€‚ æ•°ç»„å¤§å°æœ‰é™ æˆ– æ•°ç»„ç©ºé—´å¤§ä½†å“ˆå¸Œå€¼å°‘ï¼Œåˆ†æ•£ï¼Œå»ºè®®setã€‚ è¦è¿”å›ä¸‹æ ‡ï¼Œä¸èƒ½æ’åºï¼Œç”¨map\u0026lt;key, value\u0026gt;ç»“æ„è¿”å›ä¸¤è€…ã€‚ å“ˆå¸ŒvsåŒæŒ‡é’ˆï¼šå“ˆå¸Œæ³•å¯¹äºéœ€è¦å»é‡çš„é¢˜ç›®æ•ˆç‡è¾ƒä½ï¼Œå»ºè®®ä½¿ç”¨åŒæŒ‡é’ˆã€‚ 3.1 æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„å­—æ¯å¼‚ä½è¯ã€‚\nç¤ºä¾‹ 1: è¾“å…¥: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; è¾“å‡º: true\nç¤ºä¾‹ 2: è¾“å…¥: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; è¾“å‡º: false\nè¯´æ˜: ä½ å¯ä»¥å‡è®¾å­—ç¬¦ä¸²åªåŒ…å«å°å†™å­—æ¯ã€‚\næš´åŠ›ï¼šä¸¤å±‚forå¾ªç¯ï¼ŒåŒæ—¶è¿˜è¦è®°å½•å­—ç¬¦æ˜¯å¦é‡å¤å‡ºç°ï¼Œå¾ˆæ˜æ˜¾æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2)ã€‚ å“ˆå¸Œè¡¨ï¼šå®šä¸€ä¸ªæ•°ç»„å«åšrecordï¼Œå¤§å°ä¸º26ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå› ä¸ºå­—ç¬¦aåˆ°å­—ç¬¦zçš„ASCIIä¹Ÿæ˜¯26ä¸ªè¿ç»­çš„æ•°å€¼ã€‚O(n) O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 func isAnagram(s string, t string) bool { record := [26]int{} for _, v := range s { record[v - rune(\u0026#39;a\u0026#39;)] ++ } for _, v := range t { record[v - rune(\u0026#39;a\u0026#39;)] -- } return record == [26]int{} } 3.2 ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† ä½¿ç”¨æ•°ç»„æ¥åšå“ˆå¸Œçš„é¢˜ç›®ï¼Œæ˜¯å› ä¸ºé¢˜ç›®éƒ½é™åˆ¶äº†æ•°å€¼çš„å¤§å°ã€‚\næ²¡æœ‰é™åˆ¶æ•°å€¼çš„å¤§å°å°±æ— æ³•ä½¿ç”¨æ•°ç»„æ¥åšå“ˆå¸Œè¡¨äº†ã€‚\nè€Œä¸”å¦‚æœå“ˆå¸Œå€¼æ¯”è¾ƒå°‘ã€ç‰¹åˆ«åˆ†æ•£ã€è·¨åº¦éå¸¸å¤§ï¼Œä½¿ç”¨æ•°ç»„å°±é€ æˆç©ºé—´çš„æå¤§æµªè´¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solultion { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; res; unordered_set\u0026lt;int\u0026gt; nums(nums1.begin(), nums1.end()); for (auto num: nums2) { if (nums.find(num) != nums.end()) { res.insert(num); } } return vector\u0026lt;int\u0026gt;(res.begin(), res.end()); } }; // O(n + m) mæ˜¯æœ€åè¦æŠŠsetè½¬æˆvector // O(n) go:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func intersection(nums1 []int, nums2 []int) []int { set := make(map[int]struct{}, 0) // mapæ¨¡æ‹Ÿset res := make([]int, 0) for _, v := range nums1 { if _, ok := set[v]; !ok { set[v] = struct{}{} } } for _, v := range nums2 { // if exists in the last array, insert into res, and delete this set value. if _, ok := set[v]; ok { res = append(res, v) delete(set, v) // delete(map, key) } } return res } // v2: use array when the number of data is small func intersection(nums1 []int, nums2 []int) []int { count1 := make([]int, 1001, 1001) count2 := make([]int, 1001, 1001) res := make([]int, 0) for _, v := range nums1 { count1[v] = 1 } for _, v := range nums2 { count2[v] = 1 } for i := 0; i \u0026lt;= 1000; i ++ { if count1[i] + count2[i] == 2 { res = append(res, i) } } return res } 3.3 å¿«ä¹æ ‘ ç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤æ–­ä¸€ä¸ªæ•° n æ˜¯ä¸æ˜¯å¿«ä¹æ•°ã€‚\nã€Œå¿«ä¹æ•°ã€å®šä¹‰ä¸ºï¼šå¯¹äºä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸€æ¬¡å°†è¯¥æ•°æ›¿æ¢ä¸ºå®ƒæ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—çš„å¹³æ–¹å’Œï¼Œç„¶åé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°è¿™ä¸ªæ•°å˜ä¸º 1ï¼Œä¹Ÿå¯èƒ½æ˜¯ æ— é™å¾ªç¯ ä½†å§‹ç»ˆå˜ä¸åˆ° 1ã€‚å¦‚æœ å¯ä»¥å˜ä¸º 1ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯å¿«ä¹æ•°ã€‚\nå¦‚æœ n æ˜¯å¿«ä¹æ•°å°±è¿”å› True ï¼›ä¸æ˜¯ï¼Œåˆ™è¿”å› False ã€‚\næ€è·¯ï¼šåˆ¤æ–­sumæ˜¯å¦é‡å¤å‡ºç°è¿‡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while (1) { int sum = getSum(n); if (sum == 1) { return true; } if (set.find(sum) != set.end()) { return false; // sumå‡ºç°è¿‡ï¼Œæ­»å¾ªç¯äº† } else { set.insert(sum); } n = sum; } } // O(logn) O(logn) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getSum(n int) int { sum := 0 for n \u0026gt; 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } func isHappy(n int) bool { m := make(map[int]bool) for n != 1 \u0026amp;\u0026amp; m[n] == 0 { n, m[n] = getSum(n), true } return n == 1 } 3.4 ä¸¤æ•°ä¹‹å’Œ ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚\n242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ (opens new window)è¿™é“é¢˜ç›®æ˜¯ç”¨æ•°ç»„ä½œä¸ºå“ˆå¸Œè¡¨æ¥è§£å†³å“ˆå¸Œé—®é¢˜ï¼Œ349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† (opens new window)è¿™é“é¢˜ç›®æ˜¯é€šè¿‡setä½œä¸ºå“ˆå¸Œè¡¨æ¥è§£å†³å“ˆå¸Œé—®é¢˜ã€‚\nå¼ºè°ƒä¸€ä¸‹ ä»€ä¹ˆæ—¶å€™ä½¿ç”¨å“ˆå¸Œæ³•ï¼Œå½“æˆ‘ä»¬éœ€è¦æŸ¥è¯¢ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°è¿‡ï¼Œæˆ–è€…ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨é›†åˆé‡Œçš„æ—¶å€™ï¼Œå°±è¦ç¬¬ä¸€æ—¶é—´æƒ³åˆ°å“ˆå¸Œæ³•ã€‚\næœ¬é¢˜ï¼Œæˆ‘ä»¬ä¸ä»…è¦çŸ¥é“å…ƒç´ æœ‰æ²¡æœ‰éå†è¿‡ï¼Œè¿˜è¦çŸ¥é“è¿™ä¸ªå…ƒç´ å¯¹åº”çš„ä¸‹æ ‡ï¼Œéœ€è¦ä½¿ç”¨ key valueç»“æ„æ¥å­˜æ”¾ï¼Œkeyæ¥å­˜å…ƒç´ ï¼Œvalueæ¥å­˜ä¸‹æ ‡ï¼Œé‚£ä¹ˆä½¿ç”¨mapæ­£åˆé€‚ã€‚\nå†æ¥çœ‹ä¸€ä¸‹ä½¿ç”¨æ•°ç»„å’Œsetæ¥åšå“ˆå¸Œæ³•çš„å±€é™ã€‚ï¼ˆc++ï¼‰\næ•°ç»„çš„å¤§å°æ˜¯å—é™åˆ¶çš„ï¼Œè€Œä¸”å¦‚æœå…ƒç´ å¾ˆå°‘ï¼Œè€Œå“ˆå¸Œå€¼å¤ªå¤§ä¼šé€ æˆå†…å­˜ç©ºé—´çš„æµªè´¹ã€‚ setæ˜¯ä¸€ä¸ªé›†åˆï¼Œé‡Œé¢æ”¾çš„å…ƒç´ åªèƒ½æ˜¯ä¸€ä¸ªkeyï¼Œè€Œä¸¤æ•°ä¹‹å’Œè¿™é“é¢˜ç›®ï¼Œä¸ä»…è¦åˆ¤æ–­yæ˜¯å¦å­˜åœ¨è€Œä¸”è¿˜è¦è®°å½•yçš„ä¸‹æ ‡ä½ç½®ï¼Œå› ä¸ºè¦è¿”å›x å’Œ yçš„ä¸‹æ ‡ã€‚æ‰€ä»¥set ä¹Ÿä¸èƒ½ç”¨ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // æš´åŠ› func twoSum(nums []int, target int) []int { for k1, _ := range nums { for k2 := k1 + 1; k2 \u0026lt; len(nums); k2 ++ { if target == nums[k1] + nums[k2] { return []int{k1, k2} } } } return []int{} } // map func twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if pre, ok := m[target - v]; ok { return []int{pre, i} } else { m[v] = i } } return []int{} } 3.5 å››æ•°ç›¸åŠ II (ç»å…¸é¢˜ç›®) ç»™å®šå››ä¸ªåŒ…å«æ•´æ•°çš„æ•°ç»„åˆ—è¡¨ A , B , C , D ,è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç»„ (i, j, k, l) ï¼Œä½¿å¾— A[i] + B[j] + C[k] + D[l] = 0ã€‚\nä¸ºäº†ä½¿é—®é¢˜ç®€å•åŒ–ï¼Œæ‰€æœ‰çš„ A, B, C, D å…·æœ‰ç›¸åŒçš„é•¿åº¦ Nï¼Œä¸” 0 â‰¤ N â‰¤ 500 ã€‚æ‰€æœ‰æ•´æ•°çš„èŒƒå›´åœ¨ -2^28 åˆ° 2^28 - 1 ä¹‹é—´ï¼Œæœ€ç»ˆç»“æœä¸ä¼šè¶…è¿‡ 2^31 - 1 ã€‚\nè¿™é“é¢˜ç›®æ˜¯å››ä¸ªç‹¬ç«‹çš„æ•°ç»„ï¼Œåªè¦æ‰¾åˆ°A[i] + B[j] + C[k] + D[l] = 0å°±å¯ä»¥ï¼Œä¸ç”¨è€ƒè™‘æœ‰é‡å¤çš„å››ä¸ªå…ƒç´ ç›¸åŠ ç­‰äº0çš„æƒ…å†µï¼Œæ‰€ä»¥ç›¸å¯¹äºé¢˜ç›®18. å››æ•°ä¹‹å’Œï¼Œé¢˜ç›®15.ä¸‰æ•°ä¹‹å’Œï¼Œè¿˜æ˜¯ç®€å•äº†ä¸å°‘ï¼\nå¦‚æœæœ¬é¢˜æƒ³éš¾åº¦å‡çº§ï¼šå°±æ˜¯ç»™å‡ºä¸€ä¸ªæ•°ç»„ï¼ˆè€Œä¸æ˜¯å››ä¸ªæ•°ç»„ï¼‰ï¼Œåœ¨è¿™é‡Œæ‰¾å‡ºå››ä¸ªå…ƒç´ ç›¸åŠ ç­‰äº0ï¼Œç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„å››å…ƒç»„ï¼Œå¤§å®¶å¯ä»¥æ€è€ƒä¸€ä¸‹ï¼Œåç»­çš„æ–‡ç« æˆ‘ä¹Ÿä¼šè®²åˆ°çš„ã€‚\næ€è·¯ é¦–å…ˆå®šä¹‰ ä¸€ä¸ªunordered_mapï¼Œkeyæ”¾aå’Œbä¸¤æ•°ä¹‹å’Œï¼Œvalue æ”¾aå’Œbä¸¤æ•°ä¹‹å’Œå‡ºç°çš„æ¬¡æ•°ã€‚ éå†å¤§Aå’Œå¤§Bæ•°ç»„ï¼Œç»Ÿè®¡ä¸¤ä¸ªæ•°ç»„å…ƒç´ ä¹‹å’Œï¼Œå’Œå‡ºç°çš„æ¬¡æ•°ï¼Œæ”¾åˆ°mapä¸­ã€‚ å®šä¹‰intå˜é‡countï¼Œç”¨æ¥ç»Ÿè®¡ a+b+c+d = 0 å‡ºç°çš„æ¬¡æ•°ã€‚ å†éå†å¤§Cå’Œå¤§Dæ•°ç»„ï¼Œæ‰¾åˆ°å¦‚æœ 0-(c+d) åœ¨mapä¸­å‡ºç°è¿‡çš„è¯ï¼Œå°±ç”¨countæŠŠmapä¸­keyå¯¹åº”çš„valueä¹Ÿå°±æ˜¯å‡ºç°æ¬¡æ•°ç»Ÿè®¡å‡ºæ¥ã€‚ æœ€åè¿”å›ç»Ÿè®¡å€¼ count å°±å¯ä»¥äº† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) // k: a+b v: a+bæ•°å€¼å‡ºç°çš„æ¬¡æ•° count := 0 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1 + v2] ++ } } for _, v3 := range nums3 { for _, v4 := range nums4 { count += m[-v3-v4] } } return count } 3.6 èµé‡‘ä¿¡ ç»™å®šä¸€ä¸ªèµé‡‘ä¿¡ (ransom) å­—ç¬¦ä¸²å’Œä¸€ä¸ªæ‚å¿—(magazine)å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸² ransom èƒ½ä¸èƒ½ç”±ç¬¬äºŒä¸ªå­—ç¬¦ä¸² magazines é‡Œé¢çš„å­—ç¬¦æ„æˆã€‚å¦‚æœå¯ä»¥æ„æˆï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› falseã€‚\n(é¢˜ç›®è¯´æ˜ï¼šä¸ºäº†ä¸æš´éœ²èµé‡‘ä¿¡å­—è¿¹ï¼Œè¦ä»æ‚å¿—ä¸Šæœç´¢å„ä¸ªéœ€è¦çš„å­—æ¯ï¼Œç»„æˆå•è¯æ¥è¡¨è¾¾æ„æ€ã€‚æ‚å¿—å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦åªèƒ½åœ¨èµé‡‘ä¿¡å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ä¸€æ¬¡ã€‚)\næ³¨æ„ï¼š\nä½ å¯ä»¥å‡è®¾ä¸¤ä¸ªå­—ç¬¦ä¸²å‡åªå«æœ‰å°å†™å­—æ¯ã€‚\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\nhttps://leetcode.cn/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func canConstruct(ransomNote string, magazine string) bool { if len(ransomNote) \u0026gt; len(magazine) { return false } cnt := [26]int{} for _, v := range magazine { cnt[v - \u0026#39;a\u0026#39;] ++ } for _, v := range ransomNote { cnt[v - \u0026#39;a\u0026#39;] -- if cnt[v - \u0026#39;a\u0026#39;] \u0026lt; 0 { return false } } return true } 3.7 ä¸‰æ•°ä¹‹å’Œ ç»™ä½ ä¸€ä¸ªåŒ…å« n ä¸ªæ•´æ•°çš„æ•°ç»„ numsï¼Œåˆ¤æ–­ nums ä¸­æ˜¯å¦å­˜åœ¨ä¸‰ä¸ªå…ƒç´  aï¼Œbï¼Œc ï¼Œä½¿å¾— a + b + c = 0 ï¼Ÿè¯·ä½ æ‰¾å‡ºæ‰€æœ‰æ»¡è¶³æ¡ä»¶ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚\næ³¨æ„ï¼š ç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚\nç¤ºä¾‹ï¼š\nç»™å®šæ•°ç»„ nums = [-1, 0, 1, 2, -1, -4]ï¼Œ\næ»¡è¶³è¦æ±‚çš„ä¸‰å…ƒç»„é›†åˆä¸ºï¼š [ [-1, 0, 1], [-1, -1, 2] ]\nè¦ç‚¹ï¼šå»é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); // find a+b+c=0 for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (nums[i] \u0026gt; 0) return res; // å»é‡aï¼Œè¿™é‡Œä¸èƒ½æ˜¯nums[i] == nums[i + 1] if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int l = i + 1; int r = nums.size() - 1; while (r \u0026gt; l) { if (nums[i] + nums[l] + nums[r] \u0026gt; 0) r -- ; else if (nums[i] + nums[l] + nums[r]) l ++ ; else { res.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[l], nums[r]}); // å»é‡bå’Œcæ”¾åœ¨æ‰¾åˆ°ä¸€ä¸ªä¸‰å…ƒç»„ä¹‹å while (r \u0026gt; l \u0026amp;\u0026amp; nums[r] == nums[r - 1]) r -- ; while (r \u0026gt; l \u0026amp;\u0026amp; nums[l] == nums[l + 1]) l ++ ; // æ‰¾åˆ°ç­”æ¡ˆæ—¶åŒæŒ‡é’ˆåŒæ—¶æ”¶ç¼© r -- , l ++ ; } } } return res; } æˆ‘ä»¬è¦åšçš„æ˜¯ ä¸èƒ½æœ‰é‡å¤çš„ä¸‰å…ƒç»„ï¼Œä½†ä¸‰å…ƒç»„å†…çš„å…ƒç´ æ˜¯å¯ä»¥é‡å¤çš„ï¼\nä¸¤æ•°ä¹‹å’Œ å°±ä¸èƒ½ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼Œå› ä¸º1.ä¸¤æ•°ä¹‹å’Œ (opens new window)è¦æ±‚è¿”å›çš„æ˜¯ç´¢å¼•ä¸‹æ ‡ï¼Œ è€ŒåŒæŒ‡é’ˆæ³•ä¸€å®šè¦æ’åºï¼Œä¸€æ—¦æ’åºä¹‹ååŸæ•°ç»„çš„ç´¢å¼•å°±è¢«æ”¹å˜äº†ã€‚\nå¦‚æœ1.ä¸¤æ•°ä¹‹å’Œ (opens new window)è¦æ±‚è¿”å›çš„æ˜¯æ•°å€¼çš„è¯ï¼Œå°±å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ³•äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func threeSum(nums []int) [][]int { sort.Ints(nums) res := [][]int{} for i := 0; i \u0026lt; len(nums) - 2; i ++ { n1 := nums[i] if n1 \u0026gt; 0 { return res } if i \u0026gt; 0 \u0026amp;\u0026amp; n1 == nums[i - 1] { continue } l, r := i + 1, len(nums) - 1 for l \u0026lt; r { n2, n3 := nums[l], nums[r] if n1 + n2 + n3 == 0 { res = append(res, []int{n1, n2, n3}) for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == n2 { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == n3 { r -- } } else if n1 + n2 + n3 \u0026gt; 0 { r -- } else { l ++ } } } return res } 3.8 å››æ•°ä¹‹å’Œ é¢˜æ„ï¼šç»™å®šä¸€ä¸ªåŒ…å« n ä¸ªæ•´æ•°çš„æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œåˆ¤æ–­ nums ä¸­æ˜¯å¦å­˜åœ¨å››ä¸ªå…ƒç´  aï¼Œbï¼Œc å’Œ d ï¼Œä½¿å¾— a + b + c + d çš„å€¼ä¸ target ç›¸ç­‰ï¼Ÿæ‰¾å‡ºæ‰€æœ‰æ»¡è¶³æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„ã€‚\næ³¨æ„ï¼š\nç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„å››å…ƒç»„ã€‚\nç¤ºä¾‹ï¼š ç»™å®šæ•°ç»„ nums = [1, 0, -1, 0, -2, 2]ï¼Œå’Œ target = 0ã€‚ æ»¡è¶³è¦æ±‚çš„å››å…ƒç»„é›†åˆä¸ºï¼š [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\næ€è·¯ï¼šå’Œä¸‰æ•°ä¹‹å’Œä¸€æ ·ä½¿ç”¨ åŒæŒ‡é’ˆ ï¼ŒåŸºæœ¬æ€è·¯å°±æ˜¯åœ¨æ­¤åŸºç¡€ä¸ŠåŠ ä¸€å±‚forå¾ªç¯ã€‚\nç»†èŠ‚ï¼šä¸èƒ½åˆ¤æ–­äº†nums[k] \u0026gt; targetå°±è¿”å›ï¼Œå› ä¸ºtargetæ˜¯ä»»æ„å€¼ï¼Œé‡åˆ°è´Ÿæ•°å°±ä¸å¥½ç›´æ¥è·³å‡ºäº†ï¼›\nä½†å¯ä»¥åšå‰ªæï¼Œ nums[i] \u0026gt; target \u0026amp;\u0026amp; (nums[i] \u0026gt;= 0 || target \u0026gt;= 0)\n15.ä¸‰æ•°ä¹‹å’Œ (opens new window)çš„åŒæŒ‡é’ˆè§£æ³•æ˜¯ä¸€å±‚forå¾ªç¯num[i]ä¸ºç¡®å®šå€¼ï¼Œç„¶åå¾ªç¯å†…æœ‰leftå’Œrightä¸‹æ ‡ä½œä¸ºåŒæŒ‡é’ˆï¼Œæ‰¾åˆ°nums[i] + nums[left] + nums[right] == 0ã€‚\nå››æ•°ä¹‹å’Œçš„åŒæŒ‡é’ˆè§£æ³•æ˜¯ä¸¤å±‚forå¾ªç¯nums[k] + nums[i]ä¸ºç¡®å®šå€¼ï¼Œä¾ç„¶æ˜¯å¾ªç¯å†…æœ‰leftå’Œrightä¸‹æ ‡ä½œä¸ºåŒæŒ‡é’ˆï¼Œæ‰¾å‡ºnums[k] + nums[i] + nums[left] + nums[right] == targetçš„æƒ…å†µï¼Œä¸‰æ•°ä¹‹å’Œçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2)ï¼Œå››æ•°ä¹‹å’Œçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n^3) ã€‚\né‚£ä¹ˆä¸€æ ·çš„é“ç†ï¼Œäº”æ•°ä¹‹å’Œã€å…­æ•°ä¹‹å’Œç­‰ç­‰éƒ½é‡‡ç”¨è¿™ç§è§£æ³•ã€‚\nå¯¹äº15.ä¸‰æ•°ä¹‹å’Œ (opens new window)åŒæŒ‡é’ˆæ³•å°±æ˜¯å°†åŸæœ¬æš´åŠ›O(n^3)çš„è§£æ³•ï¼Œé™ä¸ºO(n^2)çš„è§£æ³•ï¼Œå››æ•°ä¹‹å’Œçš„åŒæŒ‡é’ˆè§£æ³•å°±æ˜¯å°†åŸæœ¬æš´åŠ›O(n^4)çš„è§£æ³•ï¼Œé™ä¸ºO(n^3)çš„è§£æ³•ã€‚\nä¹‹å‰æˆ‘ä»¬è®²è¿‡å“ˆå¸Œè¡¨çš„ç»å…¸é¢˜ç›®ï¼š454.å››æ•°ç›¸åŠ II (opens new window)ï¼Œç›¸å¯¹äºæœ¬é¢˜ç®€å•å¾ˆå¤šï¼Œå› ä¸ºæœ¬é¢˜æ˜¯è¦æ±‚åœ¨ä¸€ä¸ªé›†åˆä¸­æ‰¾å‡ºå››ä¸ªæ•°ç›¸åŠ ç­‰äºtargetï¼ŒåŒæ—¶å››å…ƒç»„ä¸èƒ½é‡å¤ã€‚\nåŒæŒ‡é’ˆæ³•å°†æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)çš„è§£æ³•ä¼˜åŒ–ä¸º O(n)çš„è§£æ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func fourSum(nums []int, target int) [][]int { if len(nums) \u0026lt; 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u0026lt; len(nums) - 3; i ++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] { continue } for j := i + 1; j \u0026lt; len(nums) - 2; j ++ { if j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1] { continue } l, r := j + 1, len(nums) - 1 for l \u0026lt; r { sum := nums[i] + nums[j] + nums[l] + nums[r] if sum \u0026lt; target { l ++ } else if sum \u0026gt; target { r -- } else { res = append(res, []int{nums[i], nums[j], nums[l], nums[r]}) // å»é‡ for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == nums[l + 1] { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == nums[r - 1] { r -- } // æ‰¾åˆ°ç­”æ¡ˆæ—¶ï¼Œl råŒæ—¶é è¿‘ r -- l ++ } } } } return res } å­—ç¬¦ä¸²ï¼ˆå®Œï¼‰ 4.1 åè½¬å­—ç¬¦ä¸² ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ char[] çš„å½¢å¼ç»™å‡ºã€‚\nä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚\nä½ å¯ä»¥å‡è®¾æ•°ç»„ä¸­çš„æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯ ASCII ç è¡¨ä¸­çš„å¯æ‰“å°å­—ç¬¦ã€‚\nç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] è¾“å‡ºï¼š[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\næ€è·¯ï¼š\nåŒæŒ‡é’ˆã€‚å­—ç¬¦ä¸²ä¹Ÿæ˜¯ä¸€ç§æ•°ç»„ï¼Œæ‰€ä»¥å…ƒç´ åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­åˆ†å¸ƒï¼Œè¿™å°±å†³å®šäº†åè½¬é“¾è¡¨å’Œåè½¬å­—ç¬¦ä¸²æ–¹å¼ä¸Šè¿˜æ˜¯æœ‰æ‰€å·®å¼‚çš„ã€‚\nå¯¹äºå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼ˆä¹Ÿå¯ä»¥è¯´æ˜¯ç´¢å¼•ä¸‹æ ‡ï¼‰ï¼Œä¸€ä¸ªä»å­—ç¬¦ä¸²å‰é¢ï¼Œä¸€ä¸ªä»å­—ç¬¦ä¸²åé¢ï¼Œä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶å‘ä¸­é—´ç§»åŠ¨ï¼Œå¹¶äº¤æ¢å…ƒç´ ã€‚ 1 2 3 4 5 6 7 8 func reverseString(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.2 åè½¬2 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ•´æ•° kï¼Œä»å­—ç¬¦ä¸²å¼€å¤´ç®—èµ·, æ¯è®¡æ•°è‡³ 2k ä¸ªå­—ç¬¦ï¼Œå°±åè½¬è¿™ 2k ä¸ªå­—ç¬¦ä¸­çš„å‰ k ä¸ªå­—ç¬¦ã€‚\nå¦‚æœå‰©ä½™å­—ç¬¦å°‘äº k ä¸ªï¼Œåˆ™å°†å‰©ä½™å­—ç¬¦å…¨éƒ¨åè½¬ã€‚\nå¦‚æœå‰©ä½™å­—ç¬¦å°äº 2k ä½†å¤§äºæˆ–ç­‰äº k ä¸ªï¼Œåˆ™åè½¬å‰ k ä¸ªå­—ç¬¦ï¼Œå…¶ä½™å­—ç¬¦ä¿æŒåŸæ ·ã€‚\nç¤ºä¾‹:\nè¾“å…¥: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 è¾“å‡º: \u0026ldquo;bacdfeg\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseStr(s string, k int) string { bs := []byte(s) for i := 0; i \u0026lt; len(s); i += 2 * k { if i + k \u0026lt; len(bs) { reverse(bs[i: i + k]) } else { reverse(bs[i: len(s)]) } } return string(bs) } func reverse(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.3 æ›¿æ¢æ•°å­— goå­—ç¬¦ä¸²å’ŒC++çš„åŒºåˆ«ï¼š\ngoä¸­çš„stringç±»å‹æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œéœ€è¦è½¬æ¢æˆ[]byte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { var bs []byte fmt.Scanln(\u0026amp;bs) for i := 0; i \u0026lt; len(bs); i ++ { if bs[i] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; bs[i] \u0026gt;= \u0026#39;0\u0026#39; { insertNum := []byte{\u0026#39;n\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;r\u0026#39;} bs = append(bs[:i], append(insertNum, bs[i+1:]...)...) i = i + len(insertNum) - 1 } } fmt.Printf(string(bs)) } 4.4 ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯ï¼ˆå¤æ‚é¢˜ç›®ï¼‰ ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé€ä¸ªç¿»è½¬å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå•è¯ã€‚\nç¤ºä¾‹ 1ï¼š è¾“å…¥: \u0026ldquo;the sky is blue\u0026rdquo; è¾“å‡º: \u0026ldquo;blue is sky the\u0026rdquo;\nç¤ºä¾‹ 2ï¼š è¾“å…¥: \u0026quot; hello world! \u0026quot; è¾“å‡º: \u0026ldquo;world! hello\u0026rdquo; è§£é‡Š: è¾“å…¥å­—ç¬¦ä¸²å¯ä»¥åœ¨å‰é¢æˆ–è€…åé¢åŒ…å«å¤šä½™çš„ç©ºæ ¼ï¼Œä½†æ˜¯åè½¬åçš„å­—ç¬¦ä¸èƒ½åŒ…æ‹¬ã€‚\nç¤ºä¾‹ 3ï¼š è¾“å…¥: \u0026ldquo;a good example\u0026rdquo; è¾“å‡º: \u0026ldquo;example good a\u0026rdquo; è§£é‡Š: å¦‚æœä¸¤ä¸ªå•è¯é—´æœ‰å¤šä½™çš„ç©ºæ ¼ï¼Œå°†åè½¬åå•è¯é—´çš„ç©ºæ ¼å‡å°‘åˆ°åªå«ä¸€ä¸ªã€‚\næ€è·¯ï¼š\nç§»é™¤å¤šä½™ç©ºæ ¼\næ•´ä½“ç¿»è½¬\nå•è¯ç¿»è½¬\nè¦æ±‚ï¼šä¸é€‚ç”¨è¾…åŠ©ç©ºé—´ï¼Œç©ºé—´å¤æ‚åº¦O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func reverseWords(s string) string { b := []byte(s) // ç§»é™¤å‰é¢ã€ä¸­é—´ã€åé¢å­˜åœ¨çš„å¤šä½™ç©ºæ ¼ slow := 0 for i := 0; i \u0026lt; len(b); i++ { if b[i] != \u0026#39; \u0026#39; { if slow != 0 { b[slow] = \u0026#39; \u0026#39; slow++ } for i \u0026lt; len(b) \u0026amp;\u0026amp; b[i] != \u0026#39; \u0026#39; { // å¤åˆ¶é€»è¾‘ b[slow] = b[i] slow++ i++ } } } b = b[0:slow] // ç¿»è½¬æ•´ä¸ªå­—ç¬¦ä¸² reverse(b) // ç¿»è½¬æ¯ä¸ªå•è¯ last := 0 for i := 0; i \u0026lt;= len(b); i++ { if i == len(b) || b[i] == \u0026#39; \u0026#39; { reverse(b[last:i]) last = i + 1 } } return string(b) } func reverse(b []byte) { left := 0 right := len(b) - 1 for left \u0026lt; right { b[left], b[right] = b[right], b[left] left++ right-- } } 4.5 å³æ—‹å­—ç¬¦ä¸² å­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œæ˜¯æŠŠå­—ç¬¦ä¸²å°¾éƒ¨çš„è‹¥å¹²ä¸ªå­—ç¬¦è½¬ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„åé¢ k ä¸ªå­—ç¬¦ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ï¼Œå®ç°å­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œã€‚\nä¾‹å¦‚ï¼Œå¯¹äºè¾“å…¥å­—ç¬¦ä¸² \u0026ldquo;abcdefg\u0026rdquo; å’Œæ•´æ•° 2ï¼Œå‡½æ•°åº”è¯¥å°†å…¶è½¬æ¢ä¸º \u0026ldquo;fgabcde\u0026rdquo;ã€‚\næ€è·¯ï¼šå…ˆæ•´ä½“åè½¬ï¼Œå†å±€éƒ¨åè½¬ã€‚abcdefg =\u0026gt; gf | edcba =\u0026gt; fg | abcde\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func reverse(s []byte, l, r int) { for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } func main() { var s string var k int fmt.Scanln(\u0026amp;k) fmt.Scanln(\u0026amp;s) bs := []byte(s) reverse(bs, 0, len(s) - 1) reverse(bs, 0, k - 1) reverse(bs, k, len(s) - 1) fmt.Println(string(bs)) } 4.6 å®ç°strStr() å®ç° strStr() å‡½æ•°ã€‚\nç»™å®šä¸€ä¸ª haystack å­—ç¬¦ä¸²å’Œä¸€ä¸ª needle å­—ç¬¦ä¸²ï¼Œåœ¨ haystack å­—ç¬¦ä¸²ä¸­æ‰¾å‡º needle å­—ç¬¦ä¸²å‡ºç°çš„ç¬¬ä¸€ä¸ªä½ç½® (ä»0å¼€å§‹)ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å› -1ã€‚\nç¤ºä¾‹ 1: è¾“å…¥: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; è¾“å‡º: 2\nç¤ºä¾‹ 2: è¾“å…¥: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; è¾“å‡º: -1\nè¯´æ˜: å½“ needle æ˜¯ç©ºå­—ç¬¦ä¸²æ—¶ï¼Œæˆ‘ä»¬åº”å½“è¿”å›ä»€ä¹ˆå€¼å‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªåœ¨é¢è¯•ä¸­å¾ˆå¥½çš„é—®é¢˜ã€‚ å¯¹äºæœ¬é¢˜è€Œè¨€ï¼Œå½“ needle æ˜¯ç©ºå­—ç¬¦ä¸²æ—¶æˆ‘ä»¬åº”å½“è¿”å› 0 ã€‚\nKMPç®—æ³•ï¼š è§£å†³å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ã€‚å½“å‡ºç°å­—ç¬¦ä¸²ä¸åŒ¹é…æ—¶ï¼Œå¯ä»¥è®°å½•ä¸€éƒ¨åˆ†ä¹‹å‰å·²ç»åŒ¹é…çš„æ–‡æœ¬å†…å®¹ï¼Œåˆ©ç”¨è¿™äº›ä¿¡æ¯é¿å…ä»å¤´å†å»åšåŒ¹é…ã€‚ å‰ç¼€è¡¨ï¼šèµ·å§‹ä½ç½®åˆ°ä¸‹æ ‡iä¹‹å‰ï¼ˆåŒ…æ‹¬iï¼‰çš„å­ä¸²ä¸­ï¼Œæœ‰å¤šå¤§é•¿åº¦çš„ç›¸åŒå‰ç¼€åç¼€ã€‚\nå‰ç¼€è¡¨æ˜¯ç”¨æ¥å›é€€çš„ï¼Œå®ƒè®°å½•äº†æ¨¡å¼ä¸²ä¸ä¸»ä¸²(æ–‡æœ¬ä¸²)ä¸åŒ¹é…çš„æ—¶å€™ï¼Œæ¨¡å¼ä¸²åº”è¯¥ä»å“ªé‡Œå¼€å§‹é‡æ–°åŒ¹é…ã€‚\nå½“å‰ä¸åŒ¹é…ä½ç½®iå‰é¢ï¼ˆåŒ…æ‹¬iï¼‰æ‰€æœ‰å­ä¸²ä¸­çš„æœ€é•¿ç›¸ç­‰å‰åç¼€çš„é•¿åº¦ï¼Œå³æ¨¡å¼ä¸²ä¸Šé‡æ–°åŒ¹é…çš„ä½ç½®\nå‰ç¼€ï¼šåŒ…å«é¦–å­—æ¯ï¼Œä½†ä¸åŒ…å«å°¾å­—æ¯çš„æ‰€æœ‰å­ä¸² åç¼€ï¼šåä¹‹\nä¸ºä»€ä¹ˆç”¨å‰ç¼€è¡¨ï¼Ÿ ä¸‹æ ‡5ä¹‹å‰è¿™éƒ¨åˆ†çš„å­—ç¬¦ä¸²ï¼ˆä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²aabaaï¼‰çš„æœ€é•¿ç›¸ç­‰çš„å‰ç¼€ å’Œ åç¼€å­—ç¬¦ä¸²æ˜¯ å­å­—ç¬¦ä¸²aa ï¼Œå› ä¸ºæ‰¾åˆ°äº†æœ€é•¿ç›¸ç­‰çš„å‰ç¼€å’Œåç¼€ï¼ŒåŒ¹é…å¤±è´¥çš„ä½ç½®æ˜¯åç¼€å­ä¸²çš„åé¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ‰¾åˆ°ä¸å…¶ç›¸åŒçš„å‰ç¼€çš„åé¢é‡æ–°åŒ¹é…å°±å¯ä»¥äº†ã€‚ e.g. æ–‡æœ¬ä¸²ï¼šaabaabaaf æ¨¡å¼ä¸²ï¼šaabaafï¼Œå…¶å‰ç¼€è¡¨ä¸ºï¼š010120 nextæ•°ç»„| prefixæ•°ç»„\nå®ç°ï¼šåœ¨åŒ¹é…æ—¶ï¼Œåœ¨æ¨¡å¼ä¸²få¤„å‘ç”Ÿå†²çªï¼Œæ¥ä¸‹æ¥çœ‹få‰ä¸€ä½çš„nextæ•°ç»„å€¼ï¼Œä¸º2ï¼Œæ•…è·³è½¬åˆ°æ¨¡å¼ä¸²ä¸‹æ ‡ä¸º2çš„ä½ç½®ç»§ç»­åŒ¹é…ã€‚\nnextæ•°ç»„çš„ä¸åŒå®ç° æ•´ä½“å³ç§»ï¼Œé¦–ä½æ·»åŠ -1 ï¼š -1 0 1 0 1 2\nå®ç°ï¼šåœ¨åŒ¹é…æ—¶ï¼Œåœ¨æ¨¡å¼ä¸²få¤„å‘ç”Ÿå†²çªï¼Œçœ‹fçš„nextæ•°ç»„å€¼ï¼Œä¸º2ï¼Œæ•…è·³è½¬åˆ°æ¨¡å¼ä¸²ä¸‹æ ‡ä¸º2çš„ä½ç½®ç»§ç»­åŒ¹é…ã€‚\næ•´ä½“å‡1ï¼š -1 0 -1 0 1 -1\nå­ä¸² æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ a 0 aa 1 (a a) aab 0 aaba 1 (a a) aabaa 2 (aa aa) aabaaf 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // å‰ç¼€è¡¨ä¸å‡ä¸€ or å³ç§» func getNext(next []int, s string) { j := 0 // jè¡¨ç¤º æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j] { j = next[j - 1] } if s[i] == s[j] { j ++ } next[i] = j // next[i]æ˜¯iï¼ˆåŒ…æ‹¬iï¼‰ä¹‹å‰çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := 0 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; hayStack[i] != needle[j] { j = next[j - 1] } if hayStack[i] == needle[j] { j ++ } if j == n { return i - n + 1 } } return -1 } // å‡ä¸€å®ç° func getNext(next []int, s string) { j := -1 next[0] = -1 for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] // å›é€€å‰ä¸€ä½ } if s[i] == s[j + 1] { j ++ } next[i] = j } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := -1 // æ¨¡å¼ä¸²çš„èµ·å§‹ä½ç½® nextä¸º-1 å› æ­¤ä¹Ÿä¸º-1 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; hayStack[i] != needle[j + 1] { j = next[j] } if hayStack[i] == needle[j + 1] { j ++ } if j == n - 1 { return i - n + 1 } } return -1 } 4.7 é‡å¤å­ä¸² ç»™å®šä¸€ä¸ªéç©ºçš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦å¯ä»¥ç”±å®ƒçš„ä¸€ä¸ªå­ä¸²é‡å¤å¤šæ¬¡æ„æˆã€‚ç»™å®šçš„å­—ç¬¦ä¸²åªå«æœ‰å°å†™è‹±æ–‡å­—æ¯ï¼Œå¹¶ä¸”é•¿åº¦ä¸è¶…è¿‡10000ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: \u0026ldquo;abab\u0026rdquo; è¾“å‡º: True è§£é‡Š: å¯ç”±å­å­—ç¬¦ä¸² \u0026ldquo;ab\u0026rdquo; é‡å¤ä¸¤æ¬¡æ„æˆã€‚ ç¤ºä¾‹ 2:\nè¾“å…¥: \u0026ldquo;aba\u0026rdquo; è¾“å‡º: False ç¤ºä¾‹ 3:\nè¾“å…¥: \u0026ldquo;abcabcabcabc\u0026rdquo; è¾“å‡º: True è§£é‡Š: å¯ç”±å­å­—ç¬¦ä¸² \u0026ldquo;abc\u0026rdquo; é‡å¤å››æ¬¡æ„æˆã€‚ (æˆ–è€…å­å­—ç¬¦ä¸² \u0026ldquo;abcabc\u0026rdquo; é‡å¤ä¸¤æ¬¡æ„æˆã€‚ æ€è·¯ï¼š\n1.ç§»åŠ¨åŒ¹é… åˆ¤æ–­å­—ç¬¦ä¸²sæ˜¯å¦ç”±é‡å¤å­ä¸²ç»„æˆï¼Œåªè¦ä¸¤ä¸ªsæ‹¼æ¥åœ¨ä¸€èµ·ï¼Œé‡Œé¢è¿˜å‡ºç°ä¸€ä¸ªsçš„è¯ï¼Œå°±è¯´æ˜æ˜¯ç”±é‡å¤å­ä¸²ç»„æˆã€‚åœ¨åˆ¤æ–­ s + s æ‹¼æ¥çš„å­—ç¬¦ä¸²é‡Œæ˜¯å¦å‡ºç°ä¸€ä¸ªsçš„çš„æ—¶å€™ï¼Œè¦åˆ¨é™¤ s + s çš„é¦–å­—ç¬¦å’Œå°¾å­—ç¬¦ï¼Œè¿™æ ·é¿å…åœ¨s+sä¸­æœç´¢å‡ºåŸæ¥çš„sï¼Œæˆ‘ä»¬è¦æœç´¢çš„æ˜¯ä¸­é—´æ‹¼æ¥å‡ºæ¥çš„sã€‚\n1 2 3 4 5 6 7 func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } t := s + s return strings.Contains(t[1:len(t)-1], s) } 2.KMP æœ€å°é‡å¤å­ä¸²ï¼šå› ä¸º æœ€é•¿ç›¸ç­‰å‰åç¼€çš„è§„åˆ™ï¼Œå½“ä¸€ä¸ªå­—ç¬¦ä¸²ç”±é‡å¤å­ä¸²ç»„æˆçš„ï¼Œæœ€é•¿ç›¸ç­‰å‰åç¼€ä¸åŒ…å«çš„å­ä¸²å°±æ˜¯æœ€å°é‡å¤å­ä¸²ã€‚\nlen % (len - (next[len - 1] + 1)) ä¹Ÿå°±æ˜¯ï¼š 12(å­—ç¬¦ä¸²çš„é•¿åº¦) - 8(æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦) = 4ï¼Œ 4æ­£å¥½å¯ä»¥è¢« 12(å­—ç¬¦ä¸²çš„é•¿åº¦) æ•´é™¤ï¼Œæ‰€ä»¥è¯´æ˜æœ‰é‡å¤çš„å­å­—ç¬¦ä¸²ï¼ˆasdfï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func repeatedSubstringPattern(s string) bool { n := len(s) if len(s) == 0 { return false } j := -1 next := make([]int, len(s)) next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] } if s[i] == s[j + 1] { j ++ } next[i] = j } // next[n-1]+1 æœ€é•¿ç›¸åŒå‰åç¼€çš„é•¿åº¦ if next[n-1] != -1 \u0026amp;\u0026amp; n%(n-(next[n-1]+1)) == 0 { return true } return false } åŒæŒ‡é’ˆæ³•ï¼ˆå®Œï¼‰ 1.3 ç§»é™¤å…ƒç´ \n4.1 åè½¬å­—ç¬¦ä¸²\n4.3 æ›¿æ¢æ•°å­—\n4.4 ç¿»è½¬ä¸²é‡Œçš„å•è¯\n2.3 ç¿»è½¬é“¾è¡¨\n2.5\n2.6\n2.7\n3.7\n3.8\næ ˆå’Œé˜Ÿåˆ—ï¼ˆå®Œï¼‰ goæ ˆ\n1 2 3 4 5 6 7 8 9 // create stack stack := make([]int, 0) // push stack = append(stack, 10) // pop val := stack[len(stack)-1] stack = stack[:len(stack)-1] // empty len(stack) == 0 go queue\n1 2 3 4 5 6 7 8 9 // create queue := make([]int, 0) // enqueue queue = append(queue, 10) // dequeue val := queue[0] queue = queue[1:] // empty len(queue) == 0 6.1 æ ˆæ¨¡æ‹Ÿé˜Ÿåˆ— 1 queue = 1 è¾“å…¥stack + 1 è¾“å‡ºstack\npushï¼šå…¥é˜Ÿ = å…¥æ ˆ popï¼šifè¾“å‡ºæ ˆç©ºï¼Œå°±å°†è¾“å…¥æ ˆä¸­æ•°æ®allå¯¼å…¥è¾“å‡ºæ ˆï¼Œå†ä»è¾“å‡ºæ ˆpopï¼›ifè¾“å‡ºæ ˆä¸ç©ºï¼Œå°±ç›´æ¥pop emptyï¼šifè¾“å…¥æ ˆå’Œè¾“å‡ºæ ˆéƒ½ä¸ºç©ºäº†ï¼Œåˆ™æ¨¡æ‹Ÿçš„é˜Ÿåˆ—ä¸ºç©ºã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // ------------stack------------- type MyStack []int func (s *MyStack) Push(v int) { *s = append(*s, v) } func (s *MyStack) Pop() int { val := (*s)[len(*s) - 1] *s = (*s)[:len(*s) - 1] return val } func (s *MyStack) Peek() int { return (*s)[len(*s) - 1] } func (s *MyStack) Size() int { return len(*s) } func (s *MyStack) Empty() bool { return s.Size() == 0 } // ------------queue------------- type MyQueue struct { stackIn *MyStack stackOut *MyStack } func Constructor() MyQueue { return MyQueue { stackIn: \u0026amp;MyStack{}, stackOut: \u0026amp;MyStack{}, } } func (this *MyQueue) Push(x int) { this.stackIn.Push(x) } func (this *MyQueue) Pop() int { this.fillStackOut() return this.stackOut.Pop() } func (this *MyQueue) Peek() int { this.fillStackOut() return this.stackOut.Peek() } func (this *MyQueue) Empty() bool { return this.stackIn.Empty() \u0026amp;\u0026amp; this.stackOut.Empty() } // å¡«å……è¾“å‡ºæ ˆ func (this *MyQueue) fillStackOut() { if this.stackOut.Empty() { for !this.stackIn.Empty() { val := this.stackIn.Pop() this.stackOut.Push(val) } } } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 6.2 é˜Ÿåˆ—æ¨¡æ‹Ÿæ ˆ ä¸€ä¸ªé˜Ÿåˆ—å°±å¯ä»¥æ¨¡æ‹Ÿæ ˆ ï¼ˆå¦‚æœéè¦ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œå¦ä¸€ä¸ªé˜Ÿåˆ—ä»…èµ·åˆ°ä¿å­˜å…ƒç´ çš„ä½œç”¨ï¼‰\npushï¼š=å…¥æ ˆ popï¼šå°†é˜Ÿå¤´å…ƒç´ é‡æ–°åŠ å…¥é˜Ÿåˆ—å°¾ï¼Œå†å¼¹å‡º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type MyStack struct { queue []int } func Constructor() MyStack { return MyStack { queue: make([]int, 0), } } func (this *MyStack) Push(x int) { this.queue = append(this.queue, x) } func (this *MyStack) Pop() int { n := len(this.queue) - 1 for n != 0 { val := this.queue[0] this.queue = this.queue[1:] this.queue = append(this.queue, val) n -- } val := this.queue[0] this.queue = this.queue[1:] return val } func (this *MyStack) Top() int { val := this.Pop() this.queue = append(this.queue, val) // popå®Œè¦é‡æ–°æ·»åŠ å›å» return val } func (this *MyStack) Empty() bool { return len(this.queue) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 6.3 æ‹¬å·åŒ¹é… åœ¨å†™ä»£ç ä¹‹å‰è¦åˆ†æå¥½æœ‰å“ªå‡ ç§ä¸åŒ¹é…çš„æƒ…å†µ:\nç¬¬ä¸€ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå·¦æ–¹å‘çš„æ‹¬å·å¤šä½™äº† ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚\nç¬¬äºŒç§æƒ…å†µï¼Œæ‹¬å·æ²¡æœ‰å¤šä½™ï¼Œä½†æ˜¯ æ‹¬å·çš„ç±»å‹æ²¡æœ‰åŒ¹é…ä¸Šã€‚\nç¬¬ä¸‰ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå³æ–¹å‘çš„æ‹¬å·å¤šä½™äº†ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚\nè¿˜æœ‰ä¸€äº›æŠ€å·§ï¼Œåœ¨åŒ¹é…å·¦æ‹¬å·çš„æ—¶å€™ï¼Œå³æ‹¬å·å…ˆå…¥æ ˆï¼Œå°±åªéœ€è¦æ¯”è¾ƒå½“å‰å…ƒç´ å’Œæ ˆé¡¶ç›¸ä¸ç›¸ç­‰å°±å¯ä»¥äº†ï¼Œæ¯”å·¦æ‹¬å·å…ˆå…¥æ ˆä»£ç å®ç°è¦ç®€å•çš„å¤šäº†ï¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // O(n) O(n) func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } stk := make([]rune, 0) for i := 0; i \u0026lt; n; i ++ { if s[i] == \u0026#39;[\u0026#39; { stk = append(stk, \u0026#39;]\u0026#39;) } else if s[i] == \u0026#39;(\u0026#39; { stk = append(stk, \u0026#39;)\u0026#39;) } else if s[i] == \u0026#39;{\u0026#39; { stk = append(stk, \u0026#39;}\u0026#39;) } else if len(stk) == 0 || stk[len(stk) - 1] != rune(s[i]) { // å¦‚æœæ˜¯å³æ‹¬å·ï¼Œå¦‚æœæ ˆç©º æˆ– æ ˆé‡Œæ²¡æœ‰å¯ä»¥åŒ¹é…çš„å…ƒç´  return false } else { stk = stk[:len(stk) - 1] // pop } } // éå†å®Œäº†çœ‹æ—¶å€™æœ‰å‰©ä½™ return len(stk) == 0 } 6.4 åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹ ç»™å‡ºç”±å°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² Sï¼Œé‡å¤é¡¹åˆ é™¤æ“ä½œä¼šé€‰æ‹©ä¸¤ä¸ªç›¸é‚»ä¸”ç›¸åŒçš„å­—æ¯ï¼Œå¹¶åˆ é™¤å®ƒä»¬ã€‚\nåœ¨ S ä¸Šåå¤æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œç›´åˆ°æ— æ³•ç»§ç»­åˆ é™¤ã€‚\nåœ¨å®Œæˆæ‰€æœ‰é‡å¤é¡¹åˆ é™¤æ“ä½œåè¿”å›æœ€ç»ˆçš„å­—ç¬¦ä¸²ã€‚ç­”æ¡ˆä¿è¯å”¯ä¸€ã€‚\nç¤ºä¾‹ï¼š\nè¾“å…¥ï¼š\u0026ldquo;abbaca\u0026rdquo; è¾“å‡ºï¼š\u0026ldquo;ca\u0026rdquo; è§£é‡Šï¼šä¾‹å¦‚ï¼Œåœ¨ \u0026ldquo;abbaca\u0026rdquo; ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ é™¤ \u0026ldquo;bb\u0026rdquo; ç”±äºä¸¤å­—æ¯ç›¸é‚»ä¸”ç›¸åŒï¼Œè¿™æ˜¯æ­¤æ—¶å”¯ä¸€å¯ä»¥æ‰§è¡Œåˆ é™¤æ“ä½œçš„é‡å¤é¡¹ã€‚ä¹‹åæˆ‘ä»¬å¾—åˆ°å­—ç¬¦ä¸² \u0026ldquo;aaca\u0026rdquo;ï¼Œå…¶ä¸­åˆåªæœ‰ \u0026ldquo;aa\u0026rdquo; å¯ä»¥æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œæ‰€ä»¥æœ€åçš„å­—ç¬¦ä¸²ä¸º \u0026ldquo;ca\u0026rdquo;ã€‚ æç¤ºï¼š\n1 \u0026lt;= S.length \u0026lt;= 20000 S ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func removeDuplicates(s string) string { stack := make([]rune, 0) for _, val := range s { if len(stack) == 0 || val != stack[len(stack)-1] { stack = append(stack, val) } else { stack = stack[:len(stack)-1] } } var res []rune for len(stack) != 0 { // å°†æ ˆä¸­å…ƒç´ æ”¾åˆ°resultå­—ç¬¦ä¸²æ±‡æ€» res = append(res, stack[len(stack)-1]) stack = stack[:len(stack)-1] } // æ­¤æ—¶å­—ç¬¦ä¸²éœ€è¦åè½¬ä¸€ä¸‹ l, r := 0, len(res)-1 for l \u0026lt; r { res[l], res[r] = res[r], res[l] l++ r-- } return string(res) } è¿™é“é¢˜ç›®å°±åƒæ˜¯æˆ‘ä»¬ç©è¿‡çš„æ¸¸æˆå¯¹å¯¹ç¢°ï¼Œå¦‚æœç›¸åŒçš„å…ƒç´ æŒ¨åœ¨ä¸€èµ·å°±è¦æ¶ˆé™¤ã€‚\nå¯èƒ½æˆ‘ä»¬åœ¨ç©æ¸¸æˆçš„æ—¶å€™æ„Ÿè§‰ç†æ‰€å½“ç„¶åº”è¯¥æ¶ˆé™¤ï¼Œä½†ç¨‹åºåˆæ€ä¹ˆçŸ¥é“è¯¥å¦‚ä½•æ¶ˆé™¤å‘¢ï¼Œç‰¹åˆ«æ˜¯æ¶ˆé™¤ä¹‹ååˆæœ‰æ–°çš„å…ƒç´ å¯èƒ½æŒ¨åœ¨ä¸€èµ·ã€‚\næ­¤æ—¶æ¸¸æˆçš„åç«¯é€»è¾‘å°±å¯ä»¥ç”¨ä¸€ä¸ªæ ˆæ¥å®ç°ï¼ˆæˆ‘æ²¡æœ‰å®é™…è€ƒå¯Ÿå¯¹å¯¹ç¢°æˆ–è€…çˆ±æ¶ˆé™¤æ¸¸æˆçš„ä»£ç å®ç°ï¼Œä»…ä»åŸç†ä¸Šè¿›è¡Œæ¨æ–­ï¼‰ã€‚\næ¸¸æˆå¼€å‘å¯èƒ½ä½¿ç”¨æ ˆç»“æ„ï¼Œç¼–ç¨‹è¯­è¨€çš„ä¸€äº›åŠŸèƒ½å®ç°ä¹Ÿä¼šä½¿ç”¨æ ˆç»“æ„ï¼Œå®ç°å‡½æ•°é€’å½’è°ƒç”¨å°±éœ€è¦æ ˆï¼Œä½†ä¸æ˜¯æ¯ç§ç¼–ç¨‹è¯­è¨€éƒ½æ”¯æŒé€’å½’ï¼Œä¾‹å¦‚ï¼š\né€’å½’çš„å®ç°å°±æ˜¯ï¼šæ¯ä¸€æ¬¡é€’å½’è°ƒç”¨éƒ½ä¼šæŠŠå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€ç­‰å‹å…¥è°ƒç”¨æ ˆä¸­ï¼Œç„¶åé€’å½’è¿”å›çš„æ—¶å€™ï¼Œä»æ ˆé¡¶å¼¹å‡ºä¸Šä¸€æ¬¡é€’å½’çš„å„é¡¹å‚æ•°ï¼Œæ‰€ä»¥è¿™å°±æ˜¯é€’å½’ä¸ºä»€ä¹ˆå¯ä»¥è¿”å›ä¸Šä¸€å±‚ä½ç½®çš„åŸå› ã€‚\nç›¸ä¿¡å¤§å®¶åº”è¯¥é‡åˆ°è¿‡ä¸€ç§é”™è¯¯å°±æ˜¯æ ˆæº¢å‡ºï¼Œç³»ç»Ÿè¾“å‡ºçš„å¼‚å¸¸æ˜¯Segmentation faultï¼ˆå½“ç„¶ä¸æ˜¯æ‰€æœ‰çš„Segmentation fault éƒ½æ˜¯æ ˆæº¢å‡ºå¯¼è‡´çš„ï¼‰ ï¼Œå¦‚æœä½ ä½¿ç”¨äº†é€’å½’ï¼Œå°±è¦æƒ³ä¸€æƒ³æ˜¯ä¸æ˜¯æ— é™é€’å½’äº†ï¼Œé‚£ä¹ˆç³»ç»Ÿè°ƒç”¨æ ˆå°±ä¼šæº¢å‡ºã€‚\nè€Œä¸”åœ¨ä¼ä¸šé¡¹ç›®å¼€å‘ä¸­ï¼Œå°½é‡ä¸è¦ä½¿ç”¨é€’å½’ï¼åœ¨é¡¹ç›®æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œç”±äºå‚æ•°å¤šï¼Œå…¨å±€å˜é‡ç­‰ç­‰ï¼Œä½¿ç”¨é€’å½’å¾ˆå®¹æ˜“åˆ¤æ–­ä¸å……åˆ†returnçš„æ¡ä»¶ï¼Œéå¸¸å®¹æ˜“æ— é™é€’å½’ï¼ˆæˆ–è€…é€’å½’å±‚çº§è¿‡æ·±ï¼‰ï¼Œé€ æˆæ ˆæº¢å‡ºé”™è¯¯ï¼ˆè¿™ç§é—®é¢˜è¿˜ä¸å¥½æ’æŸ¥ï¼ï¼‰\n6.5 é€†æ³¢å…°å¼æ±‚å€¼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { // is operation c1, c2 := stack[len(stack) - 2], stack[len(stack) - 1] stack = stack[:len(stack) - 2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, c1 + c2) case \u0026#34;-\u0026#34;: stack = append(stack, c1 - c2) case \u0026#34;*\u0026#34;: stack = append(stack, c1 * c2) case \u0026#34;/\u0026#34;: stack = append(stack, c1 / c2) } } } return stack[0] } 6.6 æ»‘åŠ¨çª—å£æœ€å¤§å€¼ ï¼ˆç»å…¸ï¼šå•è°ƒé˜Ÿåˆ—ï¼‰ ç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º k çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ k ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚\nè¿”å›æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ã€‚\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 1 \u0026lt;= k \u0026lt;= nums.length è¿›é˜¶ï¼šä½ èƒ½åœ¨çº¿æ€§æ—¶é—´å¤æ‚åº¦å†…è§£å†³æ­¤é¢˜å—ï¼Ÿ\nç”¨ä¸€ä¸ªé˜Ÿåˆ—ç»´æŠ¤å½“å‰çª—å£ï¼Œéšç€çª—å£ç§»åŠ¨ï¼Œé˜Ÿåˆ—ä¸€è¿›ä¸€å‡ºï¼Œå¸Œæœ›é˜Ÿå¤´æ˜¯æœ€å¤§å…ƒç´ ã€‚\nè¦ä¿è¯é˜Ÿåˆ—å†…å…ƒç´ å•è°ƒé€’å‡ï¼ˆå¢ï¼‰ â€“ã€‹ å•è°ƒé˜Ÿåˆ—\nä½†ä¸éœ€è¦ç»´æŠ¤çª—å£é‡Œçš„æ‰€æœ‰å…ƒç´ ï¼Œåªéœ€è¦ç»´æŠ¤å¯èƒ½æˆä¸ºæœ€å¤§å€¼çš„å…ƒç´ ã€‚å¦‚æœä¸‹ä¸€ä¸ªå…ƒç´ æ¯”ä¸Šä¸€ä¸ªå¤§ï¼Œé‚£ä¹ˆä¸Šä¸€ä¸ªå‡ºé˜Ÿï¼Œä¿å­˜ä¸‹ä¸€ä¸ªï¼Œç›´åˆ°é‡åˆ°æ¯”ä¸Šä¸€ä¸ªå°çš„ï¼Œä¸Šä¸€ä¸ªå…ƒç´ ä¸åŠ¨ï¼Œç»§ç»­ä¿ç•™å°äºå½“å‰å€¼çš„æœ€å¤§å€¼ã€‚\nè®¾è®¡å•è°ƒé˜Ÿåˆ—çš„æ—¶å€™ï¼Œpopï¼Œå’Œpushæ“ä½œè¦ä¿æŒå¦‚ä¸‹è§„åˆ™ï¼š\npop(value)ï¼šå¦‚æœçª—å£ç§»é™¤çš„å…ƒç´ valueç­‰äºå•è°ƒé˜Ÿåˆ—çš„å‡ºå£å…ƒç´ ï¼Œé‚£ä¹ˆé˜Ÿåˆ—å¼¹å‡ºå…ƒç´ ï¼Œå¦åˆ™ä¸ç”¨ä»»ä½•æ“ä½œ push(value)ï¼šå¦‚æœpushçš„å…ƒç´ valueå¤§äºå…¥å£å…ƒç´ çš„æ•°å€¼ï¼Œé‚£ä¹ˆå°±å°†é˜Ÿåˆ—å…¥å£çš„å…ƒç´ å¼¹å‡ºï¼Œç›´åˆ°pushå…ƒç´ çš„æ•°å€¼å°äºç­‰äºé˜Ÿåˆ—å…¥å£å…ƒç´ çš„æ•°å€¼ä¸ºæ­¢ ä¿æŒå¦‚ä¸Šè§„åˆ™ï¼Œæ¯æ¬¡çª—å£ç§»åŠ¨çš„æ—¶å€™ï¼Œåªè¦é—®que.front()å°±å¯ä»¥è¿”å›å½“å‰çª—å£çš„æœ€å¤§å€¼ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // O(n) O(k) // å°è£…å•è°ƒé˜Ÿåˆ—çš„æ–¹å¼è§£é¢˜ type MyQueue struct { queue []int } func NewMyQueue() *MyQueue { return \u0026amp;MyQueue{ queue: make([]int, 0), } } func (m *MyQueue) Front() int { return m.queue[0] } func (m *MyQueue) Back() int { return m.queue[len(m.queue)-1] } func (m *MyQueue) Empty() bool { return len(m.queue) == 0 } func (m *MyQueue) Push(val int) { for !m.Empty() \u0026amp;\u0026amp; val \u0026gt; m.Back() { m.queue = m.queue[:len(m.queue)-1] } m.queue = append(m.queue, val) } func (m *MyQueue) Pop(val int) { if !m.Empty() \u0026amp;\u0026amp; val == m.Front() { m.queue = m.queue[1:] } } func maxSlidingWindow(nums []int, k int) []int { queue := NewMyQueue() length := len(nums) res := make([]int, 0) // å…ˆå°†å‰kä¸ªå…ƒç´ æ”¾å…¥é˜Ÿåˆ— for i := 0; i \u0026lt; k; i++ { queue.Push(nums[i]) } // è®°å½•å‰kä¸ªå…ƒç´ çš„æœ€å¤§å€¼ res = append(res, queue.Front()) for i := k; i \u0026lt; length; i++ { // æ»‘åŠ¨çª—å£ç§»é™¤æœ€å‰é¢çš„å…ƒç´  queue.Pop(nums[i-k]) // æ»‘åŠ¨çª—å£æ·»åŠ æœ€åé¢çš„å…ƒç´  queue.Push(nums[i]) // è®°å½•æœ€å¤§å€¼ res = append(res, queue.Front()) } return res } 6.7 å‰kä¸ªé«˜é¢‘å…ƒç´ ï¼ˆç»å…¸ï¼šä¼˜å…ˆé˜Ÿåˆ—/å †ï¼‰ ç»Ÿè®¡å‡ºç°å…ƒç´ çš„é¢‘ç‡ map:[key, value] å¯¹é¢‘ç‡æ’åº priority queue / å–å‰kä¸ªé¢‘ç‡çš„å…ƒç´  ä»€ä¹ˆæ˜¯ä¼˜å…ˆçº§é˜Ÿåˆ—å‘¢ï¼Ÿ\nå…¶å®å°±æ˜¯ä¸€ä¸ªæŠ«ç€é˜Ÿåˆ—å¤–è¡£çš„å †ï¼Œå› ä¸ºä¼˜å…ˆçº§é˜Ÿåˆ—å¯¹å¤–æ¥å£åªæ˜¯ä»é˜Ÿå¤´å–å…ƒç´ ï¼Œä»é˜Ÿå°¾æ·»åŠ å…ƒç´ ï¼Œå†æ— å…¶ä»–å–å…ƒç´ çš„æ–¹å¼ï¼Œçœ‹èµ·æ¥å°±æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ã€‚\nè€Œä¸”ä¼˜å…ˆçº§é˜Ÿåˆ—å†…éƒ¨å…ƒç´ æ˜¯è‡ªåŠ¨ä¾ç…§å…ƒç´ çš„æƒå€¼æ’åˆ—ã€‚é‚£ä¹ˆå®ƒæ˜¯å¦‚ä½•æœ‰åºæ’åˆ—çš„å‘¢ï¼Ÿ\nç¼ºçœæƒ…å†µä¸‹priority_queueåˆ©ç”¨max-heapï¼ˆå¤§é¡¶å †ï¼‰å®Œæˆå¯¹å…ƒç´ çš„æ’åºï¼Œè¿™ä¸ªå¤§é¡¶å †æ˜¯ä»¥vectorä¸ºè¡¨ç°å½¢å¼çš„complete binary treeï¼ˆå®Œå…¨äºŒå‰æ ‘ï¼‰ã€‚\nä¸ºä»€ä¹ˆä¸ç”¨å¿«æ’å‘¢ï¼Œ ä½¿ç”¨å¿«æ’è¦å°†mapè½¬æ¢ä¸ºvectorçš„ç»“æ„ï¼Œç„¶åå¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œæ’åºï¼Œ è€Œè¿™ç§åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å…¶å®åªéœ€è¦ç»´æŠ¤kä¸ªæœ‰åºçš„åºåˆ—å°±å¯ä»¥äº†ï¼Œæ‰€ä»¥ä½¿ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—æ˜¯æœ€ä¼˜çš„ã€‚\né‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå®šä¹‰ä¸€ä¸ªå¤§å°ä¸ºkçš„å¤§é¡¶å †ï¼Œåœ¨æ¯æ¬¡ç§»åŠ¨æ›´æ–°å¤§é¡¶å †çš„æ—¶å€™ï¼Œæ¯æ¬¡å¼¹å‡ºéƒ½æŠŠæœ€å¤§çš„å…ƒç´ å¼¹å‡ºå»äº†ï¼Œé‚£ä¹ˆæ€ä¹ˆä¿ç•™ä¸‹æ¥å‰Kä¸ªé«˜é¢‘å…ƒç´ å‘¢ã€‚\nè€Œä¸”ä½¿ç”¨å¤§é¡¶å †å°±è¦æŠŠæ‰€æœ‰å…ƒç´ éƒ½è¿›è¡Œæ’åºï¼Œé‚£èƒ½ä¸èƒ½åªæ’åºkä¸ªå…ƒç´ å‘¢ï¼Ÿ\næ‰€ä»¥æˆ‘ä»¬è¦ç”¨å°é¡¶å †ï¼Œå› ä¸ºè¦ç»Ÿè®¡æœ€å¤§å‰kä¸ªå…ƒç´ ï¼Œåªæœ‰å°é¡¶å †æ¯æ¬¡å°†æœ€å°çš„å…ƒç´ å¼¹å‡ºï¼Œæœ€åå°é¡¶å †é‡Œç§¯ç´¯çš„æ‰æ˜¯å‰kä¸ªæœ€å¤§å…ƒç´ \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // å¿«æ’ func topKFrequent(nums []int, k int) []int { res := []int{} cnt := make(map[int]int) for _, val := range nums { cnt[val] ++ } for k, _ := range cnt { res = append(res, k) } sort.Slice(res, func(a, b int) bool { return cnt[res[a]] \u0026gt; cnt[res[b]] }) return res[:k] // qian k } // å°é¡¶å † func topKFrequent(nums []int, k int) []int { map_num:=map[int]int{} //è®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•° for _,item:=range nums{ map_num[item]++ } h:=\u0026amp;IHeap{} heap.Init(h) //æ‰€æœ‰å…ƒç´ å…¥å †ï¼Œå †çš„é•¿åº¦ä¸ºk for key,value:=range map_num{ heap.Push(h,[2]int{key,value}) if h.Len()\u0026gt;k{ heap.Pop(h) } } res:=make([]int,k) //æŒ‰é¡ºåºè¿”å›å †ä¸­çš„å…ƒç´  for i:=0;i\u0026lt;k;i++{ res[k-i-1]=heap.Pop(h).([2]int)[0] } return res } //æ„å»ºå°é¡¶å † type IHeap [][2]int func (h IHeap) Len()int { return len(h) } func (h IHeap) Less (i,j int) bool { return h[i][1]\u0026lt;h[j][1] } func (h IHeap) Swap(i,j int) { h[i],h[j]=h[j],h[i] } func (h *IHeap) Push(x interface{}){ *h=append(*h,x.([2]int)) } func (h *IHeap) Pop() interface{}{ old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x } Go: æ·±å…¥ç†è§£å †å®ç°åŠåº”ç”¨-è…¾è®¯äº‘å¼€å‘è€…ç¤¾åŒº-è…¾è®¯äº‘ (tencent.com)\nå †æ˜¯ä¸€ç§ç‰¹æ®Šçš„å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€æœ‰çš„èŠ‚ç‚¹éƒ½å¤§äºç­‰äºï¼ˆæœ€å¤§å †ï¼‰æˆ–å°äºç­‰äºï¼ˆæœ€å°å †ï¼‰å…¶å­èŠ‚ç‚¹ã€‚Goè¯­è¨€ä¸­çš„å †é€šè¿‡container/heapåŒ…å®ç°ï¼Œè¯¥åŒ…æä¾›äº†å¯¹æ•°æ®ç»“æ„è¿›è¡Œå †æ“ä½œçš„æ¥å£å’Œæ–¹æ³•ã€‚\näºŒå‰æ ‘ æ»¡äºŒå‰æ ‘ å®Œå…¨äºŒå‰æ ‘ äºŒå‰æœç´¢æ ‘ å¹³è¡¡äºŒå‰æœç´¢æ ‘ AVL äºŒå‰æ ‘å­˜å‚¨ï¼š\né“¾å¼ é¡ºåºï¼šå¦‚æœçˆ¶èŠ‚ç‚¹çš„æ•°ç»„ä¸‹æ ‡æ˜¯ iï¼Œé‚£ä¹ˆå®ƒçš„å·¦å­©å­å°±æ˜¯ i * 2 + 1ï¼Œå³å­©å­å°±æ˜¯ i * 2 + 2ã€‚ äºŒå‰æ ‘ä¸»è¦æœ‰ä¸¤ç§éå†æ–¹å¼ï¼š\næ·±åº¦ä¼˜å…ˆéå†ï¼šå…ˆå¾€æ·±èµ°ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹å†å¾€å›èµ°ã€‚ å‰åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ ä¸­åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ ååºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰ å¹¿åº¦ä¼˜å…ˆéå†ï¼šä¸€å±‚ä¸€å±‚çš„å»éå†ã€‚ å±‚æ¬¡éå†ï¼ˆè¿­ä»£æ³•ï¼‰ ä¹‹å‰æˆ‘ä»¬è®²æ ˆä¸é˜Ÿåˆ—çš„æ—¶å€™ï¼Œå°±è¯´è¿‡æ ˆå…¶å®å°±æ˜¯é€’å½’çš„ä¸€ç§å®ç°ç»“æ„ï¼Œä¹Ÿå°±è¯´å‰ä¸­ååºéå†çš„é€»è¾‘å…¶å®éƒ½æ˜¯å¯ä»¥å€ŸåŠ©æ ˆä½¿ç”¨é€’å½’çš„æ–¹å¼æ¥å®ç°çš„ã€‚\nè€Œå¹¿åº¦ä¼˜å…ˆéå†çš„å®ç°ä¸€èˆ¬ä½¿ç”¨é˜Ÿåˆ—æ¥å®ç°ï¼Œè¿™ä¹Ÿæ˜¯é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„ç‰¹ç‚¹æ‰€å†³å®šçš„ï¼Œå› ä¸ºéœ€è¦å…ˆè¿›å…ˆå‡ºçš„ç»“æ„ï¼Œæ‰èƒ½ä¸€å±‚ä¸€å±‚çš„æ¥éå†äºŒå‰æ ‘ã€‚\näºŒå‰æ ‘å®šä¹‰\n1 2 3 4 5 6 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} } 1 2 3 4 5 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 7.1 é€’å½’éå† 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { // æ³¨æ„å…¥å‚ if node == nil { // æ³¨æ„ç»ˆæ­¢æ¡ä»¶ return } // å‰åºéå† res = append(res, node.Val) traversal(node.Left) traversal(node.Right) // ä¸­åºéå† // ntraversal(node.Left) // res = append(res, node.Val) // traversal(node.Right) // ååºéå† // traversal(node.Left) // traversal(node.Right) // res = append(res, node.Val) } traversal(root) return } 7.2 äºŒå‰æ ‘é€’å½’ ç¡®å®šé€’å½’å‡½æ•°å…¥å‚å’Œè¿”å›å€¼ ç¡®å®šé€’å½’é€€å‡ºæ¡ä»¶ ç¡®å®šå•æ¬¡é€’å½’å†…å®¹ é€’å½’çš„å®ç°å°±æ˜¯ï¼šæ¯ä¸€æ¬¡é€’å½’è°ƒç”¨éƒ½ä¼šæŠŠå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€ç­‰å‹å…¥è°ƒç”¨æ ˆä¸­ï¼Œç„¶åé€’å½’è¿”å›çš„æ—¶å€™ï¼Œä»æ ˆé¡¶å¼¹å‡ºä¸Šä¸€æ¬¡é€’å½’çš„å„é¡¹å‚æ•°ï¼Œæ‰€ä»¥è¿™å°±æ˜¯é€’å½’ä¸ºä»€ä¹ˆå¯ä»¥è¿”å›ä¸Šä¸€å±‚ä½ç½®çš„åŸå› ã€‚\n7.3 äºŒå‰æ ‘è¿­ä»£ å‰ååºç”¨æ ˆï¼Œååºç”¨æŒ‡é’ˆ\nstk.Len()\nstk.PushBack(ndoe)\nstk.Back() è¿”å›æ ˆä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå³æ ˆé¡¶å…ƒç´ ã€‚\nstk.Remove(stk.Back()) ä»æ ˆä¸­ç§»é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ã€‚è¿™é‡Œç§»é™¤çš„å…ƒç´ æ˜¯æ ˆé¡¶å…ƒç´ ã€‚\n(*TreeNode) æ˜¯ç±»å‹æ–­è¨€ï¼Œå°†ç§»é™¤çš„å…ƒç´ è½¬æ¢ä¸º *TreeNode ç±»å‹ã€‚\nç»Ÿä¸€è¿­ä»£ å•è°ƒæ ˆï¼ˆå®Œï¼‰ 739.æ¯æ—¥æ¸©åº¦ è¯·æ ¹æ®æ¯æ—¥ æ°”æ¸© åˆ—è¡¨ï¼Œé‡æ–°ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ã€‚å¯¹åº”ä½ç½®çš„è¾“å‡ºä¸ºï¼šè¦æƒ³è§‚æµ‹åˆ°æ›´é«˜çš„æ°”æ¸©ï¼Œè‡³å°‘éœ€è¦ç­‰å¾…çš„å¤©æ•°ã€‚å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚\nä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªåˆ—è¡¨ temperatures = [73, 74, 75, 71, 69, 72, 76, 73]ï¼Œä½ çš„è¾“å‡ºåº”è¯¥æ˜¯ [1, 1, 4, 2, 1, 1, 0, 0]ã€‚\næç¤ºï¼šæ°”æ¸© åˆ—è¡¨é•¿åº¦çš„èŒƒå›´æ˜¯ [1, 30000]ã€‚æ¯ä¸ªæ°”æ¸©çš„å€¼çš„å‡ä¸ºåæ°åº¦ï¼Œéƒ½æ˜¯åœ¨ [30, 100] èŒƒå›´å†…çš„æ•´æ•°ã€‚\næ€è·¯ï¼šæ‰¾åˆ°å³è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§çš„æ•°\nåœ¨éå†è¿‡ç¨‹ä¸­ç”¨æ ˆè®°å½•å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å¤§çš„å…ƒç´ ï¼ŒO(n). æ ˆä¸­åªå­˜å¯¹åº”å…ƒç´ ä¸‹æ ‡å³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // æš´åŠ› func dailyTemperatures(t []int) []int { var res []int for i := 0; i \u0026lt; len(t) - 1; i ++ { j := i + 1 for ; j \u0026lt; len(t); j ++ { if t[j] \u0026gt; t[i] { res = append(res, j - i) break // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°±é€€å‡º } } if j == len(t) { // å¦‚æœæ‰¾å®Œäº†éƒ½æ²¡æœ‰ res = append(res, 0) } } return append(res, 0) // æœ€åä¸€æ—¥è‚¯å®šæ˜¯0 } // å•è°ƒæ ˆ(å¢) func dailyTemperatures(t []int) []int { res := make([]int, len(t)) stk := []int{0} // åˆå§‹åŒ–æ ˆé¡¶å…ƒç´ ä¸ºç¬¬ä¸€ä¸ªä¸‹æ ‡ç´¢å¼•0 for i := 1; i \u0026lt; len(t); i ++ { top := stk[len(stk) - 1] // å½“å‰æ ˆé¡¶ if t[top] \u0026gt;= t[i] { stk = append(stk, i) } else { for len(stk) != 0 \u0026amp;\u0026amp; t[i] \u0026gt; t[top] { res[top] = i - top stk = stl[:len(stk)-1] // pop if len(stk) != 0 { top = stk[len(stk) - 1] // æ›´æ–°æ ˆé¡¶ } } stk = append(stk, i) } } return res } // å•è°ƒæ ˆ(é€’å‡) func dailyTemperatures(t []int) []int { res: := make([]int, len(t)) stk := []int{} for i, v := range t { // æ ˆä¸ç©ºä¸”å½“å‰éå†å…ƒç´  v ç ´åäº†æ ˆçš„å•è°ƒæ€§ for len(stk) != 0 \u0026amp;\u0026amp; v \u0026gt; t[stk[len(stk)-1]] { // å¤§äºå½“å‰æ ˆé¡¶ï¼Œå°±popï¼Œæ›´æ–° top := stk[len(stk)-1] stk = stk[:len(stk)-1] res[top] = i - top } stk = append(stk, i) } return res } 496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I ç»™ä½ ä¸¤ä¸ª æ²¡æœ‰é‡å¤å…ƒç´  çš„æ•°ç»„ nums1 å’Œ nums2 ï¼Œå…¶ä¸­nums1 æ˜¯ nums2 çš„å­é›†ã€‚\nè¯·ä½ æ‰¾å‡º nums1 ä¸­æ¯ä¸ªå…ƒç´ åœ¨ nums2 ä¸­çš„ä¸‹ä¸€ä¸ªæ¯”å…¶å¤§çš„å€¼ã€‚\nnums1 ä¸­æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ æ˜¯æŒ‡ x åœ¨ nums2 ä¸­å¯¹åº”ä½ç½®çš„å³è¾¹çš„ç¬¬ä¸€ä¸ªæ¯” x å¤§çš„å…ƒç´ ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œå¯¹åº”ä½ç½®è¾“å‡º -1 ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: nums1 = [4,1,2], nums2 = [1,3,4,2]. è¾“å‡º: [-1,3,-1]\næ²¡æœ‰é‡å¤å…ƒç´ ï¼Œå¯ä»¥ç”¨mapæ¥åšæ˜ å°„ï¼Œå¯ä»¥æ ¹æ®æ•°å€¼å¿«é€Ÿæ‰¾ä¸‹æ ‡ï¼Œå¹¶ä¸”å¯ä»¥åˆ¤æ–­nums2[i]æ˜¯å¦åœ¨nums1ä¸­å‡ºç°è¿‡ã€‚\nresæ•°ç»„é»˜è®¤å€¼ä¸º-1ï¼ˆæ‰¾ä¸åˆ°ï¼‰ã€‚\néå†å“ªä¸ªæ•°ç»„å‘¢ï¼Ÿè¦åœ¨nums2é‡Œæ‰¾æ¯”1é‡Œå¯¹åº”ä½ç½®å…ƒç´ å¤§çš„ï¼Œæ‰€ä»¥éå†nums2\næƒ…å†µä¸€ï¼šå½“å‰éå†çš„å…ƒç´ T[i]å°äºæ ˆé¡¶å…ƒç´ T[st.top()]çš„æƒ…å†µï¼šæ­¤æ—¶æ»¡è¶³é€’å¢æ ˆï¼ˆæ ˆå¤´åˆ°æ ˆåº•çš„é¡ºåºï¼‰ï¼Œæ‰€ä»¥ç›´æ¥å…¥æ ˆã€‚\næƒ…å†µäºŒï¼šå½“å‰éå†çš„å…ƒç´ T[i]ç­‰äºæ ˆé¡¶å…ƒç´ T[st.top()]çš„æƒ…å†µï¼šå¦‚æœç›¸ç­‰çš„è¯ï¼Œä¾ç„¶ç›´æ¥å…¥æ ˆï¼Œå› ä¸ºæˆ‘ä»¬è¦æ±‚çš„æ˜¯å³è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯å¤§äºç­‰äº\næƒ…å†µä¸‰ï¼šå½“å‰éå†çš„å…ƒç´ T[i]å¤§äºæ ˆé¡¶å…ƒç´ T[st.top()]çš„æƒ…å†µï¼šæ­¤æ—¶å¦‚æœå…¥æ ˆå°±ä¸æ»¡è¶³é€’å¢æ ˆäº†ï¼Œè¿™ä¹Ÿæ˜¯æ‰¾åˆ°å³è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§çš„å…ƒç´ çš„æ—¶å€™ã€‚\nåˆ¤æ–­æ ˆé¡¶å…ƒç´ æ˜¯å¦åœ¨nums1é‡Œå‡ºç°è¿‡ï¼Œï¼ˆæ³¨æ„æ ˆé‡Œçš„å…ƒç´ æ˜¯nums2çš„å…ƒç´ ï¼‰ï¼Œå¦‚æœå‡ºç°è¿‡ï¼Œå¼€å§‹è®°å½•ç»“æœã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func nextGreaterElement(nums1 []int, nums2 []int) []int { res := make([]int, len(nums1)) for i := range res { res[i] = -1 } mp := map[int]int{} for i, v := range nums1 { mp[v] = i } stack := []int{} stack = append(stack, 0) // nums2ä¸‹æ ‡ for i := 1; i \u0026lt; len(nums2); i ++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums2[i] \u0026gt; nums2[stack[len(stack)-1]] { top := stack[len(stack)-1] if _, ok := mp[nums2[top]]; ok { // çœ‹mapé‡Œæ˜¯å¦å­˜åœ¨è¿™ä¸ªå…ƒç´  index := mp[nums2[top]] // æ ¹æ®mapæ‰¾åˆ°nums2[top] åœ¨ nums1ä¸­çš„ä¸‹æ ‡ res[index] = nums2[i] } stack = stack[:len(stack)-1] } stack = append(stack, i) // \u0026lt;= } return res } 503.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II ç»™å®šä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¾“å‡ºæ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ã€‚æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ æ˜¯æŒ‰æ•°ç»„éå†é¡ºåºï¼Œè¿™ä¸ªæ•°å­—ä¹‹åçš„ç¬¬ä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„æ•°ï¼Œè¿™æ„å‘³ç€ä½ åº”è¯¥å¾ªç¯åœ°æœç´¢å®ƒçš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º -1ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: [1,2,1] è¾“å‡º: [2,-1,2] è§£é‡Š: ç¬¬ä¸€ä¸ª 1 çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯ 2ï¼›æ•°å­— 2 æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ï¼›ç¬¬äºŒä¸ª 1 çš„ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°éœ€è¦å¾ªç¯æœç´¢ï¼Œç»“æœä¹Ÿæ˜¯ 2ã€‚ æç¤º:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func nextGreaterElements(nums []int) []int { n := len(nums) res := make([]int, n) for i := range nums { res[i] = -1 } // å•è°ƒé€’å‡ï¼Œå­˜å‚¨æ•°ç»„ä¸‹æ ‡ stk := make([]int, 0) for i := 0; i \u0026lt; n * 2; i ++ { for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[stk[len(stk)-1]] { index := stk[len(stk)-1] stk = stk[:len(stk)-1] res[index] = nums[i % n] } stk = append(stk, i % n) } return res } 42. æ¥é›¨æ°´ï¼ˆç»å…¸å¸¸é—®ï¼‰ ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚\nè¾“å…¥ï¼šheight = [0,1,0,2,1,0,1,3,2,1,2,1] è¾“å‡ºï¼š6 è§£é‡Šï¼šä¸Šé¢æ˜¯ç”±æ•°ç»„ [0,1,0,2,1,0,1,3,2,1,2,1] è¡¨ç¤ºçš„é«˜åº¦å›¾ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¥ 6 ä¸ªå•ä½çš„é›¨æ°´ï¼ˆè“è‰²éƒ¨åˆ†è¡¨ç¤ºé›¨æ°´ï¼‰ã€‚ æš´åŠ›åŒæŒ‡é’ˆ æŒ‰åˆ—è®¡ç®—ï¼šå®½åº¦ä¸€å®šæ˜¯1ï¼Œå†æ±‚æ¯ä¸€åˆ—çš„é›¨æ°´é«˜åº¦ã€‚æ¯ä¸€åˆ—çš„é›¨æ°´æœ‰å¤šé«˜å–å†³äºä¸¤ä¾§æŸ±å­ä¸­æœ€çŸ­çš„ä¸€ä¸ªã€‚\næ³¨æ„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæŸ±å­ä¸æ¥é›¨æ°´ã€‚ åœ¨forä¸­æ±‚å·¦å³ä¸¤è¾¹æœ€é«˜çš„æŸ±å­ã€‚ æœ€åè®¡ç®—è¯¥åˆ—çš„é›¨æ°´é«˜åº¦: å½“å‰åˆ—é›¨æ°´é¢ç§¯ï¼šmin(å·¦è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦ï¼Œè®°å½•å³è¾¹æŸ±å­çš„æœ€é«˜é«˜åº¦) - å½“å‰æŸ±å­é«˜åº¦ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func trap(height []int) (sum int) { n := len(height) for i, h := range height { if i == 0 || i == n - 1 { continue } ml, mr := h, h for r := i + 1; r \u0026lt; n; r ++ { if height[r] \u0026gt; mr { mr = height[r] } } for l := i - 1; l \u0026gt;= 0; l -- { if height[l] \u0026gt; ml { ml = height[l] } } if min(ml, mr) - h \u0026gt; 0 { sum += min(ml, mr) - h } } return } // æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1) åŒæŒ‡é’ˆä¼˜åŒ– ä¸ºäº†å¾—åˆ°ä¸¤è¾¹çš„æœ€é«˜é«˜åº¦ï¼Œä½¿ç”¨äº†åŒæŒ‡é’ˆæ¥éå†ï¼Œæ¯åˆ°ä¸€ä¸ªæŸ±å­éƒ½å‘ä¸¤è¾¹éå†ä¸€éï¼Œè¿™å…¶å®æ˜¯æœ‰é‡å¤è®¡ç®—çš„ã€‚æˆ‘ä»¬æŠŠæ¯ä¸€ä¸ªä½ç½®çš„å·¦è¾¹æœ€é«˜é«˜åº¦è®°å½•åœ¨ä¸€ä¸ªæ•°ç»„ä¸Šï¼ˆmaxLeftï¼‰ï¼Œå³è¾¹æœ€é«˜é«˜åº¦è®°å½•åœ¨ä¸€ä¸ªæ•°ç»„ä¸Šï¼ˆmaxRightï¼‰ï¼Œè¿™æ ·å°±é¿å…äº†é‡å¤è®¡ç®—ã€‚\nå½“å‰ä½ç½®ï¼Œå·¦è¾¹çš„æœ€é«˜é«˜åº¦æ˜¯å‰ä¸€ä¸ªä½ç½®çš„å·¦è¾¹æœ€é«˜é«˜åº¦å’Œæœ¬é«˜åº¦çš„æœ€å¤§å€¼ã€‚\nå³ä»å·¦å‘å³éå†ï¼šmaxLeft[i] = max(height[i], maxLeft[i - 1]);\nä»å³å‘å·¦éå†ï¼šmaxRight[i] = max(height[i], maxRight[i + 1]);\nå•è°ƒæ ˆ å•è°ƒæ ˆå°±æ˜¯ä¿æŒæ ˆå†…å…ƒç´ æœ‰åºã€‚æˆ‘ä»¬æ­£éœ€è¦å¯»æ‰¾ä¸€ä¸ªå…ƒç´ ï¼Œå³è¾¹æœ€å¤§å…ƒç´ ä»¥åŠå·¦è¾¹æœ€å¤§å…ƒç´ ï¼Œæ¥è®¡ç®—é›¨æ°´é¢ç§¯ã€‚\nã€å•è°ƒæ ˆæ˜¯æŒ‰è¡Œè®¡ç®—ã€‘\nä»æ ˆå¤´ï¼ˆå…ƒç´ ä»æ ˆå¤´å¼¹å‡ºï¼‰åˆ°æ ˆåº•çš„é¡ºåºåº”è¯¥æ˜¯ä»å°åˆ°å¤§çš„é¡ºåºã€‚å› ä¸ºä¸€æ—¦å‘ç°æ·»åŠ çš„æŸ±å­é«˜åº¦å¤§äºæ ˆå¤´å…ƒç´ äº†ï¼Œæ­¤æ—¶å°±å‡ºç°å‡¹æ§½äº†ï¼Œæ ˆå¤´å…ƒç´ å°±æ˜¯å‡¹æ§½åº•éƒ¨çš„æŸ±å­ï¼Œæ ˆå¤´ç¬¬äºŒä¸ªå…ƒç´ å°±æ˜¯å‡¹æ§½å·¦è¾¹çš„æŸ±å­ï¼Œè€Œæ·»åŠ çš„å…ƒç´ å°±æ˜¯å‡¹æ§½å³è¾¹çš„æŸ±å­ã€‚\né‡åˆ°ç›¸åŒçš„å…ƒç´ ï¼Œæ›´æ–°æ ˆå†…ä¸‹æ ‡ï¼Œå°±æ˜¯å°†æ ˆé‡Œå…ƒç´ ï¼ˆæ—§ä¸‹æ ‡ï¼‰å¼¹å‡ºï¼Œå°†æ–°å…ƒç´ ï¼ˆæ–°ä¸‹æ ‡ï¼‰åŠ å…¥æ ˆä¸­ã€‚å› ä¸ºé‡åˆ°ç›¸ç›¸åŒé«˜åº¦çš„æŸ±å­ï¼Œéœ€è¦ä½¿ç”¨æœ€å³è¾¹çš„æŸ±å­æ¥è®¡ç®—å®½åº¦ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func trap(height []int) (sum int) { if len(height) \u0026lt;= 2 { return 0 } stack := []int{} stack = append(stack, 0) // ç¬¬ä¸€ä¸ªæŸ±å­ for i := range height { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; height[i] \u0026gt; height[stack[len(stack)-1]] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u0026gt; 0 { h := min(height[i], height[stack[len(stack)-1]]) - height[mid] w := i - stack[len(stack)-1] - 1 sum += h * w } } stack = append(stack, i) } return } 84. æŸ±çŠ¶å›¾ä¸­çš„æœ€å¤§çŸ©å½¢ ç»™å®š n ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨æ¥è¡¨ç¤ºæŸ±çŠ¶å›¾ä¸­å„ä¸ªæŸ±å­çš„é«˜åº¦ã€‚æ¯ä¸ªæŸ±å­å½¼æ­¤ç›¸é‚»ï¼Œä¸”å®½åº¦ä¸º 1 ã€‚\næ±‚åœ¨è¯¥æŸ±çŠ¶å›¾ä¸­ï¼Œèƒ½å¤Ÿå‹¾å‹’å‡ºæ¥çš„çŸ©å½¢çš„æœ€å¤§é¢ç§¯ã€‚\n1 2 3 è¾“å…¥ï¼šheights = [2,1,5,6,2,3] è¾“å‡ºï¼š10 è§£é‡Šï¼šæœ€å¤§çš„çŸ©å½¢ä¸ºå›¾ä¸­çº¢è‰²åŒºåŸŸï¼Œé¢ç§¯ä¸º 10 ã€ä¸æ¥é›¨æ°´çš„åŒºåˆ«ã€‘è¦è®°å½•æ¯ä¸ªæŸ±å­å·¦è¾¹ç¬¬ä¸€ä¸ªå°äºè¯¥æŸ±å­çš„ä¸‹æ ‡ï¼Œè€Œä¸æ˜¯å·¦è¾¹ç¬¬ä¸€ä¸ªå°äºè¯¥æŸ±å­çš„é«˜åº¦ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // æš´åŠ›åŒæŒ‡é’ˆ func largestRectangleArea(height []int) int { n := len(height) minl := make([]int, n) minr := make([]int, n) minl[0] = -1 for i := 1; i \u0026lt; n; i ++ { t := i - 1 for t \u0026gt;= 0 \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minl[t] = minl[t], t } } minr[n - 1] = n for i := n - 2; i \u0026gt;= 0; i -- { t := i + 1 for t \u0026lt; n \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minr[t] = minr[t], t } } sum := 0 for i := 0; i \u0026lt; n; i ++ { s := height[i] * (minr[i] - minl[i] - 1) sum = max(sum, s) } return sum } å•è°ƒæ ˆ 42. æ¥é›¨æ°´ (opens new window)æ˜¯æ‰¾æ¯ä¸ªæŸ±å­å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªå¤§äºè¯¥æŸ±å­é«˜åº¦çš„æŸ±å­ï¼Œè€Œæœ¬é¢˜æ˜¯æ‰¾æ¯ä¸ªæŸ±å­å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªå°äºè¯¥æŸ±å­çš„æŸ±å­ã€‚\næ ˆé¡¶å’Œæ ˆé¡¶çš„ä¸‹ä¸€ä¸ªå…ƒç´ ä»¥åŠè¦å…¥æ ˆçš„ä¸‰ä¸ªå…ƒç´ ç»„æˆäº†æˆ‘ä»¬è¦æ±‚æœ€å¤§é¢ç§¯çš„é«˜åº¦å’Œå®½åº¦\næ³¨ï¼šåœ¨heightæ•°ç»„å¤´å°¾åŠ ä¸€ä¸ª0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func largestRectangleArea(heights []int) (res int) { stack := make([]int, 0) heights = append([]int{0}, heights...) heights = append(heights, 0) stack = append(stack, 0) for i := 1; i \u0026lt; len(heights); i ++ { for heights[stack[len(stack)-1]] \u0026gt; heights[i] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] sum := heights[mid] * (i - left - 1) if sum \u0026gt; res { res = sum } } stack = append(stack, i) } return res } è´ªå¿ƒ DP åŸºç¡€é¢˜ èƒŒåŒ…ï¼š01ã€å®Œå…¨ã€å¤šé‡ æ‰“å®¶åŠ«èˆç³»åˆ— è‚¡ç¥¨é—®é¢˜ å­åºåˆ—é—®é¢˜ åŠ¨æ€è§„åˆ’ä¸­æ¯ä¸€ä¸ªçŠ¶æ€ä¸€å®šæ˜¯ç”±ä¸Šä¸€ä¸ªçŠ¶æ€æ¨å¯¼å‡ºæ¥çš„ï¼Œè¿™ä¸€ç‚¹å°±åŒºåˆ†äºè´ªå¿ƒï¼Œè´ªå¿ƒæ²¡æœ‰çŠ¶æ€æ¨å¯¼ï¼Œè€Œæ˜¯ä»å±€éƒ¨ç›´æ¥é€‰æœ€ä¼˜çš„ã€‚\né—®é¢˜åˆ†è§£ï¼š\nç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼ˆé€’æ¨å…¬å¼ï¼‰ dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ– ç¡®å®šéå†é¡ºåº ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„ å¦‚æœä»£ç æ²¡é€šè¿‡å°±æ‰“å°dpæ•°ç»„ï¼Œçœ‹çœ‹æ˜¯ä¸æ˜¯å’Œè‡ªå·±é¢„å…ˆæ¨å¯¼çš„å“ªé‡Œä¸ä¸€æ ·ã€‚\nå¦‚æœæ‰“å°å‡ºæ¥å’Œè‡ªå·±é¢„å…ˆæ¨¡æ‹Ÿæ¨å¯¼æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå°±æ˜¯è‡ªå·±çš„é€’å½’å…¬å¼ã€åˆå§‹åŒ–æˆ–è€…éå†é¡ºåºæœ‰é—®é¢˜äº†ã€‚\nå¦‚æœå’Œè‡ªå·±é¢„å…ˆæ¨¡æ‹Ÿæ¨å¯¼çš„ä¸ä¸€æ ·ï¼Œé‚£ä¹ˆå°±æ˜¯ä»£ç å®ç°ç»†èŠ‚æœ‰é—®é¢˜ã€‚\n509. æ–æ³¢é‚£å¥‘æ•°ï¼ˆå…¥é—¨ï¼‰ æ–æ³¢é‚£å¥‘æ•°ï¼Œé€šå¸¸ç”¨ F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š F(0) = 0ï¼ŒF(1) = 1 F(n) = F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n \u0026gt; 1 ç»™ä½ n ï¼Œè¯·è®¡ç®— F(n) ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼š2 è¾“å‡ºï¼š1 è§£é‡Šï¼šF(2) = F(1) + F(0) = 1 + 0 = 1 æç¤ºï¼š\n0 \u0026lt;= n \u0026lt;= 30 æ€è·¯ï¼š\nç¡®å®šdpæ•°ç»„åŠä¸‹è¡¨çš„æ„ä¹‰ï¼šdp[i] å®šä¹‰ä¸ºç¬¬iä¸ªæ•°çš„æ–æ³¢é‚£å¥‘æ•°å€¼ é€’æ¨å…¬å¼ï¼šé¢˜ç›®ç»™äº† dp[i] = dp[i - 1] + dp[i - 2] åˆå§‹åŒ–ï¼šé¢˜ç›®ç»™äº† dp[0] = 0, dp[1] = 1 éå†é¡ºåºï¼šä»å…¬å¼çœ‹å‡ºï¼Œdp[i] ä¾èµ– dp[i - 1]å’Œdp[i - 2]ï¼Œæ‰€ä»¥æ˜¯ä»å‰åˆ°åéå† ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„ï¼šN = 10æ—¶ï¼Œdpæ•°ç»„åº”è¯¥æ˜¯ï¼š0 1 1 2 3 5 8 13 21 34 55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // é€’å½’ func fib(n int) int { if n \u0026lt; 2 { return n } return fib(n - 1) + fib(n - 2) } // dp func fib(n int) int { if n \u0026lt; 2 { return n } dp0, dp1, dp := 0, 1, 0 for i := 1; i \u0026lt; n; i ++ { dp = dp0 + dp1 dp0, dp1 = dp1, dp } return dp } 70. çˆ¬æ¥¼æ¢¯ å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿæ³¨æ„ï¼šç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼š 2 è¾“å‡ºï¼š 2 è§£é‡Šï¼š æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚ 1 é˜¶ + 1 é˜¶ 2 é˜¶ ç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼š 3 è¾“å‡ºï¼š 3 è§£é‡Šï¼š æœ‰ä¸‰ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚ 1 é˜¶ + 1 é˜¶ + 1 é˜¶ 1 é˜¶ + 2 é˜¶ 2 é˜¶ + 1 é˜¶ æ€è·¯ï¼š\ndp[i]: çˆ¬åˆ°ç¬¬iå±‚æ—¶ï¼Œæœ‰dp[i]ç§æ–¹æ³• dp[i] = dp[i - 1] + dp[i - 2] ä¸è€ƒè™‘dp[0], dp[1] = 1, dp[2] = 2, ä»3å¼€å§‹é€’æ¨ é¡ºåºï¼šä»å‰åˆ°å ä¸¾ä¾‹ï¼šn = 5æ—¶ï¼Œ dpæ•°ç»„ï¼š1 2 3 5 8 1 2 3 4 5 6 7 8 9 10 11 func climbStairs(n int) int { if n == 1 { return n } dp := make([]int, n + 1) dp[1], dp[2] = 1, 2 for i := 3; i \u0026lt;= n; i ++ { dp[i] = dp[i - 1] + dp[i - 2] } return dp[n] } 746. æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ cost ï¼Œå…¶ä¸­ cost[i] æ˜¯ä»æ¥¼æ¢¯ç¬¬ i ä¸ªå°é˜¶å‘ä¸Šçˆ¬éœ€è¦æ”¯ä»˜çš„è´¹ç”¨ã€‚ä¸€æ—¦ä½ æ”¯ä»˜æ­¤è´¹ç”¨ï¼Œå³å¯é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå°é˜¶ã€‚\nä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ–ä¸‹æ ‡ä¸º 1 çš„å°é˜¶å¼€å§‹çˆ¬æ¥¼æ¢¯ã€‚\nè¯·ä½ è®¡ç®—å¹¶è¿”å›è¾¾åˆ°æ¥¼æ¢¯é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚\næ€è·¯ï¼š\ndp[i] ï¼š åˆ°è¾¾ç¬¬iä¸ªå°é˜¶æ‰€èŠ±è´¹çš„æœ€å°‘è´¹ç”¨\ndp[i] = dp[i - 1] + cost[i - 1], dp[i - 1] = dp[i - 2] + cost[i - 2].\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\nåˆå§‹åŒ–ï¼šæ ¹æ®é¢˜ç›®æ„æ€ï¼Œdp[0] = dp[1] = 0 (å› ä¸ºä»0æˆ–1å¼€é¢˜è·³éƒ½å¯ä»¥ï¼Œæ„æ€å°±æ˜¯ä¸è®¡è´¹)\néå†é¡ºåºï¼šä»å‰åˆ°å\nä¸¾ä¾‹æ¨å¯¼ï¼šcost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n0 0 1 2 2 3 3 4 4 5 6\n1 2 3 4 5 6 7 8 func minCostClimbingStairs(cost []int) int { f := make([]int, len(cost) + 1) f[0], f[1] = 0, 0 for i := 2; i \u0026lt;= len(cost); i ++ { f[i] = min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2]) } return f[len(cost)] } 62. ä¸åŒè·¯å¾„ ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ ï¼‰ã€‚\næœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ ï¼‰ã€‚\né—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ\ndp[i ] [j] : è¡¨ç¤ºä»ï¼ˆ0,0ï¼‰å‡ºå‘åˆ°ï¼ˆi,j)çš„ä¸åŒè·¯å¾„æ•° å…¬å¼ï¼šdp[ i ] [ j ] = dp[i] [j - 1] + dp[i - 1] [j] ï¼ˆä»å·¦è¾¹å’Œä¸Šè¾¹æ¥çš„ï¼‰ åˆå§‹åŒ–ï¼šdp[i] [0] = 1, dp[0] [j] = 1 éå†é¡ºåºï¼šä»å·¦åˆ°å³ä¸€å±‚å±‚éå†å³å¯ ä¸¾ä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j \u0026lt; n; j ++ { dp[0][j] = 1 } for i := 1; i \u0026lt; m; i ++ { for j := 1; j \u0026lt; n; j ++ { dp[i][j] = dp[i - 1][j] + dp[i][j - 1] } } return dp[m - 1][n - 1] } // ä¼˜åŒ–ï¼šäºŒç»´ç®€åŒ–åˆ°ä¸€ç»´ï¼Œæ»šåŠ¨æ•°ç»„ T: O(mn), S: O(mn) -\u0026gt; O(n) // æ•°è®ºåšæ³•ï¼šå¯¹äºmè¡Œnåˆ—çš„çŸ©å½¢ï¼Œèµ°åˆ°ç»ˆç‚¹éƒ½éœ€è¦m+n-2æ­¥ã€‚åœ¨è¿™m + n - 2 æ­¥ä¸­ï¼Œä¸€å®šæœ‰ m - 1 æ­¥æ˜¯è¦å‘ä¸‹èµ°çš„ï¼Œä¸ç”¨ç®¡ä»€ä¹ˆæ—¶å€™å‘ä¸‹èµ°ã€‚é‚£ä¹ˆæœ‰å‡ ç§èµ°æ³•å‘¢ï¼Ÿ å¯ä»¥è½¬åŒ–ä¸ºï¼Œç»™ä½ m + n - 2ä¸ªä¸åŒçš„æ•°ï¼Œéšä¾¿å–m - 1ä¸ªæ•°ï¼Œæœ‰å‡ ç§å–æ³•ã€‚C_(m+m-2)^(m-1) //éœ€è¦åœ¨è®¡ç®—åˆ†å­çš„æ—¶å€™ï¼Œä¸æ–­é™¤ä»¥åˆ†æ¯ func uniquePaths(m int, n int) int { numerator := 1 denominator := m - 1 // fenmu cnt := m - 1 t := m + n - 2 for cnt \u0026gt; 0 { numerator *= t t -- for denominator != 0 \u0026amp;\u0026amp; numerator % denominator == 0 { numerator /= denominator denominator -- } cnt -- } return numerator } // O(m) O(1) æ±‚ç»„åˆçš„æ—¶å€™ï¼Œè¦é˜²æ­¢ä¸¤ä¸ªintç›¸ä¹˜æº¢å‡ºï¼ æ‰€ä»¥ä¸èƒ½æŠŠç®—å¼çš„åˆ†å­éƒ½ç®—å‡ºæ¥ï¼Œåˆ†æ¯éƒ½ç®—å‡ºæ¥å†åšé™¤æ³•ã€‚\næ•°ä½DP æ•°çš„å¤§å°å’Œå¤æ‚åº¦æ²¡ä»€ä¹ˆå…³ç³»ï¼Œæ•°ä½å˜åŒ–æœ‰å…³ã€‚\nf[i, mask, isLimit, isNum]\nè¿”å›ä»iå¼€å§‹å¡«æ•°å­—ï¼Œiå‰é¢çš„æ•°å­—çš„é›†åˆæ˜¯maskï¼Œå…±æ„é€ å‡ºçš„ç‰¹æ®Šæ•°çš„æ•°é‡ï¼›is_limitè¡¨ç¤ºå‰é¢å¡«çš„æ•°æ˜¯å¦éƒ½æ˜¯nå¯¹åº”ä½ç½®ä¸Šçš„ï¼Œif trueï¼Œåˆ™å½“å‰ä½ä¹‹å¤šä¸ºs[i], å¦åˆ™è‡³å¤šä¸ºâ€™9â€™; is_numè¡¨ç¤ºå‰é¢æ˜¯å¦å¡«äº†æ•°å­—ï¼ˆæ˜¯å¦è·³è¿‡ï¼‰ï¼Œif trueåˆ™å½“å‰å¯ä»¥ä»0å¼€å§‹ï¼Œfalseå¯ä»¥è·³è¿‡æˆ–ä»1å¼€å§‹ã€‚\n1 2 3 func f(i int, mask int, is_limit bool, is_num bool) int { if i == len(s) } é›†åˆå¯ä»¥ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼ŒäºŒè¿›åˆ¶ä»ä½åˆ°é«˜ç¬¬ i ä½ä¸º 1 è¡¨ç¤º i åœ¨é›†åˆä¸­ï¼Œä¸º 0 è¡¨ç¤º i ä¸åœ¨é›†åˆä¸­ã€‚ä¾‹å¦‚é›†åˆ {0,2,3} å¯¹åº”çš„äºŒè¿›åˆ¶æ•°ä¸º 1101 (2)\nè®¾é›†åˆå¯¹åº”çš„äºŒè¿›åˆ¶æ•°ä¸º xã€‚æœ¬é¢˜éœ€è¦ç”¨åˆ°ä¸¤ä¸ªä½è¿ç®—æ“ä½œï¼š\nåˆ¤æ–­å…ƒç´  d æ˜¯å¦åœ¨é›†åˆä¸­ï¼šx \u0026raquo; d \u0026amp; 1 å¯ä»¥å–å‡º x çš„ç¬¬ d ä¸ªæ¯”ç‰¹ä½ï¼Œå¦‚æœæ˜¯ 1 å°±è¯´æ˜ d åœ¨é›†åˆä¸­ã€‚ æŠŠå…ƒç´  d æ·»åŠ åˆ°é›†åˆä¸­ï¼šå°† x æ›´æ–°ä¸º x | (1 \u0026laquo; d)ã€‚\n","permalink":"https://erica423.github.io/posts/algorithm/","summary":"1 æ•°ç»„ 1.1 æ•°ç»„å­˜å‚¨ ä¸è®ºä¸€ç»´æ•°ç»„è¿˜æ˜¯äºŒç»´æ•°ç»„ï¼Œå…¶å­˜å‚¨åœ°å€ç©ºé—´éƒ½æ˜¯çº¿æ€§è¿ç»­çš„ã€‚ goä¸­ int ç±»å‹é•¿åº¦å’Œæ“ä½œç³»ç»Ÿçš„ä½æ•°æœ‰å…³ï¼š64ä½çš„é»˜è®¤ int ä½æ•°ä¸º 8ï¼Œ32ä½","title":"ç®—æ³•"},{"content":"Go è¯­è¨€å¹¿æ³›åœ°åº”ç”¨äºäº‘è®¡ç®—å’Œå¾®æœåŠ¡ï¼Œæˆç†Ÿçš„ RPC æ¡†æ¶å’Œå¾®æœåŠ¡æ¡†æ¶æ±—ç‰›å……æ ‹ã€‚grpcã€rpcxã€go-micro ç­‰éƒ½æ˜¯éå¸¸æˆç†Ÿçš„æ¡†æ¶ã€‚ä¸€èˆ¬è€Œè¨€ï¼ŒRPC æ˜¯å¾®æœåŠ¡æ¡†æ¶çš„ä¸€ä¸ªå­é›†ï¼Œå¾®æœåŠ¡æ¡†æ¶å¯ä»¥è‡ªå·±å®ç° RPC éƒ¨åˆ†ï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä¸åŒçš„ RPC æ¡†æ¶ä½œä¸ºé€šä¿¡åŸºåº§ã€‚\nGeeRPC é€‰æ‹©ä»é›¶å®ç° Go è¯­è¨€å®˜æ–¹çš„æ ‡å‡†åº“ net/rpcï¼Œå¹¶åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ–°å¢äº†ï¼š\nåè®®äº¤æ¢(protocol exchange) æ³¨å†Œä¸­å¿ƒ(registry) æœåŠ¡å‘ç°(service discovery) è´Ÿè½½å‡è¡¡(load balance) è¶…æ—¶å¤„ç†(timeout processing)ç­‰ç‰¹æ€§ã€‚ æ¶ˆæ¯çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ– RPCè°ƒç”¨ï¼š\n1 err := client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) å…¶ä¸­ï¼Œå®¢æˆ·ç«¯å‘é€çš„è¯·æ±‚åŒ…æ‹¬ï¼šæœåŠ¡åArithï¼Œæ–¹æ³•åMultiplyï¼Œå‚æ•°argsï¼›æœåŠ¡ç«¯çš„å“åº”åŒ…æ‹¬é”™è¯¯ä¿¡æ¯errå’Œè¿”å›å€¼replyã€‚\n","permalink":"https://erica423.github.io/posts/rpc/","summary":"Go è¯­è¨€å¹¿æ³›åœ°åº”ç”¨äºäº‘è®¡ç®—å’Œå¾®æœåŠ¡ï¼Œæˆç†Ÿçš„ RPC æ¡†æ¶å’Œå¾®æœåŠ¡æ¡†æ¶æ±—ç‰›å……æ ‹ã€‚grpcã€rpcxã€go-micro ç­‰éƒ½æ˜¯éå¸¸æˆç†Ÿçš„æ¡†æ¶ã€‚ä¸€èˆ¬è€Œè¨€ï¼ŒRP","title":"RPCç›¸å…³"},{"content":" GOåœ¨çº¿ç¼–è¯‘å™¨ï¼šgo playground\nTest-Driven Development(TDD) - æµ‹è¯•é©±åŠ¨å¼€å‘ å‘¨æœŸï¼š\nç¼–å†™ä¸€ä¸ªæµ‹è¯•\nè®©ç¼–è¯‘é€šè¿‡\nè¿è¡Œæµ‹è¯•ï¼ŒæŸ¥çœ‹å¤±è´¥åŸå› å¹¶æ£€æŸ¥é”™è¯¯æ¶ˆæ¯æ˜¯å¾ˆæœ‰æ„ä¹‰çš„\nç¼–å†™è¶³å¤Ÿçš„ä»£ç ä»¥ä½¿æµ‹è¯•é€šè¿‡\né‡æ„\nå¸¸ç”¨åŠŸèƒ½ æµ‹è¯•æ–‡ä»¶å‘½åè§„åˆ™ï¼šxxx_test.go, ä¸xxx.goæ”¾åœ¨åŒä¸€ä¸ªpackageä¸‹\næµ‹è¯•å‡½æ•°å‘½ä»¤ä»¥Testå¼€å¤´\næµ‹è¯•å‡½æ•°åªæ¥å—ä¸€ä¸ª*testing.Tç±»å‹çš„å‚æ•°t ï¼ˆtå°±æ˜¯æµ‹è¯•æ¡†æ¶ä¸­çš„é’©å­hookï¼‰\nt.Errorf(): æ ¼å¼åŒ–è®°å½•é”™è¯¯ä¿¡æ¯ï¼Œä½†æµ‹è¯•ç»§ç»­è¿›è¡Œã€‚f è¡¨ç¤ºæ ¼å¼åŒ–ï¼Œå…è®¸æˆ‘ä»¬æ„å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶å°†å€¼æ’å…¥å ä½ç¬¦å€¼ %q ä¸­ã€‚\nt.Fatalf(): æŠ¥å‘Šè‡´å‘½é”™è¯¯ï¼Œå¹¶ç»ˆæ­¢æµ‹è¯•ã€‚\nt.Fail(): æ ‡è®°æµ‹è¯•ç»“æœä¸ºå¤±è´¥çš„ï¼Œä¸åŒçš„æ˜¯t.FailåªæŠŠæµ‹è¯•ç»“æœæ ‡è®°ä¸ºå¤±è´¥ï¼Œä¸ä¼šç»ˆæ­¢å½“å‰æµ‹è¯•ï¼Œt.FailNowåˆ™ä¼šç«‹å³ç»ˆæ­¢å½“å‰çš„æµ‹è¯•å‡½æ•°ï¼Œå¹¶æ ‡è®°ä¸ºå¤±è´¥ã€‚\nt.Helper(): å‘Šè¯‰æµ‹è¯•å¥—ä»¶è¿™ä¸ªæ–¹æ³•æ˜¯è¾…åŠ©å‡½æ•°ï¼ˆhelperï¼‰ã€‚é€šè¿‡è¿™æ ·åšï¼Œå½“æµ‹è¯•å¤±è´¥æ—¶æ‰€æŠ¥å‘Šçš„è¡Œå·å°†åœ¨å‡½æ•°è°ƒç”¨ä¸­è€Œä¸æ˜¯åœ¨è¾…åŠ©å‡½æ•°å†…éƒ¨ã€‚\nSubtest - å­æµ‹è¯• æœ‰æ—¶ï¼Œå¯¹ä¸€ä¸ªã€Œäº‹æƒ…ã€è¿›è¡Œåˆ†ç»„æµ‹è¯•ï¼Œç„¶åå†å¯¹ä¸åŒåœºæ™¯è¿›è¡Œå­æµ‹è¯•éå¸¸æœ‰æ•ˆã€‚\n1 2 3 4 5 6 7 8 9 func TestMain(t *testing.T) { t.Run(\u0026#34;show expected output of this function\u0026#34;, func(t *testing.T) { }) t.Run(\u0026#34;...\u0026#34;, func(t *testing.T) { }) } è¿™ç§æ–¹æ³•çš„å¥½å¤„æ˜¯ï¼Œä½ å¯ä»¥å»ºç«‹åœ¨å…¶ä»–æµ‹è¯•ä¸­ä¹Ÿèƒ½å¤Ÿä½¿ç”¨çš„å…±äº«ä»£ç ã€‚ é‡è¦çš„æ˜¯ï¼Œä½ çš„æµ‹è¯•æ¸…æ¥šåœ°è¯´æ˜äº†ä»£ç éœ€è¦åšä»€ä¹ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func TestHello(t *testing.T) { assertCorrectMessage := func(t *testing.T, got, want string) { t.Helper() if got != want { t.Errorf(\u0026#34;got \u0026#39;%q\u0026#39; want \u0026#39;%q\u0026#39;\u0026#34;, got, want) } } t.Run(\u0026#34;saying hello to people\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;Chris\u0026#34;) want := \u0026#34;Hello, Chris\u0026#34; assertCorrectMessage(t, got, want) }) t.Run(\u0026#34;empty string defaults to \u0026#39;world\u0026#39;\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;\u0026#34;) want := \u0026#34;Hello, World\u0026#34; assertCorrectMessage(t, got, want) }) } åŠæ—¶æ·»åŠ æ³¨é‡Šï¼Œæ–¹ä¾¿ç”ŸæˆAPIæ–‡æ¡£ Swaggerè‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£\nsyntax å¥æ³•\nAdd AND assignment operactor è‡ªå¢èµ‹å€¼è¿ç®—ç¬¦ +=\næ•°ç»„ \u0026amp; åˆ‡ç‰‡ we are using the %v placeholder to print the \u0026ldquo;default\u0026rdquo; format, which works well for arrays.\nåœ¨ Go ä¸­ä¸èƒ½å¯¹åˆ‡ç‰‡ä½¿ç”¨ç­‰å·è¿ç®—ç¬¦ã€‚ä½ å¯ä»¥å†™ä¸€ä¸ªå‡½æ•°è¿­ä»£æ¯ä¸ªå…ƒç´ æ¥æ£€æŸ¥å®ƒä»¬çš„å€¼ã€‚ä½†æ˜¯ä¸€ç§æ¯”è¾ƒç®€å•çš„åŠæ³•æ˜¯ä½¿ç”¨ reflect.DeepEqualï¼Œå®ƒåœ¨åˆ¤æ–­ä¸¤ä¸ªå˜é‡æ˜¯å¦ç›¸ç­‰æ—¶ååˆ†æœ‰ç”¨ã€‚ä½†ä¸æ˜¯ç±»å‹å®‰å…¨çš„ã€‚\næ¥å£ åœ¨ Go è¯­è¨€ä¸­ interface resolution æ˜¯éšå¼çš„ã€‚å¦‚æœä¼ å…¥çš„ç±»å‹åŒ¹é…æ¥å£éœ€è¦çš„ï¼Œåˆ™ç¼–è¯‘æ­£ç¡®ã€‚\næµ‹è¯•è¦†ç›–ç‡ 1 go test -cover Table driven tests - è¡¨æ ¼é©±åŠ¨æµ‹è¯• é€‚åˆå¤„ç†åŒè´¨åŒ–çš„æµ‹è¯•å†…å®¹, å¦‚æœä½ è¦æµ‹è¯•ä¸€ä¸ªæ¥å£çš„ä¸åŒå®ç°ï¼Œæˆ–è€…ä¼ å…¥å‡½æ•°çš„æ•°æ®æœ‰å¾ˆå¤šä¸åŒçš„æµ‹è¯•éœ€æ±‚ï¼Œè¿™ä¸ªæ­¦å™¨å°†éå¸¸ç»™åŠ›ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func TestArea(t *testing.T) { areaTests := []struct { shape Shape want float64 }{ {Rectangle{10.0, 20.0}, 200.0}, {Circle{10.0}, 314.1592653589793}, } for _, tt := range areaTests { got := tt.shape.Area() if got != tt.want { t.Errorf(\u0026#34;want %.2f but got %.2f\u0026#34;, tt.want, got) } } } ä½¿ç”¨äº†åŒ¿åç»“æ„ä½“ - anonymous struct, ç”¨å«æœ‰ä¸¤ä¸ªåŸŸ shape å’Œ want çš„ []struct å£°æ˜äº†ä¸€ä¸ªç»“æ„ä½“åˆ‡ç‰‡ã€‚\nå¯ä»¥æ”¹è¿›é”™è¯¯è¾“å‡ºä¸º %#v got %.2f want %.2f. %#vï¼Œè¿™æ ·ä¼šæ‰“å°ç»“æ„ä½“ä¸­åŸŸçš„å€¼ã€‚èƒ½ä¸€çœ¼çœ‹å‡ºè¢«æµ‹è¯•çš„å±æ€§ã€‚\nå…³äºåˆ—è¡¨é©±åŠ¨æµ‹è¯•çš„æœ€åä¸€ç‚¹æç¤ºæ˜¯ä½¿ç”¨ t.Runã€‚\nåœ¨æ¯ä¸ªç”¨ä¾‹ä¸­ä½¿ç”¨ t.Runï¼Œæµ‹è¯•ç”¨ä¾‹çš„é”™è¯¯è¾“å‡ºä¸­ä¼šåŒ…å«ç”¨ä¾‹çš„åå­—ï¼š\n1 2 3 -------- FAIL: TestArea (0.00s) --- FAIL: TestArea/Rectangle (0.00s) shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10 è¿è¡Œåˆ—è¡¨ä¸­æŒ‡å®šçš„æµ‹è¯•ç”¨ä¾‹ï¼šgo test -run TestArea/Rectangle\næ£€æŸ¥æœªç»æ£€æŸ¥çš„error æœ‰ä¸€ç§æƒ…å†µæˆ‘ä»¬è¿˜æ²¡æœ‰æµ‹è¯•è¿‡ã€‚è¦æ‰¾åˆ°å®ƒï¼Œåœ¨ä¸€ä¸ªç»ˆç«¯ä¸­è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥å®‰è£… errcheckï¼Œè¿™æ˜¯è®¸å¤šå¯ç”¨çš„ lintersï¼ˆä»£ç æ£€æµ‹å·¥å…·ï¼‰ä¹‹ä¸€ã€‚\ngo get -u github.com/kisielk/errcheck\nç„¶åï¼Œåœ¨ä»£ç ç›®å½•ä¸­è¿è¡Œ errcheck .\nä¾èµ–æ³¨å…¥ï¼š io.Writer æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€šç”¨æ¥å£ï¼Œç”¨äºã€Œå°†æ•°æ®æ”¾åœ¨æŸä¸ªåœ°æ–¹ã€ã€‚\nfmt.Fprintf å’Œ fmt.Printf ä¸€æ ·ï¼Œåªä¸è¿‡ fmt.Fprintf ä¼šæ¥æ”¶ä¸€ä¸ª Writer å‚æ•°ï¼Œç”¨äºæŠŠå­—ç¬¦ä¸²ä¼ é€’è¿‡å»ï¼Œè€Œ fmt.Printf é»˜è®¤æ˜¯æ ‡å‡†è¾“å‡ºã€‚\næ³¨å…¥ - Mocking å°†ä¾èµ–å…³ç³»å®šä¹‰ä¸ºä¸€ä¸ªæ¥å£ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨ main ä½¿ç”¨ çœŸå®çš„ Sleeperï¼Œå¹¶ä¸”åœ¨æˆ‘ä»¬çš„æµ‹è¯•ä¸­ä½¿ç”¨ spy sleeperã€‚é€šè¿‡ä½¿ç”¨æ¥å£ï¼Œæˆ‘ä»¬çš„ Countdown å‡½æ•°å¿½ç•¥äº†è¿™ä¸€ç‚¹ï¼Œå¹¶ä¸ºè°ƒç”¨è€…å¢åŠ äº†ä¸€äº›çµæ´»æ€§ã€‚\nConcurrency åŒ¿åå‡½æ•°æœ‰è®¸å¤šæœ‰ç”¨çš„ç‰¹æ€§ã€‚é¦–å…ˆï¼Œå®ƒä»¬å¯ä»¥åœ¨å£°æ˜çš„åŒæ—¶æ‰§è¡Œ â€”â€” è¿™å°±æ˜¯åŒ¿åå‡½æ•°æœ«å°¾çš„ () å®ç°çš„ã€‚å…¶æ¬¡ï¼Œå®ƒä»¬ç»´æŠ¤å¯¹å…¶æ‰€å®šä¹‰çš„è¯æ±‡ä½œç”¨åŸŸçš„è®¿é—®æƒ â€”â€” åœ¨å£°æ˜åŒ¿åå‡½æ•°æ—¶æ‰€æœ‰å¯ç”¨çš„å˜é‡ä¹Ÿå¯åœ¨å‡½æ•°ä½“å†…ä½¿ç”¨ã€‚\nä¸Šé¢åŒ¿åå‡½æ•°çš„ä¸»ä½“å’Œä¹‹å‰å¾ªç¯ä½“ä¸­çš„å®Œå…¨ä¸€æ ·ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯å¾ªç¯çš„æ¯æ¬¡è¿­ä»£éƒ½ä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„ goroutineï¼Œä¸å½“å‰è¿›ç¨‹ï¼ˆWebsiteChecker å‡½æ•°ï¼‰åŒæ—¶å‘ç”Ÿï¼Œæ¯ä¸ªå¾ªç¯éƒ½ä¼šå°†ç»“æœæ·»åŠ åˆ° results map ä¸­ã€‚\n1 2 3 4 5 6 7 for _, url := range urls { go func() { results[url] = wc(url) }() } time.Sleep(2 * time.Second) è¿™é‡Œçš„é—®é¢˜æ˜¯å˜é‡ url è¢«é‡å¤ç”¨äº for å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ â€”â€” æ¯æ¬¡éƒ½ä¼šä» urls è·å–æ–°å€¼ã€‚ä½†æ˜¯æˆ‘ä»¬çš„æ¯ä¸ª goroutine éƒ½æ˜¯ url å˜é‡çš„å¼•ç”¨ â€”â€” å®ƒä»¬æ²¡æœ‰è‡ªå·±çš„ç‹¬ç«‹å‰¯æœ¬ã€‚æ‰€ä»¥ä»–ä»¬ éƒ½ ä¼šå†™å…¥åœ¨è¿­ä»£ç»“æŸæ—¶çš„ url â€”â€” æœ€åä¸€ä¸ª urlã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å¾—åˆ°çš„ç»“æœæ˜¯æœ€åä¸€ä¸ª urlã€‚\n1 2 3 4 5 6 7 for _, url := range urls { go func(u string) { results[u] = wc(u) }(url) } time.Sleep(2 * time.Second) é€šè¿‡ç»™æ¯ä¸ªåŒ¿åå‡½æ•°ä¸€ä¸ªå‚æ•° url(u)ï¼Œç„¶åç”¨ url ä½œä¸ºå‚æ•°è°ƒç”¨åŒ¿åå‡½æ•°ï¼Œæˆ‘ä»¬ç¡®ä¿ u çš„å€¼å›ºå®šä¸ºå¾ªç¯è¿­ä»£çš„ url å€¼ï¼Œé‡æ–°å¯åŠ¨ goroutineã€‚u æ˜¯ url å€¼çš„å‰¯æœ¬ï¼Œå› æ­¤æ— æ³•æ›´æ”¹ã€‚\nç”¨channelè§£å†³æ•°æ®ç«äº‰ data race\ngoroutines æ˜¯ Go çš„åŸºæœ¬å¹¶å‘å•å…ƒï¼Œå®ƒè®©æˆ‘ä»¬å¯ä»¥åŒæ—¶æ£€æŸ¥å¤šä¸ªç½‘ç«™ã€‚\nanonymous functionsï¼ˆåŒ¿åå‡½æ•°ï¼‰ï¼Œæˆ‘ä»¬ç”¨å®ƒæ¥å¯åŠ¨æ¯ä¸ªæ£€æŸ¥ç½‘ç«™çš„å¹¶å‘è¿›ç¨‹ã€‚\nchannelsï¼Œç”¨æ¥ç»„ç»‡å’Œæ§åˆ¶ä¸åŒè¿›ç¨‹ä¹‹é—´çš„äº¤æµï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿé¿å… race conditionï¼ˆç«äº‰æ¡ä»¶ï¼‰ çš„é—®é¢˜ã€‚\nthe race detectorï¼ˆç«äº‰æ¢æµ‹å™¨ï¼‰ å¸®åŠ©æˆ‘ä»¬è°ƒè¯•å¹¶å‘ä»£ç çš„é—®é¢˜ã€‚\nä½¿ç”¨ select æ—¶ï¼Œtime.After æ˜¯ä¸€ä¸ªå¾ˆå¥½ç”¨çš„å‡½æ•°ã€‚å½“ä½ ç›‘å¬çš„ channel æ°¸è¿œä¸ä¼šè¿”å›ä¸€ä¸ªå€¼æ—¶ä½ å¯ä»¥æ½œåœ¨åœ°ç¼–å†™æ°¸è¿œé˜»å¡çš„ä»£ç ï¼Œå°½ç®¡åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­å®ƒæ²¡æœ‰å‘ç”Ÿã€‚time.After ä¼šåœ¨ä½ å®šä¹‰çš„æ—¶é—´è¿‡åå‘é€ä¸€ä¸ªä¿¡å·ç»™ channel å¹¶è¿”å›ä¸€ä¸ª chan ç±»å‹ï¼ˆå°±åƒ ping é‚£æ ·ï¼‰ã€‚\nvalue æœ‰ä¸€ä¸ªæ–¹æ³• NumFieldï¼Œå®ƒè¿”å›å€¼ä¸­çš„å­—æ®µæ•°\nSync Sync\nWaitGroup ç­‰å¾… goroutine é›†åˆå®Œæˆã€‚ä¸» goroutine è°ƒç”¨ Add è®¾ç½®ç­‰å¾…çš„ goroutine æ•°é‡ã€‚ç„¶åæ¯ä¸ª goroutine è¿è¡Œå¹¶åœ¨å®Œæˆæ—¶è°ƒç”¨ Doneã€‚åŒæ—¶ï¼ŒWait å¯ä»¥ç”¨æ¥é˜»å¡ï¼Œç›´åˆ°æ‰€æœ‰ goroutine éƒ½å®Œæˆã€‚\né€šè¿‡åœ¨åšå‡ºæ–­è¨€ä¹‹å‰ç­‰å¾…wg.Wait()å®Œæˆï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šæ‰€æœ‰çš„ goroutine éƒ½å·²å°è¯•Incè¿‡Counterã€‚\nA Mutex must not be copied after first use. Use channels when passing ownership of data\nUse mutexes for managing state\nContext context\næˆ‘ä»¬æ‰€åšçš„æ˜¯ä»æˆ‘ä»¬çš„requestä¸­æ´¾ç”Ÿä¸€ä¸ªæ–°çš„ cancellingCtxï¼Œå®ƒè¿”å›ä¸€ä¸ªcancelå‡½æ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ time.AfterFunc å®‰æ’åœ¨ 5 æ¯«ç§’å†…è°ƒç”¨è¯¥å‡½æ•°ã€‚æœ€åï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨ request.WithContext åœ¨è¯·æ±‚ä¸­ä½¿ç”¨è¿™ä¸ªæ–°ä¸Šä¸‹æ–‡ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func Server(store Store) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { ctx := r.Context() data := make(chan string, 1) go func() { data \u0026lt;- store.Fetch() }() select { case d := \u0026lt;-data: fmt.Fprint(w, d) case \u0026lt;-ctx.Done(): store.Cancel() } } } contextæœ‰ä¸€ä¸ªæ–¹æ³•Done()è¿”å›ä¸€ä¸ªchannelï¼Œå½“contextâ€œå®Œæˆâ€æˆ–â€œå–æ¶ˆâ€æ—¶ï¼Œè¯¥é€šé“ä¼šå‘é€ä¿¡å·ã€‚ æˆ‘ä»¬æƒ³è¦ç›‘å¬è¯¥ä¿¡å·å¹¶åœ¨æ”¶åˆ°è¯¥ä¿¡å·æ—¶è°ƒç”¨ store.Cancelï¼Œä½†å¦‚æœæˆ‘ä»¬Storeè®¾æ³•åœ¨Fetchå®ƒä¹‹å‰å°±å¿½ç•¥å®ƒã€‚\nå¯¹æœåŠ¡å™¨çš„ä¼ å…¥è¯·æ±‚åº”è¯¥åˆ›å»ºä¸Šä¸‹æ–‡ï¼Œè€Œå¯¹æœåŠ¡å™¨çš„ä¼ å‡ºè°ƒç”¨åº”è¯¥æ¥å—ä¸Šä¸‹æ–‡ã€‚å®ƒä»¬ä¹‹é—´çš„å‡½æ•°è°ƒç”¨é“¾å¿…é¡»ä¼ æ’­ä¸Šä¸‹æ–‡ï¼Œå¯ä»¥é€‰æ‹©å°†å…¶æ›¿æ¢ä¸ºä½¿ç”¨ WithCancelã€WithDeadlineã€WithTimeout æˆ– WithValue åˆ›å»ºçš„æ´¾ç”Ÿä¸Šä¸‹æ–‡ã€‚å½“ä¸€ä¸ªä¸Šä¸‹æ–‡è¢«å–æ¶ˆæ—¶ï¼Œå®ƒæ´¾ç”Ÿçš„æ‰€æœ‰ä¸Šä¸‹æ–‡ä¹Ÿè¢«å–æ¶ˆã€‚\nProperty based tests strings.Builder ç”¨äºä½¿ç”¨å†™å…¥æ–¹æ³•é«˜æ•ˆæ„å»ºå­—ç¬¦ä¸²ã€‚å®ƒæœ€å¤§é™åº¦åœ°å‡å°‘äº†å†…å­˜å¤åˆ¶ã€‚\nç½—é©¬æ•°å­—çš„è§„åˆ™æ˜¯åŒä¸€å­—ç¬¦ä¸èƒ½åœ¨ä¸€è¡Œä¸­é‡å¤è¶…è¿‡ 3 æ¬¡ã€‚ å–è€Œä»£ä¹‹çš„æ˜¯å–ä¸‹ä¸€ä¸ªæœ€é«˜çš„ç¬¦å·ï¼Œç„¶ååœ¨å…¶å·¦ä¾§æ”¾ç½®ä¸€ä¸ªç¬¦å·æ¥ â€œå‡å»â€ã€‚ å¹¶éæ‰€æœ‰ç¬¦å·éƒ½å¯ä»¥ç”¨ä½œå‡æ³•å™¨ï¼›åªæœ‰ I (1)ã€X (10) å’Œ C (100)ã€‚\nä¾‹å¦‚ï¼Œç½—é©¬æ•°å­—ä¸­çš„ 5 æ˜¯ Vã€‚è¦åˆ›å»º 4ï¼Œæ‚¨ä¸æ‰§è¡Œ IIIIï¼Œè€Œæ˜¯æ‰§è¡Œ IVã€‚\nRomanNumeralè§„åˆ™ï¼š\nä¸èƒ½æœ‰è¶…è¿‡ 3 ä¸ªè¿ç»­çš„ç¬¦å·\nåªæœ‰ I (1), X (10) å’Œ C (100) æ˜¯ ã€Œå‡æ³•å™¨ã€\nå°† ConvertToRoman(N) çš„ç»“æœä¼ é€’ç»™ ConvertToArabic ï¼Œåº”è¯¥è¿”å› Nã€‚\nåŸºäºå±æ€§çš„æµ‹è¯•é€šè¿‡å‘ä»£ç ä¸­æŠ›å‡ºéšæœºæ•°æ®å¹¶éªŒè¯æ‰€æè¿°çš„è§„åˆ™å§‹ç»ˆä¸ºçœŸæ¥å¸®åŠ©æ‚¨åšåˆ°è¿™ä¸€ç‚¹ã€‚å¾ˆå¤šäººè®¤ä¸ºåŸºäºå±æ€§çš„æµ‹è¯•ä¸»è¦æ˜¯å…³äºéšæœºæ•°æ®çš„ï¼Œä½†ä»–ä»¬æ˜¯é”™è¯¯çš„ã€‚ åŸºäºå±æ€§çš„æµ‹è¯•é¢ä¸´çš„çœŸæ­£æŒ‘æˆ˜æ˜¯ä½ å¯¹ä½ çš„é¢†åŸŸæœ‰ã€Œå¾ˆå¥½çš„ã€ç†è§£ï¼Œè¿™æ ·æ‚¨å°±å¯ä»¥ç¼–å†™è¿™äº›å±æ€§ã€‚\nä»åº•éƒ¨è¯»å–ï¼Œæˆ‘ä»¬ä¸º quick.Check æä¾›äº†ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†è¿è¡Œä¸€äº›éšæœºçš„è¾“å…¥ï¼Œå¦‚æœå‡½æ•°è¿”å› falseï¼Œå®ƒå°†è¢«è§†ä¸ºæ£€æŸ¥å¤±è´¥ã€‚\nä¸Šé¢çš„ assertion å‡½æ•°æ¥å—éšæœºæ•°å¹¶è¿è¡Œå‡½æ•°æ¥æµ‹è¯•å±æ€§ã€‚\nä½ ä¸èƒ½ç”¨ç½—é©¬æ•°å­—è¡¨ç¤ºè´Ÿæ•°\næ ¹æ®æˆ‘ä»¬æœ€å¤š 3 ä¸ªè¿ç»­ç¬¦å·çš„è§„åˆ™ï¼Œæˆ‘ä»¬ä¸èƒ½è¡¨ç¤ºå¤§äº 3999 çš„å€¼ (ç½—é©¬æ•°å­—çš„æœ€å¤§å€¼)ï¼Œè€Œ int çš„æœ€å¤§å€¼æ¯” 3999 å¤§å¾—å¤šã€‚ å› æ­¤ä½¿ç”¨uint16\nå†…ç½®çš„è·¯ç”±æœºåˆ¶å«åš ServeMuxï¼ˆrequest multiplexerï¼Œå¤šè·¯è¯·æ±‚å¤ç”¨å™¨ï¼‰ï¼Œå®ƒå…è®¸ä½ å°† http.Handler é™„åŠ åˆ°ç‰¹å®šçš„è¯·æ±‚è·¯å¾„ã€‚\nWe changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.\nGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to â€œborrowâ€ pieces of an implementation by embedding types within a struct or interface.\nè¿™æ„å‘³ç€æˆ‘ä»¬çš„ PlayerServer ç°åœ¨å·²ç»æœ‰äº† http.Handler æ‰€æœ‰çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ ServeHTTPã€‚\nä¸ºäº† â€œå¡«å……â€ http.Handlerï¼Œæˆ‘ä»¬å°†å®ƒåˆ†é…ç»™æˆ‘ä»¬åœ¨ NewPlayerServer ä¸­åˆ›å»ºçš„ routerã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·åšæ˜¯å› ä¸º http.ServeMux å…·æœ‰ ServeHTTP æ–¹æ³•ã€‚\nè¿™å…è®¸æˆ‘ä»¬åˆ é™¤æˆ‘ä»¬çš„ ServeHTTP æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»é€šè¿‡åµŒå…¥ç±»å‹å…¬å¼€äº†å®ƒã€‚\nåµŒå…¥æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„æ€çš„è¯­æ³•ç‰¹æ€§ã€‚ä½ å¯ä»¥ç”¨å®ƒå°†æ¥å£ç»„æˆæ–°çš„æ¥å£ã€‚\nIOå’Œæ’åº æœåŠ¡å™¨é‡å¯ä¼šé‡ç½®ç§¯åˆ†\nos.OpenFile å…è®¸ä½ å®šä¹‰æ‰“å¼€æ–‡ä»¶çš„æƒé™ï¼Œåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼ŒO_RDWR æ„å‘³ç€æˆ‘ä»¬æƒ³è¦è¯»å†™æƒé™ï¼Œos.O_CREATE æ˜¯æŒ‡å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥æ–‡ä»¶ã€‚\nåˆ›å»ºä¸€ä¸ªæ–°ç±»å‹æ¥å°è£…æˆ‘ä»¬çš„ã€Œå½“å†™å…¥æ—¶ï¼Œä»å¤´éƒ¨å¼€å§‹ã€åŠŸèƒ½ã€‚æˆ‘æŠŠå®ƒå«åš Tape.\nfile.Stat è¿”å›æˆ‘ä»¬çš„æ–‡ä»¶çš„ç»Ÿè®¡æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥æ£€æŸ¥æ–‡ä»¶çš„å¤§å°ï¼Œå¦‚æœå®ƒæ˜¯ç©ºçš„ï¼Œæˆ‘ä»¬å°±ä¼šç¼–å†™ä¸€ä¸ªç©ºçš„ JSON æ•°ç»„ï¼Œç„¶å Seek åˆ°å¼€å§‹ä½ç½®ï¼Œä¸ºå‰©ä¸‹çš„ä»£ç åšå‡†å¤‡ã€‚\nå‘½ä»¤è¡Œå’Œé¡¹ç›®ç»“æ„ å½“ç”¨æˆ·è¾“å…¥ Ruth wins æ—¶ï¼Œå®ƒåªéœ€è¦èƒ½å¤Ÿè®°å½•ç©å®¶çš„èƒœå‡ºæƒ…å†µï¼Œæœ€ç»ˆç›®çš„æ˜¯ä½œä¸ºä¸€ä¸ªå¸®åŠ©ç”¨æˆ·ç©æ‰‘å…‹çš„å·¥å…·ã€‚\näº§å“è´Ÿè´£äººå¸Œæœ›åœ¨ä¸¤ä¸ªåº”ç”¨ç¨‹åºä¹‹é—´å…±äº«æ•°æ®åº“ï¼Œä»¥ä¾¿ç©å®¶leagueæ ¹æ®æ–°ç¨‹åºä¸­è®°å½•çš„winsè¿›è¡Œæ›´æ–°ã€‚\nç¬¬ä¸€ä¸ªéœ€æ±‚å°±æ˜¯å½“ç”¨æˆ·è¾“å…¥ {PlayerName} wins æ—¶è®°å½•ä¸€æ¬¡èƒœåˆ©ã€‚\nbufio åŒ…å®ç°äº† I/O ç¼“å†²ã€‚å®ƒå°è£…äº†ä¸€ä¸ª io.Reader æˆ– io.Writer å¯¹è±¡ï¼Œåˆ›å»ºäº†å¦ä¸€ä¸ªå¯¹è±¡ï¼ˆReader æˆ– Writerï¼‰ï¼Œä¹Ÿå®ç°äº†æ¥å£ï¼Œå¹¶ä¸ºæ–‡æœ¬ I/O æä¾›äº†ç¼“å†²å’Œä¸€äº›å¸®åŠ©ã€‚\nScanner.Scan() ä¼šé€è¡Œè¯»å–å†…å®¹ã€‚ ç„¶åä½¿ç”¨ Scanner.Text() æ¥è¿”å› scanner è¯»å–çš„ stringã€‚ æˆ‘ä»¬å°†å®ƒå°è£…åˆ°ä¸€ä¸ªåä¸º readLine() çš„å‡½æ•°ä¸­ã€‚\nBenchmarking - åŸºå‡†æµ‹è¯• ç”¨ go test -bench=. æ¥è¿è¡ŒåŸºå‡†æµ‹è¯•ã€‚ (å¦‚æœåœ¨ Windows Powershell ç¯å¢ƒä¸‹ä½¿ç”¨ go test -bench=\u0026quot;.\u0026quot;)\nTips: benchmarksé»˜è®¤é¡ºåºæ‰§è¡Œã€‚\n1 2 3 4 5 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u0026lt; b.N; i ++ { Repeat(\u0026#34;A\u0026#34;) } } testing.B å¯ä½¿ä½ è®¿é—®éšæ€§å‘½åï¼ˆcryptically namedï¼‰b.Nã€‚\nåŸºå‡†æµ‹è¯•è¿è¡Œæ—¶ï¼Œä»£ç ä¼šè¿è¡Œ b.N æ¬¡ï¼Œå¹¶æµ‹é‡éœ€è¦å¤šé•¿æ—¶é—´ã€‚\nä»£ç è¿è¡Œçš„æ¬¡æ•°ä¸ä¼šå¯¹ä½ äº§ç”Ÿå½±å“ï¼Œæµ‹è¯•æ¡†æ¶ä¼šé€‰æ‹©ä¸€ä¸ªå®ƒæ‰€è®¤ä¸ºçš„æœ€ä½³å€¼ï¼Œä»¥ä¾¿è®©ä½ è·å¾—æ›´åˆç†çš„ç»“æœã€‚\nGoConveyï¼ˆæµ‹è¯•æ¡†æ¶ï¼‰ 1 2 import \u0026#34;github.com/smartystreets/goconvey/convey\u0026#34; go get github.com/smartystreets/goconvey convey.Convey å®šä¹‰äº†æµ‹è¯•ç”¨ä¾‹åç§°ã€t æŒ‡é’ˆã€æµ‹è¯•ä»£ç ã€‚ convey.So` ç”¨æ¥åˆ¤æ–­é¢„æœŸç»“æœã€‚ convey æä¾›äº†å¤§é‡çš„æ–­è¨€å‡½æ•°ï¼Œæ¯”å¦‚åˆšæ‰ä½¿ç”¨çš„ convey.ShouldBeTrueï¼Œå°±æ˜¯åˆ¤æ–­ ok çš„å€¼åº”è¯¥ä¸º trueã€‚\n1 2 3 4 5 6 func TestCheckUrl(t *testing.T) { convey.Convey(\u0026#34;TestCheckTeachUrl\u0026#34;, t, func() { ok:=CheckUrl(\u0026#34;learnku.com\u0026#34;) convey.So(ok,convey.ShouldBeTrue) }) } GoConvey å®˜æ–¹æ–‡æ¡£ï¼šAssertions Â· smartystreets/goconvey Wiki Â· GitHub\nTestifyï¼ˆæ–­è¨€ï¼‰ Testify ä¹Ÿæ˜¯ä¸€ä¸ªæ–­è¨€åº“ï¼ŒåŠŸèƒ½ç›¸å¯¹äº GoConvey è€Œè¨€æ¯”è¾ƒç®€å•ï¼Œä¸»è¦æ˜¯åœ¨æä¾›æ–­è¨€åŠŸèƒ½ä¹‹å¤–ï¼Œæä¾›äº† mock çš„åŠŸèƒ½ã€‚\n1 2 import \u0026#34;github.com/stretchr/testify\u0026#34; go get -t github.com/stretchr/testify eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func TestCheckUrl3(t *testing.T) { assert := assert.New(t) var tests = []struct { input string expected bool }{ {\u0026#34;xdcute.com\u0026#34;, true}, {\u0026#34;xxx.com\u0026#34;, false}, } for _, test := range tests { fmt.Println(test.input) assert.Equal(CheckUrl(test.input), test.expected) } } GoMockï¼ˆæ¨¡æ‹Ÿæ¥å£ï¼‰ mock å·¥å…·çš„ä½œç”¨æ˜¯æŒ‡å®šå‡½æ•°çš„è¡Œä¸ºï¼ˆæ¨¡æ‹Ÿå‡½æ•°çš„è¡Œä¸ºï¼‰ã€‚å¯ä»¥å¯¹å…¥å‚è¿›è¡Œæ ¡éªŒï¼Œå¯¹å‡ºå‚è¿›è¡Œè®¾å®šï¼Œè¿˜å¯ä»¥æŒ‡å®šå‡½æ•°çš„è¿”å›å€¼ã€‚\nå¹¶è¡Œæµ‹è¯• func (b *B) RunParallel(body func(*PB))ä¼šä»¥å¹¶è¡Œçš„æ–¹å¼æ‰§è¡Œç»™å®šçš„åŸºå‡†æµ‹è¯•ã€‚\nRunParallelä¼šåˆ›å»ºå‡ºå¤šä¸ªgoroutineï¼Œå¹¶å°†b.Nåˆ†é…ç»™è¿™äº›goroutineæ‰§è¡Œï¼Œ å…¶ä¸­goroutineæ•°é‡çš„é»˜è®¤å€¼ä¸ºGOMAXPROCSã€‚ç”¨æˆ·å¦‚æœæƒ³è¦å¢åŠ éCPUå—é™ï¼ˆnon-CPU-boundï¼‰åŸºå‡†æµ‹è¯•çš„å¹¶è¡Œæ€§ï¼Œ é‚£ä¹ˆå¯ä»¥åœ¨RunParallelä¹‹å‰è°ƒç”¨SetParallelism ã€‚RunParallelé€šå¸¸ä¼šä¸-cpuæ ‡å¿—ä¸€åŒä½¿ç”¨ã€‚\nå‚è€ƒæ–‡ç«  \u0026ldquo;https://studygolang.gitbook.io/learn-go-with-tests/\u0026quot; \u0026ldquo;https://quii.gitbook.io/learn-go-with-tests/\u0026quot; ","permalink":"https://erica423.github.io/posts/singletest/","summary":"GOåœ¨çº¿ç¼–è¯‘å™¨ï¼šgo playground Test-Driven Development(TDD) - æµ‹è¯•é©±åŠ¨å¼€å‘ å‘¨æœŸï¼š ç¼–å†™ä¸€ä¸ªæµ‹è¯• è®©ç¼–è¯‘é€šè¿‡ è¿è¡Œæµ‹è¯•ï¼ŒæŸ¥çœ‹å¤±è´¥åŸå› å¹¶æ£€æŸ¥é”™è¯¯æ¶ˆæ¯æ˜¯å¾ˆæœ‰æ„ä¹‰çš„ ç¼–å†™è¶³å¤Ÿçš„ä»£ç ä»¥ä½¿æµ‹è¯•é€š","title":"å•å…ƒæµ‹è¯•"},{"content":" Go 1. åƒåœ¾å›æ”¶ (Garbage Collection) åƒåœ¾å›æ”¶å°±æ˜¯å¯¹ç¨‹åºä¸­ä¸å†ä½¿ç”¨çš„å†…å­˜èµ„æºè¿›è¡Œè‡ªåŠ¨å›æ”¶çš„æ“ä½œã€‚\nå¼•ç”¨è®¡æ•° æ ‡è®° - æ¸…é™¤ ç¼ºç‚¹ï¼šéœ€è¦STWï¼ˆstop the worldï¼‰ åˆ†ä»£æ”¶é›† GCçš„è§¦å‘æ¡ä»¶ï¼š\nä¸»åŠ¨è§¦å‘ï¼šruntime.GC è¢«åŠ¨è§¦å‘ï¼š(1)æ­¥è°ƒç®—æ³•pacing (2)ç³»ç»Ÿæ§åˆ¶ Go GCä¸‰è‰²æ ‡è®°ï¼Ÿã€ç™¾åº¦goäºŒé¢ã€‘** ä»€ä¹ˆæ˜¯GCä¸‰è‰²æ ‡è®°æ³•ï¼Ÿ ä¸€ç§åƒåœ¾å›æ”¶ç®—æ³•ï¼Œç”¨äºè¿½è¸ªå’Œæ ‡è®°æ´»è·ƒå¯¹è±¡ã€‚ä¸æ´»è·ƒçš„å°±ä¼šè¢«å›æ”¶ã€‚\nä¸‰è‰²æ ‡è®°æ³•è§„åˆ™ï¼Ÿ é»‘ï¼šå®Œå…¨æ ‡è®°ï¼Œç¡®å®šæ´»è·ƒï¼Œä¸ä¼šå›æ”¶\nç™½ï¼šåˆæ€ï¼Œæœªæ ‡è®°å’Œè¿½è¸ªï¼Œæœ€åè¢«å›æ”¶\nç°ï¼šè¢«å‘ç°ä½†æœªå®Œå…¨è¿½è¸ª\nåˆå§‹çŠ¶æ€ä¸‹æ‰€æœ‰å¯¹è±¡éƒ½æ˜¯ç™½è‰²çš„ã€‚GCå¼€å§‹ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†æ‰€æœ‰å¯¹è±¡ï¼Œå°†ç›´æ¥å¯è¾¾çš„å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼›\néå†ç°è‰²é›†åˆï¼Œç°è‰²å¯¹è±¡ç›´æ¥å¯è¾¾çš„å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼Œè‡ªèº«æ ‡è®°ä¸ºé»‘è‰²ï¼›\né€šè¿‡ å†™å±éšœ(write-barrier) æ£€æµ‹å¯¹è±¡æœ‰å˜åŒ–ï¼Œé‡å¤2ï¼Œç›´åˆ°ç°è‰²å¯¹è±¡å…¨éƒ¨å˜æˆé»‘è‰²ï¼›\nå›æ”¶ç™½è‰²å¯¹è±¡(åƒåœ¾)\nä»€ä¹ˆæ˜¯å¼ºå¼±ä¸‰è‰²ä¸å˜å¼ï¼Ÿ å¼ºä¸‰è‰²ä¸å˜å¼ï¼šä¸å­˜åœ¨é»‘è‰²å¯¹è±¡å¼•ç”¨ç™½è‰²å¯¹è±¡ï¼›\nå¼±ä¸‰è‰²ï¼šæ‰€æœ‰è¢«é»‘è‰²å¼•ç”¨çš„ç™½è‰²å¿…é¡»æœ‰ç°è‰²ä¸Šæ¸¸å¯¹è±¡ï¼›\nç›®çš„ï¼šä»–ä»¬éƒ½è§£å†³çš„éƒ½æ˜¯æ¼æ ‡é—®é¢˜ï¼ˆé»‘å¯¹ç™½çš„å¼•ç”¨)\nä»€ä¹ˆæ˜¯å†™å±éšœï¼Ÿ åœ¨ç‰¹å®šç¨‹åºè¿è¡Œæ—¶åˆ»ï¼Œå½“å¯¹å¯¹è±¡çš„æŒ‡é’ˆè¿›è¡Œå†™æ“ä½œï¼ˆä¿®æ”¹å¼•ç”¨å…³ç³»ï¼‰æ—¶è§¦å‘çš„å¤„ç†æœºåˆ¶ã€‚ç›®çš„æ˜¯ç¡®ä¿GCè¿‡ç¨‹èƒ½æ­£ç¡®è¿½è¸ªå¯¹è±¡çš„å¼•ç”¨å…³ç³»ï¼Œé˜²æ­¢é”™è¯¯æˆ–é—æ¼å›æ”¶ï¼Œä»…ä½œç”¨äºå †ä¸Šçš„å†…å­˜å›æ”¶ã€‚\næ’å…¥å†™å±éšœï¼šå¦‚æœæœ‰é»‘æŒ‡ç™½ï¼Œåˆ™æŠŠç™½å˜ç°ï¼›\nåˆ é™¤å†™å±éšœï¼šå½“ç°è‰²åˆ é™¤ä¸€ä¸ªæŒ‡å‘ç™½è‰²çš„å…³ç³»ï¼Œç™½è‰²æ ‡è®°ä¸ºç°è‰²ã€‚\nä»€ä¹ˆæ˜¯æ··åˆå†™å±éšœï¼Ÿ\næ’å…¥+åˆ é™¤:\nåœ¨GCå¼€å§‹æ—¶å°†æ ˆä¸Šå¯¹è±¡å…¨éƒ¨æ‰«æå¹¶æ ‡è®°ä¸ºé»‘è‰²ï¼ˆä¸è¿›è¡ŒäºŒæ¬¡scanï¼‰ åœ¨GCæœŸé—´ä»»ä½•æ ˆä¸Šåˆ›å»ºçš„å¯¹è±¡éƒ½æ ‡è®°ä¸ºé»‘è‰²ï¼Œé¿å…äºŒæ¬¡scan åœ¨GCæœŸé—´åˆ é™¤ä»»ä½•çš„å¯¹è±¡éƒ½æ ‡è®°ä¸ºç°è‰² åœ¨GCæœŸé—´åˆ›å»ºçš„ä»»ä½•å¯¹è±¡éƒ½æ ‡è®°ä¸ºç°è‰² æ ˆåŒºæ²¡æœ‰å†™å±éšœé€»è¾‘ï¼ŒåŠ é‡è¿è¡Œè´Ÿæ‹…ï¼›æŠŠæ–°åŠ è¿›æ ˆçš„ç›´æ¥æ ‡æˆé»‘è‰²ï¼ˆå‡å°‘stwæ¬¡æ•°ï¼‰\nä¸ºä»€ä¹ˆé¢è¯•ä¼šé—®è¿™ä¸ªï¼Ÿ\nåŸºæœ¬ç”¨ä¸åˆ°ï¼Œå¯èƒ½å°±è°ƒè°ƒå‚æ•°å›æ”¶æ—¶é—´ç­‰ã€‚\nSTW (Stop The World) ä¸ºäº†é¿å…åœ¨åƒåœ¾å›æ”¶ (GC) çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹è±¡ä¹‹é—´çš„å¼•ç”¨å…³ç³»å‘ç”Ÿæ–°çš„å˜æ›´ï¼Œä½¿GCçš„ç»“æœå‘ç”Ÿé”™è¯¯ï¼Œåœæ­¢æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„åç¨‹ã€‚ STWå¯¹æ€§èƒ½æœ‰ä¸€äº›å½±å“ï¼Œä½†goç›®å‰å·²ç»å¯ä»¥åšåˆ°1msä»¥ä¸‹çš„STWã€‚ å†™å±éšœ (Write Barrier) ä¸ºäº†å‡å°STWå¯¹ç¨‹åºçš„å½±å“ï¼Œè¦é€šè¿‡å†™å±éšœå°½å¯èƒ½ç¼©çŸ­STWæ—¶é—´ã€‚\né€ æˆå¼•ç”¨å¯¹è±¡ä¸¢å¤±çš„æ¡ä»¶: ä¸€ä¸ªé»‘è‰²çš„èŠ‚ç‚¹Aæ–°å¢äº†æŒ‡å‘ç™½è‰²èŠ‚ç‚¹Cçš„å¼•ç”¨ï¼Œå¹¶ä¸”ç™½è‰²èŠ‚ç‚¹Cæ²¡æœ‰é™¤äº†Aä¹‹å¤–çš„å…¶ä»–ç°è‰²èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œæˆ–è€…å­˜åœ¨ä½†æ˜¯åœ¨GCè¿‡ç¨‹ä¸­è¢«åˆ é™¤äº†ã€‚ä»¥ä¸Šä¸¤ä¸ªæ¡ä»¶éœ€è¦åŒæ—¶æ»¡è¶³ï¼šæ»¡è¶³æ¡ä»¶1æ—¶è¯´æ˜èŠ‚ç‚¹Aå·²æ‰«æå®Œæ¯•ï¼ŒAæŒ‡å‘Cçš„å¼•ç”¨æ— æ³•å†è¢«æ‰«æåˆ°ï¼›æ»¡è¶³æ¡ä»¶2æ—¶è¯´æ˜ç™½è‰²èŠ‚ç‚¹Cæ— å…¶ä»–ç°è‰²èŠ‚ç‚¹çš„å¼•ç”¨äº†ï¼Œå³æ‰«æç»“æŸåä¼šè¢«å¿½ç•¥ ã€‚\nå†™å±éšœç ´åä¸¤ä¸ªæ¡ä»¶å…¶ä¸€å³å¯\nç ´åæ¡ä»¶1ï¼šDijistraå†™å±éšœ\næ»¡è¶³å¼ºä¸‰è‰²ä¸å˜æ€§ï¼šé»‘è‰²èŠ‚ç‚¹ä¸å…è®¸å¼•ç”¨ç™½è‰²èŠ‚ç‚¹ å½“é»‘è‰²èŠ‚ç‚¹æ–°å¢äº†ç™½è‰²èŠ‚ç‚¹çš„å¼•ç”¨æ—¶ï¼Œå°†å¯¹åº”çš„ç™½è‰²èŠ‚ç‚¹æ”¹ä¸ºç°è‰²\nç ´åæ¡ä»¶2ï¼šYuasaå†™å±éšœ æ»¡è¶³å¼±ä¸‰è‰²ä¸å˜æ€§ï¼šé»‘è‰²èŠ‚ç‚¹å…è®¸å¼•ç”¨ç™½è‰²èŠ‚ç‚¹ï¼Œä½†æ˜¯è¯¥ç™½è‰²èŠ‚ç‚¹æœ‰å…¶ä»–ç°è‰²èŠ‚ç‚¹é—´æ¥çš„å¼•ç”¨ï¼ˆç¡®ä¿ä¸ä¼šè¢«é—æ¼ï¼‰ å½“ç™½è‰²èŠ‚ç‚¹è¢«åˆ é™¤äº†ä¸€ä¸ªå¼•ç”¨æ—¶ï¼Œæ‚²è§‚åœ°è®¤ä¸ºå®ƒä¸€å®šä¼šè¢«ä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹æ–°å¢å¼•ç”¨ï¼Œæ‰€ä»¥å°†å®ƒç½®ä¸ºç°è‰²\nselectå¯ä»¥ç”¨äºä»€ä¹ˆï¼Ÿ golang çš„ select å°±æ˜¯ç›‘å¬ IO æ“ä½œï¼Œå½“ IO æ“ä½œå‘ç”Ÿæ—¶ï¼Œè§¦å‘ç›¸åº”çš„åŠ¨ä½œã€‚æ¯ä¸ªcaseè¯­å¥é‡Œå¿…é¡»æ˜¯ä¸€ä¸ªé¢å‘channelçš„IOæ“ä½œã€‚\nGoå‡½æ•°ä¸­ä¸ºä»€ä¹ˆå‘ç”Ÿå†…å­˜æ³„æ¼ï¼Ÿ goroutineéœ€è¦ç»´æŠ¤æ‰§è¡Œç”¨æˆ·ä»£ç çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œåœ¨è¿è¡Œè¿‡ç¨‹ä¸­éœ€è¦æ¶ˆè€—ä¸€å®šçš„å†…å­˜æ¥ä¿å­˜è¿™ç±»ä¿¡æ¯ã€‚å¦‚æœä¸€ä¸ªç¨‹åºæŒç»­ä¸æ–­åœ°äº§ç”Ÿæ–°çš„goroutineä¸”ä¸ç»“æŸå·²åˆ›å»ºçš„goroutineå¹¶å¤ç”¨è¿™éƒ¨åˆ†å†…å­˜ï¼Œå°±ä¼šé€ æˆå†…å­˜æ³„æ¼ã€‚\nGoroutineå‘ç”Ÿäº†æ³„æ¼å¦‚ä½•æ£€æµ‹ï¼Ÿ Goè‡ªå¸¦çš„å·¥å…·pprofæˆ–è€…ä½¿ç”¨Gopsæ£€æµ‹è¯Šæ–­å½“å‰åœ¨ç³»ç»Ÿä¸Šè¿è¡Œçš„goè¿›ç¨‹å ç”¨çš„èµ„æºã€‚\nGoå†…å­˜å¯¹é½ï¼Ÿ CPUè®¿é—®å†…å­˜æ—¶ï¼Œä¸æ˜¯é€ä¸ªå­—èŠ‚è®¿é—®ï¼Œè€Œæ˜¯ä»¥å­—é•¿(word size)ä¸ºå•ä½è¿›è¡Œè®¿é—®ã€‚å¦‚32ä½çš„CPUï¼Œå­—é•¿ä¸º4å­—èŠ‚ï¼Œé‚£ä¹ˆCPUè®¿é—®å†…å­˜çš„å•ä½ä¹Ÿæ˜¯4å­—èŠ‚ã€‚\nCPUå§‹ç»ˆä»¥å­—é•¿è®¿é—®å†…å­˜ï¼Œå¦‚æœä¸è¿›è¡Œå†…å­˜å¯¹é½ï¼Œå¾ˆå¯èƒ½å¢åŠ CPUè®¿é—®å†…å­˜çš„æ¬¡æ•°ã€‚\nå¯ä»¥çœ‹åˆ°ï¼Œå†…å­˜å¯¹é½å¯¹å®ç°å˜é‡çš„åŸå­æ€§æ“ä½œä¹Ÿæ˜¯æœ‰å¥½å¤„çš„ï¼Œæ¯æ¬¡å†…å­˜è®¿é—®æ˜¯åŸå­çš„ã€‚å¦‚æœå˜é‡çš„å¤§å°ä¸è¶…è¿‡å­—é•¿ï¼Œé‚£ä¹ˆå†…å­˜å¯¹é½åï¼Œå¯¹è¯¥å˜é‡çš„è®¿é—®å°±æ˜¯åŸå­çš„ï¼Œè¿™ä¸ªç‰¹æ€§åœ¨å¹¶å‘åœºæ™¯ä¸‹è‡³å…³é‡è¦ã€‚\nåˆç†çš„å†…å­˜å¯¹é½å¯ä»¥æé«˜å†…å­˜è¯»å†™çš„æ€§èƒ½ï¼Œå¹¶ä¸”ä¾¿äºå®ç°å˜é‡æ“ä½œçš„åŸå­æ€§ã€‚\nGoå‡½æ•°ä¼ å‚æ˜¯å€¼ç±»å‹è¿˜æ˜¯å¼•ç”¨ç±»å‹ï¼Ÿ Goä¸­åªå­˜åœ¨å€¼ä¼ é€’ï¼Œè¦ä¹ˆä¼ çš„æ˜¯å€¼çš„å‰¯æœ¬ï¼Œè¦ä¹ˆæ˜¯æŒ‡é’ˆçš„å‰¯æœ¬ã€‚æ— è®ºæ˜¯å€¼ç±»å‹çš„å˜é‡è¿˜æ˜¯å¼•ç”¨ç±»å‹çš„å˜é‡è¿˜æ˜¯æŒ‡é’ˆç±»å‹çš„å˜é‡ï¼Œåœ¨ä½œä¸ºå‚æ•°ä¼ é€’æ—¶éƒ½ä¼šå‘ç”Ÿcopyï¼Œå¼€è¾Ÿæ–°çš„å†…å­˜ç©ºé—´ã€‚\nå¦å¤–å€¼ä¼ é€’ã€å¼•ç”¨ä¼ é€’å’Œå€¼ç±»å‹ã€å¼•ç”¨ç±»å‹æ˜¯ä¸¤ä¸ªä¸åŒçš„æ¦‚å¿µï¼Œä¸è¦æ··æ·†äº†ã€‚å¼•ç”¨ç±»å‹ä½œä¸ºå˜é‡ä¼ é€’å¯ä»¥å½±å“åˆ°å‡½æ•°å¤–éƒ¨æ˜¯å› ä¸ºå‘ç”Ÿå€¼æ‹·è´åæ–°æ—§å˜é‡æŒ‡å‘äº†ç›¸åŒçš„å†…å­˜åœ°å€ã€‚\nGoä¸»åç¨‹å¦‚ä½•ç­‰å…¶ä½™åç¨‹ç»“æŸå†æ“ä½œï¼Ÿ ä½¿ç”¨sync.WaitGroupï¼Œç”¨æ¥ç­‰å¾…ä¸€ç»„æ“ä½œå®Œæˆã€‚WaitGroupå†…éƒ¨å®ç°äº†ä¸€ä¸ªè®¡æ•°å™¨ï¼Œç”¨æ¥è®°å½•æœªå®Œæˆçš„æ“ä½œä¸ªæ•°ï¼›Add()ç”¨æ¥æ·»åŠ è®¡æ•°ï¼›Done()ç”¨æ¥åœ¨æ“ä½œç»“æŸæ—¶è°ƒç”¨ï¼Œä½¿è®¡æ•°-1ï¼› Wait()ç”¨æ¥ç­‰å¾…æ‰€æœ‰çš„æ“ä½œç»“æŸï¼Œåœ¨è®¡æ•°ä¸ä¸º0æ—¶ç­‰å¾…ï¼Œä¸º0æ—¶ç«‹å³è¿”å›ã€‚\n","permalink":"https://erica423.github.io/posts/question/","summary":"Go 1. åƒåœ¾å›æ”¶ (Garbage Collection) åƒåœ¾å›æ”¶å°±æ˜¯å¯¹ç¨‹åºä¸­ä¸å†ä½¿ç”¨çš„å†…å­˜èµ„æºè¿›è¡Œè‡ªåŠ¨å›æ”¶çš„æ“ä½œã€‚ å¼•ç”¨è®¡æ•° æ ‡è®° - æ¸…é™¤ ç¼ºç‚¹ï¼šéœ€è¦STWï¼ˆstop the worldï¼‰ åˆ†ä»£æ”¶é›†","title":"Q\u0026A | é¢ç»"},{"content":"goè¯­è¨€sliceå’Œmapåº•å±‚å®ç°åŸç† sliceå’Œmapéƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œé•¿åº¦ä¸å›ºå®šã€‚\nsliceåº•å±‚ï¼š sliceæŒ‡å‘ä¸€ä¸ªåº•å±‚arrayï¼Œå£°æ˜æ—¶ä¸éœ€è¦æŒ‡å®šé•¿åº¦ã€‚\nappendå‡½æ•°ä¼šæ”¹å˜sliceæ‰€å¼•ç”¨çš„æ•°ç»„çš„å†…å®¹ï¼Œä»è€Œå½±å“åˆ°å¼•ç”¨åŒä¸€æ•°ç»„çš„å…¶å®ƒsliceã€‚ ä½†å½“sliceä¸­æ²¡æœ‰å‰©ä½™ç©ºé—´ï¼ˆå³(cap-len) == 0æ—¶ï¼Œæ­¤æ—¶å°†åŠ¨æ€åˆ†é…æ–°çš„æ•°ç»„ç©ºé—´ã€‚è¿”å›çš„sliceæ•°ç»„æŒ‡é’ˆå°†æŒ‡å‘è¿™ä¸ªç©ºé—´ï¼Œè€ŒåŸæ•°ç»„çš„å†…å®¹å°†ä¿æŒä¸å˜ï¼›å…¶å®ƒå¼•ç”¨æ­¤æ•°ç»„çš„sliceåˆ™ä¸å—å½±å“ã€‚\nmapåº•å±‚ï¼š mapçš„è¯»å–å’Œè®¾ç½®ä¹Ÿç±»ä¼¼sliceä¸€æ ·ï¼Œé€šè¿‡keyæ¥æ“ä½œï¼Œåªæ˜¯sliceçš„indexåªèƒ½æ˜¯intç±»å‹ï¼Œè€Œmapå¤šäº†å¾ˆå¤šç±»å‹ï¼Œå¯ä»¥æ˜¯intï¼Œå¯ä»¥æ˜¯stringåŠæ‰€æœ‰å®Œå…¨å®šä¹‰äº†==ä¸!=æ“ä½œçš„ç±»å‹ã€‚\nmapæ˜¯æ— åºçš„ï¼Œå¦‚ä½•mapè¿›è¡Œæœ‰åºçš„æ’åºï¼Ÿ å¼€ä¸€ä¸ªç©ºåˆ‡ç‰‡ï¼ŒæŠŠkeyæ‹¿å‡ºæ¥ï¼Œå¯¹keyè¿›è¡Œæ’åºï¼Œå†æŒ‰æ’å¥½åºçš„keyä¸­mapä¸­æ‹¿valueã€‚\nsliceçš„æ‰©å®¹æœºåˆ¶ åœ¨ä½¿ç”¨ append å‘ slice è¿½åŠ å…ƒç´ æ—¶ï¼Œè‹¥ slice ç©ºé—´ä¸è¶³åˆ™ä¼šå‘ç”Ÿæ‰©å®¹ï¼Œæ‰©å®¹ä¼šé‡æ–°åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ï¼Œå°†åŸ slice æ‹·è´åˆ°æ–° slice ï¼Œç„¶åè¿”å›æ–° sliceã€‚æ‰©å®¹åå†å°†æ•°æ®è¿½åŠ è¿›å»ã€‚\næ‰©å®¹æ“ä½œåªå¯¹å®¹é‡ï¼Œæ‰©å®¹åçš„ slice é•¿åº¦ä¸å˜ï¼Œå®¹é‡å˜åŒ–è§„åˆ™å¦‚ä¸‹ï¼š\n1.18ç‰ˆæœ¬ä¹‹å‰ï¼šè‹¥ slice å®¹é‡å°äº1024ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæ‰©å®¹çš„æ—¶å€™sliceçš„capå°±ç¿»ç•ªï¼Œä¹˜ä»¥2ï¼›ä¸€æ—¦å…ƒç´ ä¸ªæ•°è¶…è¿‡1024ä¸ªå…ƒç´ ï¼Œå¢é•¿å› å­å°±å˜æˆ1.25ï¼Œå³æ¯æ¬¡å¢åŠ åŸæ¥å®¹é‡çš„å››åˆ†ä¹‹ä¸€ã€‚ è‹¥ slice å®¹é‡å¤Ÿç”¨ï¼Œåˆ™å°†æ–°å…ƒç´ è¿½åŠ è¿›å»ï¼Œslice.len++ï¼Œè¿”å›åŸ slice è‹¥ slice å®¹é‡ä¸å¤Ÿç”¨ï¼Œå°† slice å…ˆæ‰©å®¹ï¼Œæ‰©å®¹å¾—åˆ°æ–° sliceï¼Œå°†æ–°å…ƒç´ è¿½åŠ è¿›æ–° sliceï¼Œslice.len++ï¼Œè¿”å›æ–° sliceã€‚ ä¾‹å¦‚ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { s1 := make([]int64, 0) for i := 0; i \u0026lt; 1025; i++ { s1 = append(s1, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s1), cap(s1)) // output: len = 1025, cap = 1280 s2 := make([]int32, 0) for i := 0; i \u0026lt; 1025; i++ { s2 = append(s2, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s2), cap(s2)) // output: len = 1025, cap = 1344 } åŸå› æ˜¯golangåº“ä¸‹runtime/slice.goä¸­çš„growsliceå‡½æ•°çš„é€»è¾‘ã€‚æ ¸å¿ƒæ˜¯ååŠçš„å†…å­˜å¯¹é½ã€‚switchçš„å‡ ä¸ªcaseåˆ†æ”¯ï¼Œå°±æ˜¯é’ˆå¯¹ä¸åŒç±»å‹çš„sliceã€‚ä»¥et.size == sys.PtrSizeåˆ†æ”¯ä¸ºä¾‹ï¼Œå…¶æ€æƒ³å°±æ˜¯é¦–å…ˆè®¡ç®—å‡ºsliceçš„å†…å­˜å¤§å°ï¼Œç„¶åè°ƒç”¨roundupsizeå‡½æ•°å†…å­˜å¯¹é½ï¼Œç„¶åè®¡ç®—å‡ºæœ€ç»ˆçš„å®¹é‡ã€‚\nroundupsizeå‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var size_to_class8 = [1024/8 + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var class_to_size = [68]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} func roundupsize(size uintptr) uintptr { if size \u0026lt; _MaxSmallSize { // 32Kå†…å­˜ä»¥å†… // class_to_size 68ä¸ªä¸åŒçš„å†…å­˜é•¿åº¦ï¼ˆåŒ…å«0ï¼‰ï¼Œå¯¹åº”runtime/sizeclasses.goä¸­è¡¨æ ¼ // å½“å°äºç­‰äº1016æ—¶ï¼Œä»size_to_class8ä¸­æ‰¾ï¼Œç»“æœæ—¶1åˆ°32ï¼Œå¯¹åº”class_to_sizeä¸­çš„index // å¦åˆ™ä»size_to_class128ä¸­æ‰¾ï¼Œç»“æœæ˜¯32åˆ°68ã€‚ æœ€ç»ˆéƒ½æ˜¯æ ¹æ®indexåˆ°class_to_sizeä¸­æœ€ç»ˆçš„ç»“æœã€‚ // å…¶ä½œç”¨å°±æ˜¯67ä¸ªå†…å­˜é•¿åº¦ä¸­æ‰¾åˆ°å¤§äºç­‰äºsizeçš„æœ€æ¥è¿‘çš„é•¿åº¦ã€‚ åº”è¯¥æ˜¯ä¸ºäº†æ•ˆç‡è€ƒè™‘ï¼Œç›´æ¥æŸ¥çš„æ–¹å¼ï¼Œæ¯”æŒ¨ä¸ªæ¯”è¾ƒçš„æ•ˆç‡æ›´é«˜ã€‚ç©ºé—´æ¢æ—¶é—´ if size \u0026lt;= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { fmt.Println(divRoundUp(size-smallSizeMax, largeSizeDiv)) return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } if size+_PageSize \u0026lt; size { // è¿™ç§æƒ…å†µåªä¼šå‘ç”Ÿåœ¨æº¢å‡ºæ—¶ï¼Œå˜æˆè´Ÿæ•°äº† return size } return alignUp(size, _PageSize) } // æŒ‰8192çš„å€æ•°å‘ä¸Šå–æ•´ï¼Œé‡‡ç”¨ä½è¿ç®—çš„æ–¹å¼ï¼Œæ›´åŠ é«˜æ•ˆ func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026amp;^ (a - 1) } åˆ°è¿™é‡Œå°±å¯ä»¥è§£é‡Šint32çš„åˆ‡ç‰‡æ‰©å®¹åä¸ºä»€ä¹ˆæ˜¯1344äº†:\næ­£å¸¸æƒ…å†µä¸‹ï¼ŒæŒ‰ç…§1.25è¢«æ‰©å®¹åï¼Œå®¹é‡ä¸º1024 * 1.25 = 1280; int32å 4å­—èŠ‚ï¼Œå…¶åˆ‡ç‰‡å†…å­˜å¤§å°ä¸ºï¼Œ1280 * 4 = 5120; é€šè¿‡æŸ¥ä¸‹é¢çš„è¡¨ï¼Œå¯ä»¥å¾—å‡ºå¤§äºç­‰äº5120çš„æœ€æ¥è¿‘çš„æ˜¯5376; æœ€ç»ˆçš„å®¹é‡ä¸º 5376 / 4 = 1344 åŒæ ·ï¼Œä¹Ÿå¯ä»¥ç®—å‡ºint64çš„åˆ‡ç‰‡å†…å­˜å¯¹é½åï¼Œå’ŒåŸæ¥æ˜¯æ²¡æœ‰å˜åŒ–ï¼Œä»ç„¶æ˜¯1280ã€‚ç®€å•è®¡ç®—ä¸‹ï¼š\n1280 * 8 = 10240; æŸ¥è¡¨ä»ç„¶æ˜¯10240 10240 / 8 = 1280ã€‚æ‰€ä»¥æ²¡æœ‰å˜åŒ–ã€‚ go 1.18ç‰ˆæœ¬åçš„ä¿®æ”¹ å°äº256æ—¶ï¼ŒåŒå€æ‰©å®¹ï¼›å¤§äºç­‰äº256æ—¶ï¼Œæ‰©å®¹åå®¹é‡ = 1.25å€çš„åŸå®¹é‡ + 192ã€‚ç›®çš„ä¸»è¦ä¸ºäº†æ˜¯å†…å­˜çš„å˜åŒ–æ›´åŠ å¹³æ»‘ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func growslice(et *_type, old slice, cap int) slice { // çœç•¥ã€‚ã€‚ã€‚ newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } // çœç•¥ã€‚ã€‚ã€‚ } è¡¥å……ï¼š int ç±»å‹å¤§å°ä¸º 8 å­—èŠ‚, goè¯­è¨€ä¸­çš„intçš„å¤§å°æ˜¯å’Œæ“ä½œç³»ç»Ÿä½æ•°ç›¸å…³çš„ï¼Œå¦‚æœæ˜¯32ä½æ“ä½œç³»ç»Ÿï¼Œintç±»å‹çš„å¤§å°å°±æ˜¯4å­—èŠ‚; å¦‚æœæ˜¯64ä½æ“ä½œç³»ç»Ÿï¼Œintç±»å‹çš„å¤§å°å°±æ˜¯8ä¸ªå­—èŠ‚\nint8 ç±»å‹å¤§å°ä¸º 1 å­—èŠ‚\nint16 ç±»å‹å¤§å°ä¸º 2 å­—èŠ‚\nint32 ç±»å‹å¤§å°ä¸º 4 å­—èŠ‚\nint64 ç±»å‹å¤§å°ä¸º 8 å­—èŠ‚\nå–å€¼èŒƒå›´\nint8: -128 ~ 127\nint16: -32768 ~ 32767\nint32: -2147483648 ~ 2147483647\nint64: -9223372036854775808 ~ 9223372036854775807\nç»“æ„ä½“é‡Œçš„å˜é‡ä¸åŠ tagå¯ä»¥è½¬jsonå­—ç¬¦ä¸²å—ï¼Ÿ å¦‚æœå˜é‡é¦–å­—æ¯å°å†™ï¼Œå³ä¸ºprivateå˜é‡ï¼Œæ— è®ºåŠ ä¸åŠ tagéƒ½ä¸å¯èƒ½è½¬ä¸ºjsonå­—æ®µï¼Œå› ä¸ºè·å–ä¸åˆ°åå°„ä¿¡æ¯ã€‚ åå°„ï¼Ÿ\nå¦‚æœå˜é‡é¦–å­—æ¯å¤§å†™ï¼Œä¸ºpublicå˜é‡ï¼š ä¸åŠ tagï¼šå¯ä»¥è½¬ï¼Œjsonå†…å­—æ®µåå’Œç»“æ„ä½“å†…å­—æ®µåŸåä¸€è‡´ï¼› åŠ tagï¼Œè½¬jsonçš„å­—æ®µåå°±æ˜¯tagé‡Œçš„å­—æ®µåï¼ˆä¹Ÿå°±æ˜¯åˆ«åï¼‰ã€‚ ç”Ÿæˆjsonï¼šjsonInfo, err := json.Marshal(struct_J)\nå±•ç¤ºjsonå†…å®¹ï¼šstring(jsonInfo)\njsonå¯¹è±¡åªæ”¯æŒstringä½œä¸ºkeyã€‚channelã€complexã€functionä¸èƒ½è¢«ç¼–ç æˆjsonã€‚\ngoè¯­è¨€TCPã€UDPå…·ä½“å®ç°åŸç† TCP (Transmission Connect Protocol, ä¼ è¾“æ§åˆ¶åè®®) é¢å‘è¿æ¥çš„ã€å¯é çš„ã€åŸºäºå­—èŠ‚æµçš„ä¼ è¾“å±‚é€šä¿¡åè®®ã€‚æä¾›äº†å…¨åŒå·¥é€šä¿¡ã€æµé‡æ§åˆ¶ã€é”™è¯¯æ§åˆ¶ç­‰åŠŸèƒ½ã€‚\nTCPåŸºæœ¬åŸç†ï¼š ä¸‰æ¬¡æ¡æ‰‹ï¼šé€šè¿‡ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹TCPè¿æ¥ã€‚ (1) clientå‘serverå‘é€SYNåŒ…ï¼Œè¯·æ±‚è¿æ¥ï¼›\n(2) serveræ”¶åˆ°SYNåŒ…ï¼Œå‘clientå‘é€SYN+ACKåŒ…ï¼ŒåŒæ„è¿æ¥å¹¶ç¡®è®¤clientçš„SYNåŒ…ï¼›\n(3) clientæ”¶åˆ°SYN+ACKåŒ…åï¼Œå‘serverå‘é€ACKåŒ…ï¼Œç¡®è®¤è¿æ¥ã€‚\nå››æ¬¡æŒ¥æ‰‹ï¼šé€šè¿‡å››æ¬¡æŒ¥æ‰‹æ–­å¼€TCPè¿æ¥ã€‚ (1) clientå‘serverå‘é€FINåŒ…ï¼Œè¡¨ç¤ºä¸å†å‘é€æ•°æ®ï¼›\n(2) serveræ”¶åˆ°FINåŒ…ï¼Œå‘clientå‘é€ACKåŒ…ï¼Œç¡®è®¤æ”¶åˆ°FINåŒ…ï¼›\n(3) serverå‘clientå‘é€FINåŒ…ï¼Œè¡¨ç¤ºä¸å†æ¥æ”¶æ•°æ®ï¼›\n(4) clientæ”¶åˆ°FINåŒ…åï¼Œå‘serverå‘é€ACKåŒ…ï¼Œç¡®è®¤æ–­è¿ã€‚\næµé‡æ§åˆ¶ï¼šTCPä½¿ç”¨æ»‘åŠ¨çª—å£æœºåˆ¶è¿›è¡Œæµé‡æ§åˆ¶ã€‚ serverå‘clientå‘é€æ•°æ®æ—¶ï¼Œéœ€è¦è€ƒè™‘clientçš„æ¥æ”¶èƒ½åŠ›ï¼Œé¿å…æ•°æ®æº¢å‡ºã€‚\né”™è¯¯æ§åˆ¶ï¼šTCPä½¿ç”¨ACKå’ŒNACKæœºåˆ¶è¿›è¡Œé”™è¯¯æ§åˆ¶ã€‚ å½“clientæ”¶åˆ°serverå‘é€çš„æ•°æ®æ—¶ï¼Œéœ€è¦å‘é€ACKåŒ…ç¡®è®¤ã€‚å¦‚æœæ”¶åˆ°çš„æ•°æ®æœ‰é”™ï¼Œå°±å‘é€NACKåŒ…ã€‚\nUDP (User Datagram Protocol, ç”¨æˆ·æ•°æ®æŠ¥åè®®) é¢å‘äº‹åŠ¡çš„ã€æ— è¿æ¥ã€ä¸å¯é çš„ä¼ è¾“å±‚é€šä¿¡åè®®ã€‚ æä¾›äº†ç®€å•å¿«é€Ÿçš„æ•°æ®ä¼ è¾“åŠŸèƒ½ã€‚\nUDPåŸºæœ¬åŸç†ï¼š æ— è¿æ¥ï¼šUDPä¸éœ€è¦å»ºç«‹è¿æ¥ï¼Œæ•°æ®åŒ…ç›´æ¥å‘é€åˆ°ç›®çš„åœ°å€ã€‚ ä¸å¯é ï¼šä¸æä¾›å¯é æ€§ä¿è¯ï¼Œæ•°æ®åŒ…å¯èƒ½ä¸¢å¤±ã€é”™è¯¯æˆ–é‡å¤ã€‚ ç®€å•å¿«é€Ÿï¼šUDPæ•°æ®åŒ…çš„headåªæœ‰8 byteï¼Œç›¸å¯¹äºTCPçš„20byte headæ›´åŠ ç®€å•å¿«é€Ÿã€‚ Goè¯­è¨€çš„ç½‘ç»œç¼–ç¨‹ä¸»è¦æ¶‰åŠä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼š netåŒ…ï¼šGoè¯­è¨€æä¾›äº†netåŒ…ï¼Œç”¨äºå®ç°ç½‘ç»œç¼–ç¨‹ã€‚netåŒ…æä¾›äº†TCP/UDPçš„åŸºæœ¬åŠŸèƒ½ï¼ŒåŒ…æ‹¬åˆ›å»ºã€ç›‘å¬ã€è¿æ¥ã€è¯»å†™ç­‰\nconnï¼šconnæ˜¯netåŒ…ä¸­çš„ä¸€ä¸ªç±»å‹ï¼Œè¡¨ç¤ºä¸€ä¸ªç½‘ç»œè¿æ¥ã€‚connåŒ…å«äº†è¿æ¥çš„ä¸¤ç«¯çš„åœ°å€å’Œæ•°æ®ç¼“å†²åŒºã€‚\nioåŒ…ï¼šGoè¯­è¨€çš„ioåŒ…æä¾›äº†ä¸€ç³»åˆ—çš„è¯»å†™å™¨æ¥å£ï¼Œç”¨äºå®ç°å„ç§æ•°æ®æµæ“ä½œã€‚ç½‘ç»œç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä½¿ç”¨ioåŒ…çš„Readerå’ŒWriteræ¥å£æ¥å¤„ç†ç½‘ç»œæ•°æ®ã€‚\nbufioåŒ…ï¼šbufioåŒ…æä¾›äº†åŸºäºç¼“å†²çš„I/OåŠŸèƒ½ï¼Œå¯ä»¥æé«˜ç½‘ç»œç¼–ç¨‹çš„æ€§èƒ½ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨bufioåŒ…çš„Readerå’ŒWriteræ¥å®ç°é«˜æ•ˆçš„ç½‘ç»œæ•°æ®å¤„ç†ã€‚\nTCPï¼šä½¿ç”¨ net.Dial/ net.Listen / conn.Write / conn.Read ç­‰ UDPï¼šä½¿ç”¨ net.Dial / net.Listen / conn.Write / conn.ReadFrom / conn.SetReadDeadline é—®ï¼šnet.Listenå’Œnet.ListenTCPandnet.ListenUDPæœ‰å•¥åŒºåˆ«ï¼Ÿï¼Ÿ\nnet.Listen()è¿”å›ä¸€ä¸ªæ¥å£net.Listenerï¼Œè¯¥æ¥å£åªä¿è¯å®ƒæ”¯æŒä»¥ä¸‹æ–¹æ³•ï¼šAccept()ã€Close()å’ŒAddr()ã€‚\nnet.ListenTCP()è¿”å›ä¸€ä¸ªæ”¯æŒä¸Šè¿°ä¸‰ç§æ–¹æ³•çš„ç±»å‹*net.TCPListenerï¼Œå› æ­¤(é¸­å­ç±»å‹duckTyping)å®ƒæ”¯æŒnet.Listeneræ¥å£ã€‚ä½†æ˜¯ï¼Œå®ƒè¿˜æ”¯æŒæ›´å¤šç‰¹å®šäºTCPçš„åŠŸèƒ½ï¼Œå¹¶ä¸”å¯ä»¥æ§åˆ¶è¿æ¥æ¥å—çš„ä½çº§åˆ«æ–¹é¢ã€‚åƒè®¾ç½®SetDeadline()ä¹‹ç±»çš„äº‹æƒ…ã€‚\nä½¿ç”¨åœºæ™¯ WebæœåŠ¡ï¼šä½¿ç”¨net/httpåŒ…æ„å»ºWebæœåŠ¡ï¼Œæä¾›RESTful APIæ¥å£ã€‚ èŠå¤©å®¤ï¼šä½¿ç”¨TCPåè®®å®ç°å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„å®æ—¶é€šä¿¡ã€‚ æ–‡ä»¶ä¼ è¾“ï¼šä½¿ç”¨UDPåè®®å®ç°é«˜é€Ÿæ–‡ä»¶ä¼ è¾“ï¼Œä¾‹å¦‚P2Pæ–‡ä»¶å…±äº«ã€‚ æ¸¸æˆæœåŠ¡å™¨ï¼šä½¿ç”¨TCPåè®®å®ç°åœ¨çº¿æ¸¸æˆæœåŠ¡å™¨ï¼Œå¤„ç†ç©å®¶ä¹‹é—´çš„å®æ—¶é€šä¿¡å’Œæ•°æ®åŒæ­¥ã€‚ TCPå’ŒUDPçš„å®¢æˆ·ç«¯å®ç° ä¸€è‡´ï¼Œåªæœ‰net.Dial()çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸åŒã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Connect TCP conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) // Connect udp conn, err := net.Dial(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) TCPå’ŒUDPçš„æœåŠ¡ç«¯å®ç°ï¼š ä¸åŒï¼Œåœ¨å®ç°TCPæ—¶è¦ç”¨Listeneræ¥å£ç›‘å¬å’Œå»ºç«‹TCPè¿æ¥\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // TCP l, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer l.Close() for { conn, err := l.Accept() if err != nil { return err } go handleConnection(conn) } func handleConnection(conn net.Conn) { // ... buffer := make([]byte, 1024) conn.Read(buffer) conn.Write([]byte(\u0026#34;Hello from server\u0026#34;)) } å®ç°UDPæ—¶ç”¨PacketConnæ¥å£å–ä»£äº†Connæ¥å£å’ŒListenerã€‚\nä¸ç±»å‹Connä¸åŒçš„æ˜¯ï¼ŒPackerConnå¹¶ä¸æ”¯æŒio.readerå’Œio.writeræ¥å£ï¼Œä½†æ˜¯å®ƒæ”¯æŒä¸¤ä¸ªç‰¹æ®Šçš„è¯»å†™æ–¹æ³•ReadFrom() å’Œ WriteTo() ã€‚WriteTo()æ–¹æ³•éœ€è¦æä¾›ä¸€ä¸ªå‚æ•°ä½œä¸ºå‘é€çš„æ•°æ®åˆ°å“ªä¸ªåœ°å€ï¼ŒReadFrom()åˆ™è¿”å›æ•°æ®æ˜¯ä»å“ªä¸ªåœ°å€æ¥æ”¶çš„ã€‚ 1 2 3 4 5 6 7 8 9 10 // UDP pc, err := net.ListenPacket(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { log.Fatal(err) } buffer := make([]byte, 1024) pc.ReadFrom(buffer) pc.WriteTo([]byte(\u0026#34;Hello from client\u0026#34;), addr) goåç¨‹è°ƒåº¦åŸç†ï¼Œåç¨‹ä¸ºä»€ä¹ˆå¿«ï¼Ÿ goroutineçš„ç†è§£ï¼š goroutineï¼Œåç¨‹ï¼Œæ˜¯ä¸€ç§è½»é‡çº§çš„ç”¨æˆ·çº¿ç¨‹ï¼ˆå¯ä»¥é¿å…ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ï¼Œä»è€ŒèŠ‚çœäº†èµ„æºå¼€é”€ï¼‰ï¼Œç”±Goè¿è¡Œæ—¶è°ƒåº¦å™¨è¿›è¡Œç®¡ç†ã€‚Goä¸­çš„æ¯ä¸€ä¸ªåç¨‹éƒ½ä¼šè¢«åˆ†é…åˆ°ä¸€ä¸ªè¾ƒå°çš„æ ˆç©ºé—´ï¼ˆé»˜è®¤å¤§å°2KBï¼‰ï¼Œä»¥éå¸¸ä½çš„æˆæœ¬è¿›è¡Œåˆ›å»ºå’Œé”€æ¯ã€‚\ngoroutineçš„è¿è¡Œï¼š Goè¿è¡Œæ—¶è°ƒåº¦å™¨é‡‡ç”¨äº† M:N çš„æ¨¡å‹ï¼Œå³åœ¨Mä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ä¸Šè¿è¡ŒNä¸ªåç¨‹ã€‚å…·ä½“æ¥è¯´ï¼ŒGoè¿è¡Œæ—¶åˆå§‹åŒ–äº†ä¸€ä¸ªæˆ–å¤šä¸ªGOMAXPROCSæŒ‡å®šæ•°é‡çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œå¹¶åœ¨è¿™äº›çº¿ç¨‹ä¸Šè¿è¡Œåç¨‹ã€‚\nâ€‹å½“ä¸€ä¸ªåç¨‹é˜»å¡æ—¶ï¼Œè°ƒåº¦å™¨ä¼šè‡ªåŠ¨å°†å…¶ä¸å½“å‰åç¨‹è§£é™¤ç»‘å®šï¼Œå¹¶å°†å…¶è½¬ç§»åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œç„¶åè¿è¡Œå…¶å®ƒçš„åç¨‹ï¼Œä»è€Œå®ç°äº†é«˜æ•ˆåœ°åˆ©ç”¨äº†CPUçš„æ—¶é—´ç‰‡ã€‚\ngoroutineçš„ä¼˜åŠ¿ï¼š åç¨‹ä¸åƒä¼ ç»Ÿå¤šçº¿ç¨‹ç¼–ç¨‹é‚£æ ·å¿…é¡»é¿å…çº¿ç¨‹ç«äº‰å’ŒåŠ é”è§£é”ç­‰æ“ä½œã€‚\nåœ¨Goä¸­é€šå¸¸é€šè¿‡channelå®ç°åç¨‹ä¹‹é—´çš„åŒæ­¥å’Œé€šä¿¡ã€‚Goçš„channelæœºåˆ¶æä¾›äº†ä¸€ç§éå¸¸æœ‰æ•ˆä¸”å®‰å…¨çš„åç¨‹åŒæ­¥æ–¹å¼ï¼Œå¯ä»¥é¿å…ç«äº‰æ¡ä»¶å’Œæ­»é”ç­‰é—®é¢˜ã€‚\nåŒæ—¶ï¼Œåç¨‹å¯ä»¥è‡ªæˆ‘è°ƒèŠ‚ã€è‡ªæˆ‘ç®¡ç†ï¼Œä»è€Œå¯ä»¥é¿å…äº†é¢‘ç¹çš„çº¿ç¨‹åˆ‡æ¢å¸¦æ¥çš„æ€§èƒ½æŸè€—ã€‚è¿™ä½¿å¾—åç¨‹æœ‰éå¸¸å¿«çš„ç›¸åº”é€Ÿåº¦å’Œé«˜æ•ˆçš„å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚\næ‰©å±•ï¼š\nå¹¶å‘(concurrency) vs å¹¶è¡Œ(parallelism) åœ¨å•ä¸ªCPU æ ¸ä¸Šï¼Œçº¿ç¨‹é€šè¿‡æ—¶é—´ç‰‡æˆ–è€…è®©å‡ºæ§åˆ¶æƒæ¥å®ç°ä»»åŠ¡åˆ‡æ¢ï¼Œè¾¾åˆ° \u0026ldquo;åŒæ—¶\u0026rdquo; è¿è¡Œå¤šä¸ªä»»åŠ¡çš„ç›®çš„ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„å¹¶å‘ã€‚ä½†å®é™…ä¸Šä»»ä½•æ—¶åˆ»éƒ½åªæœ‰ä¸€ä¸ªä»»åŠ¡è¢«æ‰§è¡Œï¼Œå…¶ä»–ä»»åŠ¡é€šè¿‡æŸç§ç®—æ³•æ¥æ’é˜Ÿã€‚\nåªç”¨å¤šæ ¸CPUå¯ä»¥è®©åŒä¸€è¿›ç¨‹å†…çš„\u0026quot;å¤šä¸ªçº¿ç¨‹\u0026quot; åšåˆ°çœŸæ­£æ„ä¹‰ä¸Šçš„åŒæ—¶è¿è¡Œã€‚\nè¿›ç¨‹ vs çº¿ç¨‹ vs åç¨‹ è¿›ç¨‹ï¼šç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…çš„åŸºæœ¬å•ä½ï¼Œå æœ‰ç‹¬ç«‹çš„å†…å­˜ç©ºé—´ã€‚\nçº¿ç¨‹ï¼šCPUè°ƒåº¦å’Œåˆ†é…çš„åŸºæœ¬å•ä½ï¼Œä¾é™„äºè¿›ç¨‹å­˜åœ¨ï¼Œæ¯ä¸ªçº¿ç¨‹å…±äº«çˆ¶è¿›ç¨‹çš„èµ„æºã€‚\nçº¿ç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Ÿ\nç”±äºä¸­æ–­å¤„ç†ï¼Œå¤šä»»åŠ¡å¤„ç†ï¼Œç”¨æˆ·æ€åˆ‡æ¢ç­‰åŸå› ä¼šå¯¼è‡´ CPU ä»ä¸€ä¸ªçº¿ç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œåˆ‡æ¢è¿‡ç¨‹éœ€è¦ä¿å­˜å½“å‰è¿›ç¨‹çš„çŠ¶æ€å¹¶æ¢å¤å¦ä¸€ä¸ªè¿›ç¨‹çš„çŠ¶æ€ã€‚ä»£ä»·æ˜¯é«˜æ˜‚çš„ã€‚\nåç¨‹ï¼šç”¨æˆ·æ€çš„è½»é‡çº§çº¿ç¨‹ï¼Œè°ƒåº¦å®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶ï¼Œåç¨‹é—´åˆ‡æ¢åªéœ€è¦ä¿å­˜ä»»åŠ¡çš„ä¸Šä¸‹æ–‡ï¼Œæ²¡æœ‰å†…æ ¸çš„å¼€é”€ã€‚\nGoroutine ä¸Šä¸‹æ–‡åˆ‡æ¢åªæ¶‰åŠåˆ°ä¸‰ä¸ªå¯„å­˜å™¨ï¼ˆPC / SP / DXï¼‰çš„å€¼ä¿®æ”¹ï¼›è€Œå¯¹æ¯”çº¿ç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢åˆ™éœ€è¦æ¶‰åŠæ¨¡å¼åˆ‡æ¢ï¼ˆä»ç”¨æˆ·æ€åˆ‡æ¢åˆ°å†…æ ¸æ€ï¼‰ã€ä»¥åŠ 16 ä¸ªå¯„å­˜å™¨ã€PCã€SPâ€¦ç­‰å¯„å­˜å™¨çš„åˆ·æ–°ï¼›\nçº¿ç¨‹æ ˆç©ºé—´é€šå¸¸æ˜¯ 2Mï¼ŒGoroutine æ ˆç©ºé—´æœ€å° 2Kï¼›\nGolang ç¨‹åºä¸­å¯ä»¥è½»æ¾æ”¯æŒ10w çº§åˆ«çš„ Goroutine è¿è¡Œï¼Œè€Œçº¿ç¨‹æ•°é‡è¾¾åˆ° 1k æ—¶ï¼Œå†…å­˜å ç”¨å°±å·²ç»è¾¾åˆ° 2Gã€‚\nGoè°ƒåº¦å™¨æ˜¯å•¥ï¼Ÿ Goè°ƒåº¦å™¨æ¨¡å‹é€šå¸¸å«åšGPMæ¨¡å‹ï¼ŒGoç¨‹åºé€šè¿‡è°ƒåº¦å™¨æ¥è°ƒåº¦goroutineåœ¨å†…æ ¸çº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œä½†æ˜¯goroutineï¼ˆGï¼‰ä¸ç›´æ¥ç»‘å®šosçº¿ç¨‹ï¼ˆMï¼‰è¿è¡Œï¼Œè€Œæ˜¯ç”± goroutine scheduler ä¸­çš„é€»è¾‘å¤„ç†å™¨ï¼ˆPï¼‰æ¥ä½œä¸ºè·å–å†…æ ¸çº¿ç¨‹èµ„æºçš„â€œä¸­ä»‹â€ã€‚\nåŒ…æ‹¬4ä¸ªé‡è¦ç»“æ„ï¼Œåˆ†åˆ«æ˜¯Gã€Pã€Mã€Schedï¼š(Gç –å¤´ Måœ°é¼  På°è½¦)\nG: Goroutineï¼Œåç¨‹ï¼Œè¿è¡Œåœ¨çº¿ç¨‹ä¸Šï¼›æ¯ä¸ª Goroutine å¯¹åº”ä¸€ä¸ª G ç»“æ„ä½“ï¼ŒG å­˜å‚¨ Goroutine çš„è¿è¡Œå †æ ˆã€çŠ¶æ€ä»¥åŠä»»åŠ¡å‡½æ•°ï¼Œå¯é‡ç”¨ã€‚G å¹¶éæ‰§è¡Œä½“ï¼Œæ¯ä¸ª G éœ€è¦ç»‘å®šåˆ° P æ‰èƒ½è¢«è°ƒåº¦æ‰§è¡Œã€‚\nM: Machineï¼Œthreadï¼Œå³çº¿ç¨‹ï¼Œå¾ªç¯è°ƒå–åç¨‹å¹¶æ‰§è¡Œï¼›OS å†…æ ¸çº¿ç¨‹æŠ½è±¡ï¼Œä»£è¡¨ç€çœŸæ­£æ‰§è¡Œè®¡ç®—çš„èµ„æºã€‚åœ¨ç»‘å®šæœ‰æ•ˆçš„ P åï¼Œè¿›å…¥ schedule å¾ªç¯ï¼›è€Œ schedule å¾ªç¯çš„æœºåˆ¶å¤§è‡´æ˜¯ä» Global é˜Ÿåˆ—ã€P çš„ Local é˜Ÿåˆ—ä»¥åŠ wait é˜Ÿåˆ—ä¸­è·å–ã€‚\nM çš„æ•°é‡æ˜¯ä¸å®šçš„ï¼Œç”± Go Runtime è°ƒæ•´ï¼Œä¸ºäº†é˜²æ­¢åˆ›å»ºè¿‡å¤š OS çº¿ç¨‹å¯¼è‡´ç³»ç»Ÿè°ƒåº¦ä¸è¿‡æ¥ï¼Œç›®å‰é»˜è®¤æœ€å¤§é™åˆ¶ä¸º 10000 ä¸ªã€‚\nM å¹¶ä¸ä¿ç•™ G çŠ¶æ€ï¼Œè¿™æ˜¯ G å¯ä»¥è·¨ M è°ƒåº¦çš„åŸºç¡€ã€‚\nP: Processorï¼Œå¤„ç†å™¨ï¼›å¯¹ G æ¥è¯´ï¼ŒP ç›¸å½“äº CPU æ ¸ï¼ŒG åªæœ‰ç»‘å®šåˆ° P æ‰èƒ½è¢«è°ƒåº¦ã€‚å¯¹ M æ¥è¯´ï¼ŒP æä¾›äº†ç›¸å…³çš„æ‰§è¡Œç¯å¢ƒ(Context)ï¼Œå¦‚å†…å­˜åˆ†é…çŠ¶æ€(mcache)ï¼Œä»»åŠ¡é˜Ÿåˆ—(G)ç­‰ã€‚P çš„æ•°é‡å†³å®šäº†ç³»ç»Ÿå†…æœ€å¤§å¯å¹¶è¡Œçš„ G çš„æ•°é‡ï¼ˆå‰æï¼šç‰©ç† CPU æ ¸æ•° \u0026gt;= P çš„æ•°é‡ï¼‰ã€‚\nP çš„æ•°é‡ç”±ç”¨æˆ·è®¾ç½®çš„ GoMAXPROCS å†³å®šï¼Œä½†æ˜¯ä¸è®º GoMAXPROCS è®¾ç½®ä¸ºå¤šå¤§ï¼ŒP çš„æ•°é‡æœ€å¤§ä¸º 256ã€‚\nSched: Go è°ƒåº¦å™¨ï¼Œå®ƒç»´æŠ¤æœ‰å­˜å‚¨ M å’Œ G çš„é˜Ÿåˆ—ä»¥åŠè°ƒåº¦å™¨çš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ç­‰ã€‚è°ƒåº¦å™¨å¾ªç¯çš„æœºåˆ¶å¤§è‡´æ˜¯ä»å„ç§é˜Ÿåˆ—ã€P çš„æœ¬åœ°é˜Ÿåˆ—ä¸­è·å– Gï¼Œåˆ‡æ¢åˆ° G çš„æ‰§è¡Œæ ˆä¸Šå¹¶æ‰§è¡Œ G çš„å‡½æ•°ï¼Œè°ƒç”¨ Goexit åšæ¸…ç†å·¥ä½œå¹¶å›åˆ° Mï¼Œå¦‚æ­¤åå¤ã€‚\nå…·ä½“è®²è§£åœ°å€\ngoå®ç°åŸºæœ¬çš„æ’åºå’ŒæŸ¥æ‰¾ç®—æ³• è¯¦ç»†å†…å®¹\nï¼ˆ1ï¼‰åŸºæœ¬æ’åºç®—æ³• åŸºäºBig-O(n^2)çš„æ’åº\né€‰æ‹©æ’åºï¼šé€‰æ•°ç»„ä¸­æœ€å°çš„å…ƒç´ å’Œç¬¬ä¸€ä¸ªå…ƒç´ äº¤æ¢ï¼›å†é€‰å‰©ä¸‹å…ƒç´ ä¸­æœ€å°çš„å’Œç¬¬äºŒä¸ªå…ƒç´ äº¤æ¢ï¼Œ\u0026hellip; ç©ºé—´O(1)ï¼Œä¸ç¨³å®š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func selectSort(arr []int) { for i := 0; i \u0026lt; len(arr); i ++ { minIndex := i for j := i + 1; j \u0026lt; len(arr); j ++ { if arr[minIndex] \u0026gt; arr[j] { minIndex = j; } } swap(arr, i, minIndex) } } func swap(arr []int, i, j int) { temp := arr[i] arr[i] = arr[j] arr[j] = temp } å†’æ³¡æ’åº: ä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹ï¼Œæ¯æ¬¡æ¯”è¾ƒç›¸é‚»å…ƒç´ ï¼ŒæŒ‰é¡ºåºäº¤æ¢ï¼Œå¦åˆ™ç»§ç»­å¾€åæ¯”è¾ƒä¸‹ä¸€å¯¹ï¼Œ\u0026hellip; ç©ºé—´O(1)ï¼Œç¨³å®š 1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { for e := len(arr) - 1; e \u0026gt; 0; e -- { for i := 0; i \u0026lt; e; i ++ { // å‡åº if arr[i] \u0026gt; arr[i + 1] { swap(arr, i, i + 1) } } } } æ’å…¥æ’åºï¼šå†’æ³¡çš„æ¯ä¸€æ¬¡å†’ï¼Œéƒ½è¦æŠŠæ— åºåºåˆ—è½®ä¸€éï¼›æ’å…¥æ’åºæ°æ°ç›¸åï¼Œä¸€æ—¦ä½ é‡åˆ°æ¯”è‡ªå·±å¤§æˆ–å°çš„äº†ï¼Œä½ å°±çŸ¥é“ï¼Œåé¢éƒ½æ˜¯æ¯”è‡ªå·±å¤§æˆ–å°çš„ï¼Œç°åœ¨åä¸‹ï¼Œå½“å‰å…ƒç´ å°±è¿›å…¥äº†æœ‰åºåºåˆ—ã€‚æ’å…¥çš„æ¯ä¸€æ¬¡æ’ï¼Œéƒ½ä¸ä¸€å®šè¦è½®ä¸€éæœ‰åºåºåˆ—ã€‚ 1 2 3 4 5 6 7 8 9 10 11 func insertSort(arr []int) { // æœªæ’åºåŒºé—´ for i := 1; i \u0026lt; len(arr); i ++ { // å·²æ’åºåŒºé—´ for j := i - 1; j \u0026gt;= 0; j -- { if arr[j] \u0026gt; arr[j + 1] { swap(arr, j, j + 1) } } } } åŸºäºBig-O(nlogn)çš„æ’åº\nå¿«æ’ï¼šåˆ†æ²»æ€æƒ³ï¼Œç©ºé—´O(logn), ä¸ç¨³å®š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func quickSort(arr []int, L int, R int) { if(L \u0026lt; R){ lF, rF := float32(L), float32(R) rand.Seed(time.Now().UnixNano()) randomIndex := int(lF + rand.Float32() * (rF - lF + 1))//æ•°ç»„ä¸­éšæœºè·å–ä¸‹æ ‡ swap(arr, randomIndex, R) var p []int = partition(arr, L, R) //partitionæ“ä½œè¿”å›p[0]å’Œp[1] quickSort(arr, L, p[0] - 1) //p[0]-1ä¸ºéšæœºä¸‹æ ‡å¯¹åº”çš„å€¼çš„å·¦è¾¹ quickSort(arr, p[1] + 1, R) //p[1]+1ä¸ºéšæœºä¸‹æ ‡å¯¹åº”çš„å€¼çš„å³è¾¹ } } func partition(arr []int, L int, R int) []int { less, more := L - 1, R //lessåŒºåŸŸä¸ºå°äºéšæœºä¸‹æ ‡å¯¹åº”çš„å€¼ï¼ŒmoreåŒºåŸŸä¸ºå¤§äºéšæœºä¸‹æ ‡å¯¹åº”çš„å€¼ for L \u0026lt; more { if arr[L] \u0026lt; arr[R] { less++ swap(arr, less, L) L++ } else if arr[L] \u0026gt; arr[R]{ more-- swap(arr, more, L) } else { L++ } } swap(arr, more, R) return []int {less + 1, more} } å½’å¹¶æ’ï¼šç©ºé—´å¤æ‚åº¦O(n)ï¼Œç¨³å®š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func mergeSort(arr []int, L int, Mid int, R int) { if len(arr) \u0026lt; 2 { return } help := make([]int, 0, R - L + 1) p1, p2 := L, Mid + 1 for p1 \u0026lt;= Mid \u0026amp;\u0026amp; p2 \u0026lt;= R { if arr[p1] \u0026lt;= arr[p2] { help = append(help, arr[p1]) p1++ } else { help = append(help, arr[p2]) p2++ } } for p1 \u0026lt;= Mid { help = append(help, arr[p1]) p1++ } for p2 \u0026lt;= R { help = append(help, arr[p2]) p2++ } for i := 0; i \u0026lt; len(help); i++ { arr[L + i] = help[i] } } å †æ’ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ï¼š heapInsert(arr []int, index int) å»ºç«‹å¤§æ ¹å †ï¼Œ(index * 2) + 1ä¸ºè¯¥èŠ‚ç‚¹å·¦å­©å­ï¼Œ(index * 2) + 2 ä¸ºè¯¥èŠ‚ç‚¹å³å­©å­ï¼Œ(index - 1) / 2 ä¸ºè¯¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚è‹¥è¯¥èŠ‚ç‚¹å¤§äºçˆ¶èŠ‚ç‚¹ï¼Œå°±äº¤æ¢ï¼Œå¹¶ä¸”index = (index - 1) / 2ã€‚\nheapify(arr []int, index int, heapSize int), æ‰¾åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹lastNodeï¼Œè¯¥èŠ‚ç‚¹ä¸å½“å‰æ ¹èŠ‚ç‚¹äº¤æ¢ï¼ŒåŒæ—¶heap\u0026ndash;ï¼Œå³æœ€åä½ç½®ä¸Šä¸ºæœ€å¤§å€¼ï¼Œæ ¹èŠ‚ç‚¹ä¸ºæå°å€¼ã€‚æ­¤æ—¶ä»æ ¹ç»“ç‚¹å‡ºå‘ï¼Œç»§ç»­heapifyçš„è¿‡ç¨‹(å·¦å­©å­å³å­©å­è¾ƒå¤§è€…ä¸æ ¹èŠ‚ç‚¹äº¤æ¢, lastNodeèŠ‚ç‚¹ æ¥åˆ°å­©å­èŠ‚ç‚¹è¾ƒå¤§è€…ä½ç½®ï¼Œç»§ç»­å·¦å³å­©å­è¾ƒå¤§è€…æ¯”è¾ƒï¼Œç›´è‡³æ²¡æœ‰å·¦å³å­©å­)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func heapInsert(arr []int, index int){ for arr[index] \u0026gt; arr[(index - 1) / 2] { swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 } } //index * 2 + 1 å·¦å­©å­èŠ‚ç‚¹ //index * 2 + 2 å³å­©å­èŠ‚ç‚¹ //(index - 1) / 2 çˆ¶èŠ‚ç‚¹ func heapify(arr []int, index int, heapSize int){ var largestIndex int leftNode := index * 2 + 1 for leftNode \u0026lt; heapSize { if leftNode + 1 \u0026lt; heapSize \u0026amp;\u0026amp; arr[leftNode + 1] \u0026gt; arr[leftNode] { largestIndex = leftNode + 1 } else { largestIndex = leftNode } if arr[largestIndex] \u0026lt; arr[index] { largestIndex = index } if largestIndex == index { break } swap(arr, largestIndex, index) index = largestIndex leftNode = index * 2 + 1 } } ï¼ˆ2ï¼‰åŸºæœ¬æŸ¥æ‰¾ç®—æ³• åšæ–‡link\nä¸ƒå¤§æŸ¥æ‰¾ç®—æ³•ï¼š é¡ºåºæŸ¥æ‰¾ã€äºŒåˆ†æŸ¥æ‰¾ã€å·®å€¼æŸ¥æ‰¾ã€æ–æ³¢é‚£å¥‘æŸ¥æ‰¾ã€ æ ‘è¡¨æŸ¥æ‰¾ (äºŒå‰æ ‘æŸ¥æ‰¾ã€å¹³è¡¡æŸ¥æ‰¾æ ‘ä¹‹2-3æŸ¥æ‰¾æ ‘ã€å¹³è¡¡æŸ¥æ‰¾æ ‘ä¹‹çº¢é»‘æ ‘ã€Bæ ‘å’ŒB+æ ‘)ã€åˆ†å—æŸ¥æ‰¾ã€å“ˆå¸ŒæŸ¥æ‰¾ã€å›¾æŸ¥æ‰¾ (å¹¿åº¦ä¼˜å…ˆæŸ¥æ‰¾ã€æ·±åº¦ä¼˜å…ˆæŸ¥æ‰¾)\nåˆ†ç±»ï¼š é™æ€æŸ¥æ‰¾ vs åŠ¨æ€æŸ¥æ‰¾\næœ‰åºæŸ¥æ‰¾ vs æ— åºæŸ¥æ‰¾\nmysqlç´¢å¼•åˆ†ä¸ºå‡ ç§ï¼Ÿ æŒ‰æ•°æ®ç»“æ„ï¼šB+treeç´¢å¼•ã€Hashç´¢å¼•ã€Full-textç´¢å¼•ã€‚\næŒ‰ç‰©ç†å­˜å‚¨ï¼šèšç°‡ç´¢å¼•ã€äºŒçº§ç´¢å¼•ï¼ˆè¾…åŠ©ç´¢å¼•æˆ–è€…éä¸»é”®ç´¢å¼•ï¼‰ã€‚\nMySQLç´¢å¼•æŒ‰å¶å­èŠ‚ç‚¹å­˜å‚¨çš„æ˜¯å¦ä¸ºå®Œæ•´è¡¨æ•°æ®åˆ†ä¸ºï¼šèšç°‡ç´¢å¼•ã€äºŒçº§ç´¢å¼•ï¼ˆè¾…åŠ©ç´¢å¼•ï¼‰ã€‚å…¨è¡¨æ•°æ®å­˜å‚¨åœ¨èšç°‡ç´¢å¼•ä¸­ï¼Œèšç°‡ç´¢å¼•ä»¥å¤–çš„å…¶ä»–ç´¢å¼•å«åšäºŒçº§ç´¢å¼•ï¼Œä¹Ÿå«è¾…åŠ©ç´¢å¼•ã€‚\næŒ‰å­—æ®µç‰¹æ€§ï¼šä¸»é”®ç´¢å¼•ã€æ™®é€šç´¢å¼•ã€å‰ç¼€ç´¢å¼•ã€‚\næŒ‰å­—æ®µä¸ªæ•°ï¼šå•åˆ—ç´¢å¼•ã€è”åˆç´¢å¼•ï¼ˆå¤åˆç´¢å¼•ã€ç»„åˆç´¢å¼•ï¼‰ã€‚\nRedis vs MySQL åŒºåˆ«ï¼š æ•°æ®ç±»å‹ mysqlæ˜¯å…³ç³»å‹æ•°æ®åº“ï¼Œä¸»è¦ç”¨äºå­˜æ”¾æŒä¹…åŒ–æ•°æ®ï¼Œå°†æ•°æ®å­˜å‚¨åœ¨ç¡¬ç›˜ä¸­ï¼Œè¯»å–é€Ÿåº¦è¾ƒæ…¢ã€‚\nredisæ˜¯NOSQLï¼Œå³éå…³ç³»å‹æ•°æ®åº“ï¼Œä¹Ÿæ˜¯ç¼“å­˜æ•°æ®åº“ï¼Œå³å°†æ•°æ®å­˜å‚¨åœ¨ç¼“å­˜ä¸­ï¼Œç¼“å­˜çš„è¯»å–é€Ÿåº¦å¿«ï¼Œèƒ½å¤Ÿå¤§å¤§çš„æé«˜è¿è¡Œæ•ˆç‡ï¼Œä½†æ˜¯ä¿å­˜æ—¶é—´æœ‰é™ã€‚\næœ¬è´¨åŒºåˆ« Redisï¼šåŸºäºå†…å­˜ï¼Œè¯»å†™é€Ÿåº¦å¿«ï¼Œä¹Ÿå¯åšæŒä¹…åŒ–ï¼Œä½†æ˜¯å†…å­˜ç©ºé—´æœ‰é™ï¼Œå½“æ•°æ®é‡è¶…è¿‡å†…å­˜ç©ºé—´æ—¶ï¼Œéœ€æ‰©å……å†…å­˜ï¼Œè€Œå†…å­˜æˆæœ¬è¾ƒé«˜ï¼›\nMySQLï¼šåŸºäºç£ç›˜ï¼Œè¯»å†™é€Ÿåº¦æ²¡æœ‰Rediså¿«ï¼Œä½†æ˜¯ä¸å—ç©ºé—´å®¹é‡é™åˆ¶ï¼Œæ€§ä»·æ¯”é«˜ï¼›\nredisä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ é€Ÿåº¦å¿«ï¼šRedis æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œè¯»å†™é€Ÿåº¦éå¸¸å¿«ï¼Œé€‚ç”¨äºéœ€è¦é«˜é€Ÿæ•°æ®å¤„ç†çš„åœºæ™¯ã€‚\næ•°æ®ç»“æ„ä¸°å¯Œï¼šRedis æ”¯æŒå¤šç§æ•°æ®ç»“æ„ï¼Œå¦‚å­—ç¬¦ä¸²ã€å“ˆå¸Œã€åˆ—è¡¨ã€é›†åˆã€æœ‰åºé›†åˆç­‰ï¼Œå¯ä»¥æ»¡è¶³ä¸åŒç±»å‹çš„æ•°æ®å­˜å‚¨éœ€æ±‚ã€‚\næ”¯æŒåˆ†å¸ƒå¼ï¼šRedis å¯ä»¥é€šè¿‡ä¸»ä»å¤åˆ¶å’Œå“¨å…µæœºåˆ¶å®ç°åˆ†å¸ƒå¼éƒ¨ç½²ï¼Œæé«˜ç³»ç»Ÿçš„å¯é æ€§å’Œå¯ç”¨æ€§ã€‚\nè½»é‡çº§ï¼šRedis ç›¸å¯¹å…¶ä»–æ•°æ®åº“æ¥è¯´æ¯”è¾ƒè½»é‡çº§ï¼Œå ç”¨èµ„æºå°‘ï¼Œå¯åŠ¨é€Ÿåº¦å¿«ã€‚\nå¯æ‰©å±•æ€§ï¼šRedis å¯ä»¥é€šè¿‡æ’ä»¶æˆ–æ‰©å±•æœºåˆ¶å®ç°æ›´å¤šçš„åŠŸèƒ½ï¼Œå¦‚ Redis Modulesã€‚\næ”¯æŒäº‹åŠ¡ï¼šRedis æä¾›äº†ç®€å•çš„äº‹åŠ¡æœºåˆ¶ï¼Œä¿è¯äº†æ•°æ®çš„ä¸€è‡´æ€§ã€‚\nç¼ºç‚¹ å†…å­˜é™åˆ¶ï¼šç”±äºæ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼ŒRedis çš„å†…å­˜å®¹é‡æœ‰é™ï¼Œæ— æ³•å¤„ç†å¤§é‡çš„æ•°æ®\næ•°æ®æŒä¹…æ€§ï¼šRedis é»˜è®¤æƒ…å†µä¸‹æ˜¯å°†æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ï¼Œå¦‚æœæ²¡æœ‰æ­£ç¡®é…ç½®æŒä¹…åŒ–æœºåˆ¶ï¼Œæ•°æ®åœ¨æœåŠ¡å™¨é‡å¯æˆ–æ•…éšœæ—¶å¯èƒ½ä¼šä¸¢å¤±ã€‚\nå¤æ‚æ€§ï¼šè™½ç„¶ Redis ç›¸å¯¹ç®€å•ï¼Œä½†åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„ç®¡ç†å’Œé…ç½®å¯èƒ½ä¼šå˜å¾—å¤æ‚ã€‚\nä¸æ”¯æŒå¤æ‚æŸ¥è¯¢ï¼šRedis ä¸»è¦ç”¨äºç®€å•çš„æ•°æ®æ“ä½œï¼Œå¯¹äºå¤æ‚çš„æŸ¥è¯¢å’Œåˆ†æåŠŸèƒ½è¾ƒå¼±ã€‚\nä½¿ç”¨åœºæ™¯ ç¼“å­˜ï¼šRedis æœ€å¸¸è§çš„ç”¨é€”ä¹‹ä¸€æ˜¯ä½œä¸ºç¼“å­˜æœåŠ¡å™¨ï¼Œå°†é¢‘ç¹è®¿é—®çš„æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œä»¥åŠ é€Ÿæ•°æ®è®¿é—®é€Ÿåº¦ã€‚ç”±äº Redis å…·æœ‰å¿«é€Ÿçš„è¯»å†™é€Ÿåº¦å’Œä¸°å¯Œçš„æ•°æ®ç»“æ„ï¼Œé€‚ç”¨äºå„ç§ç¼“å­˜åœºæ™¯ï¼Œå¦‚ç½‘é¡µç¼“å­˜ã€ä¼šè¯ç¼“å­˜ã€å¯¹è±¡ç¼“å­˜ç­‰ã€‚\nä¼šè¯å­˜å‚¨ï¼šRedis å¯ä»¥ç”¨ä½œä¼šè¯å­˜å‚¨ï¼Œå°†ç”¨æˆ·ä¼šè¯æ•°æ®å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œä»¥æä¾›å¿«é€Ÿçš„ä¼šè¯è®¿é—®å’Œç®¡ç†ã€‚è¿™å¯¹äºéœ€è¦è·¨å¤šä¸ªæœåŠ¡å™¨å…±äº«ä¼šè¯æ•°æ®çš„ Web åº”ç”¨ç¨‹åºéå¸¸æœ‰ç”¨ã€‚\næ¶ˆæ¯é˜Ÿåˆ—ï¼šRedis æ”¯æŒå‘å¸ƒ/è®¢é˜…æ¨¡å¼ï¼ˆPub/Subï¼‰ï¼Œå¯ä»¥ç”¨ä½œè½»é‡çº§çš„æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿï¼Œå®ç°æ¶ˆæ¯çš„å‘å¸ƒå’Œè®¢é˜…ï¼Œç”¨äºå¼‚æ­¥ä»»åŠ¡å¤„ç†ã€äº‹ä»¶é€šçŸ¥ç­‰åœºæ™¯ã€‚\nè®¡æ•°å™¨ï¼šRedis çš„åŸå­æ“ä½œèƒ½åŠ›ä½¿å…¶æˆä¸ºå®ç°è®¡æ•°å™¨åŠŸèƒ½çš„ç†æƒ³é€‰æ‹©ã€‚å®ƒå¯ä»¥ç”¨äºç»Ÿè®¡ç½‘ç«™è®¿é—®é‡ã€ç”¨æˆ·ç‚¹å‡»é‡ã€å•†å“é”€é‡ç­‰ã€‚\nåˆ†å¸ƒå¼é”ï¼šRedis çš„åˆ†å¸ƒå¼é”åŠŸèƒ½å¯ä»¥ç”¨äºå®ç°åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„äº’æ–¥æ“ä½œï¼Œç¡®ä¿å…±äº«èµ„æºçš„å®‰å…¨è®¿é—®ã€‚è¿™å¯¹äºæ§åˆ¶å¹¶å‘è®¿é—®ã€é¿å…èµ„æºç«äº‰éå¸¸æœ‰ç”¨ã€‚\nå®æ—¶æ•°æ®åˆ†æï¼šRedis æ”¯æŒæŒä¹…åŒ–å’Œæ•°æ®å¤‡ä»½ï¼Œå¯ä»¥ç”¨äºå®æ—¶æ•°æ®åˆ†æå’Œç›‘æ§ç³»ç»Ÿï¼Œå­˜å‚¨å®æ—¶æ•°æ®ï¼Œå¹¶æ”¯æŒæ•°æ®çš„å¿«é€ŸæŸ¥è¯¢å’Œåˆ†æã€‚\nä»»åŠ¡é˜Ÿåˆ—ï¼šRedis å¯ä»¥ç”¨ä½œä»»åŠ¡é˜Ÿåˆ—ï¼Œç”¨äºå­˜å‚¨å’Œç®¡ç†éœ€è¦å¼‚æ­¥å¤„ç†çš„ä»»åŠ¡ï¼Œå¦‚åå°ä»»åŠ¡ã€å®šæ—¶ä»»åŠ¡ç­‰ã€‚\nåœ°ç†ä½ç½®æœåŠ¡ï¼šRedis çš„åœ°ç†ä½ç½®æ•°æ®ç±»å‹ï¼ˆGeoï¼‰å¯ä»¥ç”¨äºå­˜å‚¨åœ°ç†ä½ç½®ä¿¡æ¯ï¼Œå¹¶æ”¯æŒåŸºäºä½ç½®çš„æœç´¢å’ŒæŸ¥è¯¢ï¼Œç”¨äºå®ç°ä½ç½®æœåŠ¡å’Œåœ°ç†ä¿¡æ¯ç³»ç»Ÿã€‚\nmysqlä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ å¼€æºå’Œå…è´¹ï¼šMySQL æ˜¯å¼€æºè½¯ä»¶ï¼Œå¯ä»¥å…è´¹ä½¿ç”¨ï¼Œé™ä½äº†ä¼ä¸šçš„æˆæœ¬è´Ÿæ‹…ã€‚\nè·¨å¹³å°æ€§ï¼šMySQL å¯ä»¥åœ¨å¤šç§æ“ä½œç³»ç»Ÿä¸Šè¿è¡Œï¼ŒåŒ…æ‹¬ Windowsã€Linuxã€Mac ç­‰ï¼Œå…·æœ‰è‰¯å¥½çš„è·¨å¹³å°æ€§ã€‚\næ˜“äºä½¿ç”¨ï¼šMySQL çš„å®‰è£…å’Œé…ç½®ç›¸å¯¹ç®€å•ï¼Œå…·æœ‰è‰¯å¥½çš„ç”¨æˆ·æ–‡æ¡£å’Œç¤¾åŒºæ”¯æŒï¼Œä½¿å¾—ç”¨æˆ·å¯ä»¥å¿«é€Ÿä¸Šæ‰‹å¹¶è¿›è¡Œæ•°æ®åº“ç®¡ç†å’ŒæŸ¥è¯¢ã€‚\né«˜æ€§èƒ½ï¼šMySQL å…·æœ‰è¾ƒé«˜çš„æ€§èƒ½ï¼Œèƒ½å¤Ÿå¤„ç†å¤§é‡çš„å¹¶å‘è¯·æ±‚ï¼Œæä¾›é«˜æ•ˆçš„æ•°æ®å­˜å–å’ŒæŸ¥è¯¢èƒ½åŠ›ã€‚\nå¯æ‰©å±•æ€§ï¼šMySQL æ”¯æŒä¸»ä»å¤åˆ¶ã€åˆ†åŒºè¡¨ã€åˆ†å¸ƒå¼æ•°æ®åº“ç­‰åŠŸèƒ½ï¼Œå¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œç³»ç»Ÿæ‰©å±•å’Œè´Ÿè½½å‡è¡¡ã€‚\nç¼ºç‚¹ æ€§èƒ½ç“¶é¢ˆï¼šåœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®å’Œé«˜å¹¶å‘è¯·æ±‚æ—¶ï¼ŒMySQL å¯èƒ½ä¼šé‡åˆ°æ€§èƒ½ç“¶é¢ˆï¼Œéœ€è¦è¿›è¡Œä¼˜åŒ–å’Œè°ƒæ•´ä»¥æ»¡è¶³éœ€æ±‚ã€‚\nå•ç‚¹æ•…éšœï¼šMySQL åœ¨å•æœºéƒ¨ç½²æ—¶å­˜åœ¨å•ç‚¹æ•…éšœçš„é£é™©ï¼Œéœ€è¦é‡‡å–åˆé€‚çš„å®¹é”™å’Œå¤‡ä»½ç­–ç•¥æ¥ä¿è¯ç³»ç»Ÿçš„å¯é æ€§å’Œç¨³å®šæ€§ã€‚\nå¤æ‚çš„ç®¡ç†ï¼šè™½ç„¶ MySQL ç›¸å¯¹æ˜“äºä½¿ç”¨ï¼Œä½†åœ¨å¤§è§„æ¨¡éƒ¨ç½²å’Œç®¡ç†æ—¶ï¼Œéœ€è¦èŠ±è´¹ä¸€å®šçš„æ—¶é—´å’Œç²¾åŠ›æ¥è¿›è¡Œæ•°æ®åº“çš„ç®¡ç†å’Œç»´æŠ¤ã€‚\nå­˜å‚¨å¼•æ“é™åˆ¶ï¼šMySQL çš„å­˜å‚¨å¼•æ“æ•°é‡æœ‰é™ï¼Œä¸åŒçš„å­˜å‚¨å¼•æ“å…·æœ‰ä¸åŒçš„ç‰¹æ€§å’Œæ€§èƒ½ï¼Œé€‰æ‹©åˆé€‚çš„å­˜å‚¨å¼•æ“éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œè¯„ä¼°ã€‚\näº‹åŠ¡æ”¯æŒæœ‰é™ï¼šåœ¨æŸäº›åœºæ™¯ä¸‹ï¼ŒMySQL çš„äº‹åŠ¡æ”¯æŒå¯èƒ½æœ‰é™ï¼Œä¸é€‚åˆè¦æ±‚ä¸¥æ ¼äº‹åŠ¡ä¸€è‡´æ€§çš„åº”ç”¨åœºæ™¯ã€‚\nä½¿ç”¨åœºæ™¯ Web åº”ç”¨ç¨‹åºï¼šMySQL æ˜¯è®¸å¤š Web åº”ç”¨ç¨‹åºçš„é¦–é€‰æ•°æ®åº“ï¼ŒåŒ…æ‹¬ç”µå­å•†åŠ¡ç½‘ç«™ã€åšå®¢ã€ç¤¾äº¤ç½‘ç»œã€è®ºå›ç­‰ã€‚å®ƒèƒ½å¤Ÿå¤„ç†å¤§é‡çš„å¹¶å‘è¯·æ±‚ï¼Œå¹¶æä¾›è‰¯å¥½çš„æ€§èƒ½å’Œå¯é æ€§ã€‚\næ—¥å¿—å’Œç›‘æ§ç³»ç»Ÿï¼šMySQL å¯ä»¥ç”¨äºå­˜å‚¨æ—¥å¿—å’Œç›‘æ§æ•°æ®ï¼Œç”¨äºåˆ†æç³»ç»Ÿçš„è¿è¡ŒçŠ¶æ€å’Œæ€§èƒ½æŒ‡æ ‡ï¼Œå¸®åŠ©ç®¡ç†å‘˜ç›‘æ§å’Œç®¡ç†ç³»ç»Ÿçš„è¿è¡Œæƒ…å†µã€‚\nä¼ä¸šåº”ç”¨ç¨‹åºï¼šè®¸å¤šä¼ä¸šçº§åº”ç”¨ç¨‹åºä½¿ç”¨ MySQL ä½œä¸ºå…¶å…³é”®çš„æ•°æ®å­˜å‚¨å’Œç®¡ç†å·¥å…·ã€‚è¿™äº›åº”ç”¨ç¨‹åºå¯èƒ½æ¶‰åŠå®¢æˆ·å…³ç³»ç®¡ç†ï¼ˆCRMï¼‰ã€ä¼ä¸šèµ„æºè§„åˆ’ï¼ˆERPï¼‰ã€äººåŠ›èµ„æºç®¡ç†ï¼ˆHRMï¼‰ç­‰å„ç§ä¸šåŠ¡åŠŸèƒ½ã€‚\næ•°æ®ä»“åº“å’ŒæŠ¥å‘Šç³»ç»Ÿï¼šMySQL å¯ä»¥ä½œä¸ºæ•°æ®ä»“åº“å’ŒæŠ¥å‘Šç³»ç»Ÿçš„åç«¯å­˜å‚¨ï¼Œç”¨äºå­˜å‚¨å’Œç®¡ç†å¤§é‡çš„å†å²æ•°æ®ï¼Œå¹¶æ”¯æŒå¤æ‚çš„æŸ¥è¯¢å’ŒæŠ¥å‘Šç”Ÿæˆã€‚\neså…·ä½“çš„ä½¿ç”¨æ–¹æ³•å¥½åœ¨å“ªé‡Œï¼Ÿ Elasticsearchæ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼å…¨æ–‡æœç´¢å¼•æ“ï¼Œå®ƒæ„å»ºåœ¨Apache Luceneåº“ä¹‹ä¸Šã€‚å®ƒä¸“æ³¨äºæä¾›å¿«é€Ÿã€å¼¹æ€§å’Œå¯é çš„å…¨æ–‡æœç´¢ã€ç»“æ„åŒ–æœç´¢ã€åˆ†æå’Œå¯è§†åŒ–åŠŸèƒ½ã€‚\nè¯¦ç»†ä»‹ç»\nåˆ†å¸ƒå¼æ¶æ„ï¼š Elasticsearchè¢«è®¾è®¡ä¸ºåœ¨å¤šå°æœåŠ¡å™¨ä¸Šè¿è¡Œï¼Œå¹¶è‡ªåŠ¨ç®¡ç†æ•°æ®çš„åˆ†ç‰‡å’Œå¤åˆ¶ã€‚è¿™ä½¿å¾—å®ƒèƒ½å¤Ÿå¤„ç†å¤§è§„æ¨¡çš„æ•°æ®ï¼Œå¹¶æä¾›é«˜å¯ç”¨æ€§å’Œå®¹é”™æ€§ã€‚\nå…¨æ–‡æœç´¢ï¼š Elasticsearchä½¿ç”¨å€’æ’ç´¢å¼•æŠ€æœ¯ï¼Œå¯ä»¥é«˜æ•ˆåœ°è¿›è¡Œå…¨æ–‡æœç´¢ã€‚å®ƒæ”¯æŒå„ç§æŸ¥è¯¢ç±»å‹ï¼ŒåŒ…æ‹¬åŒ¹é…ã€æ¨¡ç³Šæœç´¢ã€èŒƒå›´æœç´¢ç­‰ã€‚\nå®æ—¶æ•°æ®ï¼š Elasticsearchå¯¹æ•°æ®çš„æ›´æ”¹å‡ ä¹æ˜¯å®æ—¶çš„ï¼Œé€šå¸¸åœ¨æ¯«ç§’çº§åˆ«å†…å°±å¯ä»¥è¢«ç´¢å¼•å¹¶å¯æŸ¥è¯¢ã€‚è¿™ä½¿å¾—å®ƒéå¸¸é€‚åˆéœ€è¦åŠæ—¶åé¦ˆçš„åº”ç”¨åœºæ™¯ï¼Œå¦‚æ—¥å¿—åˆ†æã€ç›‘æ§æ•°æ®å¤„ç†ç­‰ã€‚\nå¤šè¯­è¨€æ”¯æŒï¼š Elasticsearchæä¾›äº†å¹¿æ³›çš„è¯­è¨€å®¢æˆ·ç«¯ï¼Œä½¿å¾—å¼€å‘äººå‘˜å¯ä»¥ä½¿ç”¨è‡ªå·±ç†Ÿæ‚‰çš„è¯­è¨€ä¸ä¹‹äº¤äº’ï¼Œå¦‚Javaã€Pythonã€Node.jsç­‰ã€‚\nå¼¹æ€§æ‰©å±•ï¼š Elasticsearchæ”¯æŒæ°´å¹³æ‰©å±•ï¼Œå¯ä»¥é€šè¿‡æ·»åŠ æ›´å¤šçš„èŠ‚ç‚¹æ¥å¢åŠ å­˜å‚¨å®¹é‡å’Œè´Ÿè½½èƒ½åŠ›ã€‚å®ƒè¿˜æä¾›äº†è‡ªåŠ¨åˆ†ç‰‡å’Œè´Ÿè½½å‡è¡¡æœºåˆ¶ï¼Œä½¿å¾—æ•°æ®åœ¨é›†ç¾¤ä¸­çš„åˆ†å¸ƒæ›´åŠ å‡åŒ€ã€‚\nå¤šç§æ•°æ®ç±»å‹æ”¯æŒï¼š é™¤äº†æ–‡æœ¬æ•°æ®ï¼ŒElasticsearchä¹Ÿå¯ä»¥å¤„ç†ç»“æ„åŒ–æ•°æ®å’Œåœ°ç†ä½ç½®æ•°æ®ã€‚å®ƒæ”¯æŒå„ç§æ•°æ®ç±»å‹çš„ç´¢å¼•å’ŒæŸ¥è¯¢ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²ã€æ•°å­—ã€æ—¥æœŸã€å¸ƒå°”å€¼ã€æ•°ç»„ç­‰ã€‚\næ˜“äºä½¿ç”¨çš„APIï¼š Elasticsearchæä¾›äº†RESTfulé£æ ¼çš„APIï¼Œå¯ä»¥ä½¿ç”¨HTTPåè®®ä¸ä¹‹è¿›è¡Œäº¤äº’ã€‚è¿™ä½¿å¾—å¼€å‘äººå‘˜å¯ä»¥è½»æ¾åœ°ç´¢å¼•ã€æŸ¥è¯¢ã€ä¿®æ”¹å’Œåˆ é™¤æ•°æ®ã€‚\næ•°æ®èšåˆä¸åˆ†æï¼š Elasticsearchæä¾›äº†ä¸°å¯Œçš„èšåˆåŠŸèƒ½ï¼Œå¯ä»¥å¯¹æ•°æ®è¿›è¡Œç»Ÿè®¡ã€åˆ†ç»„ã€ç­›é€‰å’Œæ’åºç­‰æ“ä½œã€‚åŒæ—¶ï¼Œå®ƒè¿˜é›†æˆäº†Kibanaå·¥å…·ï¼Œç”¨äºå¯è§†åŒ–å’Œåˆ†ææ•°æ®ã€‚\nHTTPçŠ¶æ€ç  1XX - æç¤ºä¿¡æ¯ 2XX - success 3XX - é‡å®šå‘ 4XX - å®¢æˆ·ç«¯é”™è¯¯ï¼Œè¯·æ±‚æœ‰è¯­æ³•é”™è¯¯orè¯·æ±‚æ— æ³•å®ç° 400 - bad request é”™è¯¯è¯·æ±‚ æœåŠ¡å™¨ä¸ç†è§£è¯·æ±‚çš„è¯­æ³• 401 - unauthorized æœªæˆæƒ è¯·æ±‚è¦æ±‚èº«ä»½éªŒè¯ 402 - ä¸ºäº†å°†æ¥å¯èƒ½çš„éœ€æ±‚è€Œé¢„ç•™çš„ 403 - forbidden ç¦æ­¢ æœåŠ¡å™¨æ‹’ç»è¯·æ±‚ 404 - not found æœªæ‰¾åˆ° æœåŠ¡å™¨æ‰¾ä¸åˆ°è¯·æ±‚çš„ç½‘é¡µ 5XX - æœåŠ¡ç«¯é”™è¯¯ï¼ŒæœåŠ¡å™¨æœªèƒ½å®ç°åˆæ³•çš„è¯·æ±‚ ä½ åœ¨å¼€å‘è¿‡ç¨‹ä¸­é‡åˆ°äº†ä»€ä¹ˆå›°éš¾ ä»¥åŠæ€ä¹ˆè§£å†³çš„ ","permalink":"https://erica423.github.io/posts/tech/","summary":"goè¯­è¨€sliceå’Œmapåº•å±‚å®ç°åŸç† sliceå’Œmapéƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œé•¿åº¦ä¸å›ºå®šã€‚ sliceåº•å±‚ï¼š sliceæŒ‡å‘ä¸€ä¸ªåº•å±‚arrayï¼Œå£°æ˜æ—¶ä¸","title":"Goç›¸å…³"},{"content":" 2024æš‘æœŸæ‰¾å®ä¹ å­¦ä¹ è¿›åº¦\nè®¡åˆ’ï¼šgolangåç«¯å¼€å‘ å®ä¹ çš„å‡†å¤‡ç¨‹åº¦:\næ•°æ®ç»“æ„ä¸ç®—æ³•: ä»£ç éšæƒ³å½•4 åˆ·, éƒ¨åˆ†labuladongç¬”è®° å‰‘æŒ‡offer1 leetcode 350\nè®¡ç®—æœºç½‘ç»œ: å°æ—codingå›¾è§£ç½‘ç»œ è®¡ç®—æœºç½‘ç»œè‡ªé¡¶å‘ä¸‹\næ“ä½œç³»ç»Ÿ: å°æ—codingå›¾è§£ç³»ç»Ÿ æ“ä½œç³»ç»Ÿå¯¼è®º\nMysql: MySQLå¿…çŸ¥å¿…ä¼š ä»æ ¹ä¸Šç†è§£MySQL å°æ—MySQLå›¾è§£\nRedis: Redisè®¾è®¡ä¸å®ç° å°æ—coding Rediséƒ¨åˆ†\nç¼–ç¨‹è¯­è¨€:\nGo: Goè¯­è¨€åœ£ç» GoWebç¼–ç¨‹ Goè¯­è¨€è®¾è®¡ä¸å®ç° Goä¸“å®¶ç¼–ç¨‹\nC++: \u0026lt;C++ Primer\u0026gt; \u0026lt;Efficient C++\u0026gt; \u0026lt;TCP/IPç½‘ç»œç¼–ç¨‹\u0026gt;\né¡¹ç›®å†™ä¸€ä¸ªRediså•æœºæœåŠ¡å™¨, å¦å¤–è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯https://betxin.oneäº†\nGo 1. è¯­è¨€åŸºç¡€ ã€ŠGoè¯­è¨€å­¦ä¹ ç¬”è®°ã€‹ï¼ˆè¯­æ³•éƒ¨åˆ†ï¼‰ å•æµ‹ç»ƒæ‰‹ï¼šlearn-go-with-tests ï¼ˆå…¨éƒ¨éƒ¨åˆ†ï¼‰ Goåº•å±‚ bç«™è§†é¢‘ 2. è¿›é˜¶ ã€ŠGo Webç¼–ç¨‹ã€‹link ï¼ˆ5.9 finishï¼‰ Gin (5.10) Gorm æ–‡æ¡£ å¾®æœåŠ¡æ¡†æ¶ï¼šgo-zero (âˆš) / kratos 3. é¡¹ç›® pacgo åƒè±†å­é¡¹ç›® 7daysGolang link Gee link go-gin-example link æ­å»ºè‡ªå·±çš„blogï¼šé™æ€Hugoï¼Œç»´æŠ¤ä¸­\u0026hellip; åœ¨å­¦é¡¹ç›®ï¼šåŸºäºgo-zeroçš„IMå®æ—¶èŠå¤©é¡¹ç›® Goé¢ç» Goå¤§å‚é¢è¯•çœŸé¢˜(130é¡µ-å¸¦ç­”æ¡ˆ).pdf Goåç«¯å¼€å‘å¤§å‚é¢è¯•é¢˜(å…«è‚¡æ–‡-188é¡µ-å¸¦ç­”æ¡ˆ).pdf Golangä¿®å…»ä¹‹è·¯.pdf Golangå¼€å‘å²—é¢è¯•ç¬”è®°(26é¡µ-å¸¦ç­”æ¡ˆ).pdf Goç¨‹åºå‘˜é¢è¯•ç¬”è¯•å®å…¸.txt é“¾æ¥ Golangå¸¸è§é¢è¯•é¢˜è§£æ(129é¡µ-å¸¦ç­”æ¡ˆ).pdf ç®—æ³• ä»£ç éšæƒ³å½•: é“¾æ¥\næ•°ç»„ é“¾è¡¨ å“ˆå¸Œè¡¨ å­—ç¬¦ä¸² åŒæŒ‡é’ˆæ³• æ ˆå’Œé˜Ÿåˆ— äºŒå‰æ ‘ å›æº¯ç®—æ³• è´ªå¿ƒç®—æ³• åŠ¨æ€è§„åˆ’ å•è°ƒæ ˆ å›¾è®º ã€‚ã€‚ã€‚ ","permalink":"https://erica423.github.io/posts/todo/","summary":"2024æš‘æœŸæ‰¾å®ä¹ å­¦ä¹ è¿›åº¦ è®¡åˆ’ï¼šgolangåç«¯å¼€å‘ å®ä¹ çš„å‡†å¤‡ç¨‹åº¦: æ•°æ®ç»“æ„ä¸ç®—æ³•: ä»£ç éšæƒ³å½•4 åˆ·, éƒ¨åˆ†labuladongç¬”è®° å‰‘æŒ‡offe","title":"ToDo List"}]