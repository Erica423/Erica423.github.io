<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>单元测试 | Erica-Blog</title>
<meta name=keywords content="技术"><meta name=description content="GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通"><meta name=author content="erica423"><link rel=canonical href=https://erica423.github.io/posts/singletest/><link crossorigin=anonymous href=/assets/css/stylesheet.0fd2af49d7c8b1a279992ba82155f4ce3b1d94189758b3b0a99c8692cfdc0be9.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=16x16 href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=32x32 href=https://erica423.github.io/images/dls_icon.png><link rel=apple-touch-icon href=https://erica423.github.io/images/dls_icon.png><link rel=mask-icon href=https://erica423.github.io/images/dls_icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://erica423.github.io/posts/singletest/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>(function(){""&&prompt("请输入文章密码")!==""&&(alert("密码错误！"),history.back())})()</script><link rel=stylesheet href=https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap" rel=stylesheet><script src=https://unpkg.com/@waline/client@v2/dist/waline.js></script><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><meta property="og:title" content="单元测试"><meta property="og:description" content="GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通"><meta property="og:type" content="article"><meta property="og:url" content="https://erica423.github.io/posts/singletest/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-23T15:52:48+08:00"><meta property="article:modified_time" content="2024-06-23T15:52:48+08:00"><meta property="og:site_name" content="erica-blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="单元测试"><meta name=twitter:description content="GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erica423.github.io/posts/"},{"@type":"ListItem","position":2,"name":"单元测试","item":"https://erica423.github.io/posts/singletest/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"单元测试","name":"单元测试","description":"GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通","keywords":["技术"],"articleBody":" GO在线编译器：go playground\nTest-Driven Development(TDD) - 测试驱动开发 周期：\n编写一个测试\n让编译通过\n运行测试，查看失败原因并检查错误消息是很有意义的\n编写足够的代码以使测试通过\n重构\n常用功能 测试文件命名规则：xxx_test.go, 与xxx.go放在同一个package下\n测试函数命令以Test开头\n测试函数只接受一个*testing.T类型的参数t （t就是测试框架中的钩子hook）\nt.Errorf(): 格式化记录错误信息，但测试继续进行。f 表示格式化，允许我们构建一个字符串，并将值插入占位符值 %q 中。\nt.Fatalf(): 报告致命错误，并终止测试。\nt.Fail(): 标记测试结果为失败的，不同的是t.Fail只把测试结果标记为失败，不会终止当前测试，t.FailNow则会立即终止当前的测试函数，并标记为失败。\nt.Helper(): 告诉测试套件这个方法是辅助函数（helper）。通过这样做，当测试失败时所报告的行号将在函数调用中而不是在辅助函数内部。\nSubtest - 子测试 有时，对一个「事情」进行分组测试，然后再对不同场景进行子测试非常有效。\n1 2 3 4 5 6 7 8 9 func TestMain(t *testing.T) { t.Run(\"show expected output of this function\", func(t *testing.T) { }) t.Run(\"...\", func(t *testing.T) { }) } 这种方法的好处是，你可以建立在其他测试中也能够使用的共享代码。 重要的是，你的测试清楚地说明了代码需要做什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func TestHello(t *testing.T) { assertCorrectMessage := func(t *testing.T, got, want string) { t.Helper() if got != want { t.Errorf(\"got '%q' want '%q'\", got, want) } } t.Run(\"saying hello to people\", func(t *testing.T) { got := Hello(\"Chris\") want := \"Hello, Chris\" assertCorrectMessage(t, got, want) }) t.Run(\"empty string defaults to 'world'\", func(t *testing.T) { got := Hello(\"\") want := \"Hello, World\" assertCorrectMessage(t, got, want) }) } 及时添加注释，方便生成API文档 Swagger自动生成文档\nsyntax 句法\nAdd AND assignment operactor 自增赋值运算符 +=\n数组 \u0026 切片 we are using the %v placeholder to print the “default” format, which works well for arrays.\n在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种比较简单的办法是使用 reflect.DeepEqual，它在判断两个变量是否相等时十分有用。但不是类型安全的。\n接口 在 Go 语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。\n测试覆盖率 1 go test -cover Table driven tests - 表格驱动测试 适合处理同质化的测试内容, 如果你要测试一个接口的不同实现，或者传入函数的数据有很多不同的测试需求，这个武器将非常给力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func TestArea(t *testing.T) { areaTests := []struct { shape Shape want float64 }{ {Rectangle{10.0, 20.0}, 200.0}, {Circle{10.0}, 314.1592653589793}, } for _, tt := range areaTests { got := tt.shape.Area() if got != tt.want { t.Errorf(\"want %.2f but got %.2f\", tt.want, got) } } } 使用了匿名结构体 - anonymous struct, 用含有两个域 shape 和 want 的 []struct 声明了一个结构体切片。\n可以改进错误输出为 %#v got %.2f want %.2f. %#v，这样会打印结构体中域的值。能一眼看出被测试的属性。\n关于列表驱动测试的最后一点提示是使用 t.Run。\n在每个用例中使用 t.Run，测试用例的错误输出中会包含用例的名字：\n1 2 3 -------- FAIL: TestArea (0.00s) --- FAIL: TestArea/Rectangle (0.00s) shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10 运行列表中指定的测试用例：go test -run TestArea/Rectangle\n检查未经检查的error 有一种情况我们还没有测试过。要找到它，在一个终端中运行以下命令来安装 errcheck，这是许多可用的 linters（代码检测工具）之一。\ngo get -u github.com/kisielk/errcheck\n然后，在代码目录中运行 errcheck .\n依赖注入： io.Writer 是一个很好的通用接口，用于「将数据放在某个地方」。\nfmt.Fprintf 和 fmt.Printf 一样，只不过 fmt.Fprintf 会接收一个 Writer 参数，用于把字符串传递过去，而 fmt.Printf 默认是标准输出。\n注入 - Mocking 将依赖关系定义为一个接口。这样我们就可以在 main 使用 真实的 Sleeper，并且在我们的测试中使用 spy sleeper。通过使用接口，我们的 Countdown 函数忽略了这一点，并为调用者增加了一些灵活性。\nConcurrency 匿名函数有许多有用的特性。首先，它们可以在声明的同时执行 —— 这就是匿名函数末尾的 () 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。\n上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（WebsiteChecker 函数）同时发生，每个循环都会将结果添加到 results map 中。\n1 2 3 4 5 6 7 for _, url := range urls { go func() { results[url] = wc(url) }() } time.Sleep(2 * time.Second) 这里的问题是变量 url 被重复用于 for 循环的每次迭代 —— 每次都会从 urls 获取新值。但是我们的每个 goroutine 都是 url 变量的引用 —— 它们没有自己的独立副本。所以他们 都 会写入在迭代结束时的 url —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url。\n1 2 3 4 5 6 7 for _, url := range urls { go func(u string) { results[u] = wc(u) }(url) } time.Sleep(2 * time.Second) 通过给每个匿名函数一个参数 url(u)，然后用 url 作为参数调用匿名函数，我们确保 u 的值固定为循环迭代的 url 值，重新启动 goroutine。u 是 url 值的副本，因此无法更改。\n用channel解决数据竞争 data race\ngoroutines 是 Go 的基本并发单元，它让我们可以同时检查多个网站。\nanonymous functions（匿名函数），我们用它来启动每个检查网站的并发进程。\nchannels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。\nthe race detector（竞争探测器） 帮助我们调试并发代码的问题。\n使用 select 时，time.After 是一个很好用的函数。当你监听的 channel 永远不会返回一个值时你可以潜在地编写永远阻塞的代码，尽管在我们的案例中它没有发生。time.After 会在你定义的时间过后发送一个信号给 channel 并返回一个 chan 类型（就像 ping 那样）。\nvalue 有一个方法 NumField，它返回值中的字段数\nSync Sync\nWaitGroup 等待 goroutine 集合完成。主 goroutine 调用 Add 设置等待的 goroutine 数量。然后每个 goroutine 运行并在完成时调用 Done。同时，Wait 可以用来阻塞，直到所有 goroutine 都完成。\n通过在做出断言之前等待wg.Wait()完成，我们可以确定所有的 goroutine 都已尝试Inc过Counter。\nA Mutex must not be copied after first use. Use channels when passing ownership of data\nUse mutexes for managing state\nContext context\n我们所做的是从我们的request中派生一个新的 cancellingCtx，它返回一个cancel函数。然后，我们使用 time.AfterFunc 安排在 5 毫秒内调用该函数。最后，我们通过调用 request.WithContext 在请求中使用这个新上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func Server(store Store) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { ctx := r.Context() data := make(chan string, 1) go func() { data \u003c- store.Fetch() }() select { case d := \u003c-data: fmt.Fprint(w, d) case \u003c-ctx.Done(): store.Cancel() } } } context有一个方法Done()返回一个channel，当context“完成”或“取消”时，该通道会发送信号。 我们想要监听该信号并在收到该信号时调用 store.Cancel，但如果我们Store设法在Fetch它之前就忽略它。\n对服务器的传入请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传播上下文，可以选择将其替换为使用 WithCancel、WithDeadline、WithTimeout 或 WithValue 创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。\nProperty based tests strings.Builder 用于使用写入方法高效构建字符串。它最大限度地减少了内存复制。\n罗马数字的规则是同一字符不能在一行中重复超过 3 次。 取而代之的是取下一个最高的符号，然后在其左侧放置一个符号来 “减去”。 并非所有符号都可以用作减法器；只有 I (1)、X (10) 和 C (100)。\n例如，罗马数字中的 5 是 V。要创建 4，您不执行 IIII，而是执行 IV。\nRomanNumeral规则：\n不能有超过 3 个连续的符号\n只有 I (1), X (10) 和 C (100) 是 「减法器」\n将 ConvertToRoman(N) 的结果传递给 ConvertToArabic ，应该返回 N。\n基于属性的测试通过向代码中抛出随机数据并验证所描述的规则始终为真来帮助您做到这一点。很多人认为基于属性的测试主要是关于随机数据的，但他们是错误的。 基于属性的测试面临的真正挑战是你对你的领域有「很好的」理解，这样您就可以编写这些属性。\n从底部读取，我们为 quick.Check 提供了一个函数，它将运行一些随机的输入，如果函数返回 false，它将被视为检查失败。\n上面的 assertion 函数接受随机数并运行函数来测试属性。\n你不能用罗马数字表示负数\n根据我们最多 3 个连续符号的规则，我们不能表示大于 3999 的值 (罗马数字的最大值)，而 int 的最大值比 3999 大得多。 因此使用uint16\n内置的路由机制叫做 ServeMux（request multiplexer，多路请求复用器），它允许你将 http.Handler 附加到特定的请求路径。\nWe changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.\nGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.\n这意味着我们的 PlayerServer 现在已经有了 http.Handler 所有的方法，也就是 ServeHTTP。\n为了 “填充” http.Handler，我们将它分配给我们在 NewPlayerServer 中创建的 router。我们可以这样做是因为 http.ServeMux 具有 ServeHTTP 方法。\n这允许我们删除我们的 ServeHTTP 方法，因为我们已经通过嵌入类型公开了它。\n嵌入是一个非常有意思的语法特性。你可以用它将接口组成新的接口。\nIO和排序 服务器重启会重置积分\nos.OpenFile 允许你定义打开文件的权限，在我们的例子中，O_RDWR 意味着我们想要读写权限，os.O_CREATE 是指如果文件不存在，则创建该文件。\n创建一个新类型来封装我们的「当写入时，从头部开始」功能。我把它叫做 Tape.\nfile.Stat 返回我们的文件的统计数据。我们可以检查文件的大小，如果它是空的，我们就会编写一个空的 JSON 数组，然后 Seek 到开始位置，为剩下的代码做准备。\n命令行和项目结构 当用户输入 Ruth wins 时，它只需要能够记录玩家的胜出情况，最终目的是作为一个帮助用户玩扑克的工具。\n产品负责人希望在两个应用程序之间共享数据库，以便玩家league根据新程序中记录的wins进行更新。\n第一个需求就是当用户输入 {PlayerName} wins 时记录一次胜利。\nbufio 包实现了 I/O 缓冲。它封装了一个 io.Reader 或 io.Writer 对象，创建了另一个对象（Reader 或 Writer），也实现了接口，并为文本 I/O 提供了缓冲和一些帮助。\nScanner.Scan() 会逐行读取内容。 然后使用 Scanner.Text() 来返回 scanner 读取的 string。 我们将它封装到一个名为 readLine() 的函数中。\nBenchmarking - 基准测试 用 go test -bench=. 来运行基准测试。 (如果在 Windows Powershell 环境下使用 go test -bench=\".\")\nTips: benchmarks默认顺序执行。\n1 2 3 4 5 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u003c b.N; i ++ { Repeat(\"A\") } } testing.B 可使你访问隐性命名（cryptically named）b.N。\n基准测试运行时，代码会运行 b.N 次，并测量需要多长时间。\n代码运行的次数不会对你产生影响，测试框架会选择一个它所认为的最佳值，以便让你获得更合理的结果。\nGoConvey（测试框架） 1 2 import \"github.com/smartystreets/goconvey/convey\" go get github.com/smartystreets/goconvey convey.Convey 定义了测试用例名称、t 指针、测试代码。 convey.So` 用来判断预期结果。 convey 提供了大量的断言函数，比如刚才使用的 convey.ShouldBeTrue，就是判断 ok 的值应该为 true。\n1 2 3 4 5 6 func TestCheckUrl(t *testing.T) { convey.Convey(\"TestCheckTeachUrl\", t, func() { ok:=CheckUrl(\"learnku.com\") convey.So(ok,convey.ShouldBeTrue) }) } GoConvey 官方文档：Assertions · smartystreets/goconvey Wiki · GitHub\nTestify（断言） Testify 也是一个断言库，功能相对于 GoConvey 而言比较简单，主要是在提供断言功能之外，提供了 mock 的功能。\n1 2 import \"github.com/stretchr/testify\" go get -t github.com/stretchr/testify eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func TestCheckUrl3(t *testing.T) { assert := assert.New(t) var tests = []struct { input string expected bool }{ {\"xdcute.com\", true}, {\"xxx.com\", false}, } for _, test := range tests { fmt.Println(test.input) assert.Equal(CheckUrl(test.input), test.expected) } } GoMock（模拟接口） mock 工具的作用是指定函数的行为（模拟函数的行为）。可以对入参进行校验，对出参进行设定，还可以指定函数的返回值。\n并行测试 func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试。\nRunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。\n参考文章 “https://studygolang.gitbook.io/learn-go-with-tests/\" “https://quii.gitbook.io/learn-go-with-tests/\" ","wordCount":"4522","inLanguage":"en","datePublished":"2024-06-23T15:52:48+08:00","dateModified":"2024-06-23T15:52:48+08:00","author":{"@type":"Person","name":"erica423"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erica423.github.io/posts/singletest/"},"publisher":{"@type":"Organization","name":"Erica-Blog","logo":{"@type":"ImageObject","url":"https://erica423.github.io/images/dls_icon.png"}}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erica423.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://erica423.github.io/images/dls_icon.png alt aria-label=logo height=25>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://erica423.github.io/archives/ title=🎮动态><span>🎮动态</span></a></li><li><a href=https://erica423.github.io/tags/ title=🎲标签><span>🎲标签</span></a></li><li><a href=https://erica423.github.io/search/ title="🎯搜索 (Alt + /)" accesskey=/><span>🎯搜索</span></a></li><li><a href=https://github.com/Erica423/Erica423.github.io/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erica423.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://erica423.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">单元测试</h1><div class=post-meta><span title='2024-06-23 15:52:48 +0800 +0800'>June 23, 2024</span>&nbsp;·&nbsp;erica423&nbsp;|&nbsp;<a href=https://github.com/Erica423/Erica423.github.io rel="noopener noreferrer" target=_blank>主页</a><div class=meta-item>&nbsp·&nbsp
	      <span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#test-driven-developmenttdd---测试驱动开发>Test-Driven Development(TDD) - 测试驱动开发</a><ul><li><a href=#常用功能>常用功能</a></li><li><a href=#subtest---子测试>Subtest - 子测试</a></li><li><a href=#及时添加注释方便生成api文档>及时添加注释，方便生成API文档</a></li><li><a href=#数组--切片>数组 & 切片</a></li><li><a href=#接口>接口</a></li><li><a href=#测试覆盖率>测试覆盖率</a></li></ul></li><li><a href=#table-driven-tests---表格驱动测试>Table driven tests - 表格驱动测试</a><ul><li><a href=#注入---mocking>注入 - Mocking</a></li><li><a href=#concurrency>Concurrency</a></li><li><a href=#sync>Sync</a></li><li><a href=#context>Context</a></li><li><a href=#property-based-tests>Property based tests</a></li><li><a href=#io和排序>IO和排序</a></li><li><a href=#命令行和项目结构>命令行和项目结构</a></li></ul></li><li><a href=#benchmarking---基准测试>Benchmarking - 基准测试</a></li><li><a href=#goconvey测试框架>GoConvey（测试框架）</a></li><li><a href=#testify断言>Testify（断言）</a></li><li><a href=#gomock模拟接口>GoMock（模拟接口）</a></li><li><a href=#并行测试>并行测试</a></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></details></div><div class=post-content><hr><p>GO在线编译器：<a href=https://go.dev/play/p/ICCWcRGIO68>go playground</a></p><h2 id=test-driven-developmenttdd---测试驱动开发>Test-Driven Development(TDD) - 测试驱动开发<a hidden class=anchor aria-hidden=true href=#test-driven-developmenttdd---测试驱动开发>#</a></h2><p>周期：</p><ol><li><p>编写一个测试</p></li><li><p>让编译通过</p></li><li><p>运行测试，查看失败原因并检查错误消息是很有意义的</p></li><li><p>编写足够的代码以使测试通过</p></li><li><p>重构</p></li></ol><h3 id=常用功能>常用功能<a hidden class=anchor aria-hidden=true href=#常用功能>#</a></h3><ul><li><p>测试文件命名规则：<code>xxx_test.go</code>, 与<code>xxx.go</code>放在同一个package下</p></li><li><p>测试函数命令以<code>Test</code>开头</p></li><li><p>测试函数只接受一个<code>*testing.T</code>类型的参数t （t就是测试框架中的钩子hook）</p></li><li><p><code>t.Errorf()</code>: 格式化记录错误信息，但测试继续进行。<code>f</code> 表示格式化，允许我们构建一个字符串，并将值插入占位符值 <code>%q</code> 中。</p></li><li><p><code>t.Fatalf()</code>: 报告致命错误，并终止测试。</p></li><li><p><code>t.Fail()</code>: 标记测试结果为失败的，不同的是<code>t.Fail</code>只把测试结果标记为失败，不会终止当前测试，<code>t.FailNow</code>则会立即终止当前的测试函数，并标记为失败。</p></li><li><p><code>t.Helper()</code>: 告诉测试套件这个方法是辅助函数（helper）。通过这样做，当测试失败时所报告的行号将在函数调用中而不是在辅助函数内部。</p></li></ul><h3 id=subtest---子测试>Subtest - 子测试<a hidden class=anchor aria-hidden=true href=#subtest---子测试>#</a></h3><p>有时，对一个「事情」进行分组测试，然后再对不同场景进行子测试非常有效。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMain</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;show expected output of this function&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这种方法的好处是，你可以建立在其他测试中也能够使用的共享代码。
重要的是，你的测试清楚地说明了代码需要做什么。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestHello</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>assertCorrectMessage</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>,</span> <span class=nx>got</span><span class=p>,</span> <span class=nx>want</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Helper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>got</span> <span class=o>!=</span> <span class=nx>want</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;got &#39;%q&#39; want &#39;%q&#39;&#34;</span><span class=p>,</span> <span class=nx>got</span><span class=p>,</span> <span class=nx>want</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;saying hello to people&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span> <span class=o>:=</span> <span class=nf>Hello</span><span class=p>(</span><span class=s>&#34;Chris&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span> <span class=o>:=</span> <span class=s>&#34;Hello, Chris&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nf>assertCorrectMessage</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>got</span><span class=p>,</span> <span class=nx>want</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;empty string defaults to &#39;world&#39;&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>got</span> <span class=o>:=</span> <span class=nf>Hello</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>want</span> <span class=o>:=</span> <span class=s>&#34;Hello, World&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nf>assertCorrectMessage</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>got</span><span class=p>,</span> <span class=nx>want</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=及时添加注释方便生成api文档>及时添加注释，方便生成API文档<a hidden class=anchor aria-hidden=true href=#及时添加注释方便生成api文档>#</a></h3><p><a href=https://zhuanlan.zhihu.com/p/679637398>Swagger自动生成文档</a></p><blockquote><p>syntax 句法</p><p>Add AND assignment operactor 自增赋值运算符 +=</p></blockquote><h3 id=数组--切片>数组 & 切片<a hidden class=anchor aria-hidden=true href=#数组--切片>#</a></h3><p>we are using the <code>%v</code> placeholder to print the &ldquo;default&rdquo; format, which works well for arrays.</p><p>在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种比较简单的办法是使用 <code>reflect.DeepEqual</code>，它在判断两个变量是否相等时十分有用。<strong>但不是类型安全的</strong>。</p><h3 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h3><p>在 Go 语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。</p><h3 id=测试覆盖率>测试覆盖率<a hidden class=anchor aria-hidden=true href=#测试覆盖率>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=nx>test</span> <span class=o>-</span><span class=nx>cover</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=table-driven-tests---表格驱动测试>Table driven tests - 表格驱动测试<a hidden class=anchor aria-hidden=true href=#table-driven-tests---表格驱动测试>#</a></h2><p>适合处理同质化的测试内容, 如果你要测试一个接口的不同实现，或者传入函数的数据有很多不同的测试需求，这个武器将非常给力。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestArea</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>areaTests</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>shape</span> <span class=nx>Shape</span>
</span></span><span class=line><span class=cl>		<span class=nx>want</span>  <span class=kt>float64</span>
</span></span><span class=line><span class=cl>	<span class=p>}{</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>Rectangle</span><span class=p>{</span><span class=mf>10.0</span><span class=p>,</span> <span class=mf>20.0</span><span class=p>},</span> <span class=mf>200.0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>Circle</span><span class=p>{</span><span class=mf>10.0</span><span class=p>},</span> <span class=mf>314.1592653589793</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>areaTests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>got</span> <span class=o>:=</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>shape</span><span class=p>.</span><span class=nf>Area</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>got</span> <span class=o>!=</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>want</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>t</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;want %.2f but got %.2f&#34;</span><span class=p>,</span> <span class=nx>tt</span><span class=p>.</span><span class=nx>want</span><span class=p>,</span> <span class=nx>got</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>使用了匿名结构体 - anonymous struct, 用含有两个域 shape 和 want 的 []struct 声明了一个结构体切片。</p><p>可以改进错误输出为 <code>%#v got %.2f want %.2f. %#v</code>，这样会打印结构体中域的值。能一眼看出被测试的属性。</p><p>关于列表驱动测试的最后一点提示是使用 t.Run。</p><p>在每个用例中使用 <code>t.Run</code>，测试用例的错误输出中会包含用例的名字：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-------- FAIL: TestArea (0.00s)
</span></span><span class=line><span class=cl>    --- FAIL: TestArea/Rectangle (0.00s)
</span></span><span class=line><span class=cl>        shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10
</span></span></code></pre></td></tr></table></div></div><p>运行列表中指定的测试用例：<code>go test -run TestArea/Rectangle</code></p><ul><li>检查未经检查的error</li></ul><p>有一种情况我们还没有测试过。要找到它，在一个终端中运行以下命令来安装 errcheck，这是许多可用的 linters（代码检测工具）之一。</p><p><code>go get -u github.com/kisielk/errcheck</code></p><p>然后，在代码目录中运行 <code>errcheck .</code></p><ul><li>依赖注入：</li></ul><p><code>io.Writer</code> 是一个很好的通用接口，用于「将数据放在某个地方」。</p><p><code>fmt.Fprintf</code> 和 <code>fmt.Printf</code> 一样，只不过 fmt.Fprintf 会接收一个 Writer 参数，用于把字符串传递过去，而 fmt.Printf 默认是标准输出。</p><h3 id=注入---mocking>注入 - Mocking<a hidden class=anchor aria-hidden=true href=#注入---mocking>#</a></h3><p>将依赖关系定义为一个接口。这样我们就可以在 main 使用 真实的 Sleeper，并且在我们的测试中使用 spy sleeper。通过使用接口，我们的 Countdown 函数忽略了这一点，并为调用者增加了一些灵活性。</p><h3 id=concurrency>Concurrency<a hidden class=anchor aria-hidden=true href=#concurrency>#</a></h3><p>匿名函数有许多有用的特性。首先，它们可以<strong>在声明的同时执行</strong> —— 这就是匿名函数末尾的 () 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。</p><p>上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（WebsiteChecker 函数）同时发生，每个循环都会将结果添加到 results map 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>results</span><span class=p>[</span><span class=nx>url</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的问题是变量 url 被重复用于 for 循环的每次迭代 —— 每次都会从 urls 获取新值。但是我们的每个 goroutine 都是 url 变量的引用 —— 它们没有自己的独立副本。所以他们 都 会写入在迭代结束时的 url —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>url</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>results</span><span class=p>[</span><span class=nx>u</span><span class=p>]</span> <span class=p>=</span> <span class=nf>wc</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>通过给每个匿名函数一个参数 url(u)，然后用 url 作为参数调用匿名函数，我们确保 u 的值固定为循环迭代的 url 值，重新启动 goroutine。u 是 url 值的副本，因此无法更改。</p><p>用channel解决数据竞争 data race</p><ul><li><p>goroutines 是 Go 的基本并发单元，它让我们可以同时检查多个网站。</p></li><li><p>anonymous functions（匿名函数），我们用它来启动每个检查网站的并发进程。</p></li><li><p>channels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。</p></li><li><p>the race detector（竞争探测器） 帮助我们调试并发代码的问题。</p></li></ul><p>使用 select 时，time.After 是一个很好用的函数。当你监听的 channel 永远不会返回一个值时你可以潜在地编写永远阻塞的代码，尽管在我们的案例中它没有发生。time.After 会在你定义的时间过后发送一个信号给 channel 并返回一个 chan 类型（就像 ping 那样）。</p><p>value 有一个方法 NumField，它返回值中的字段数</p><h3 id=sync>Sync<a hidden class=anchor aria-hidden=true href=#sync>#</a></h3><p><a href=https://pkg.go.dev/sync#WaitGroup>Sync</a></p><p>WaitGroup 等待 goroutine 集合完成。主 goroutine 调用 Add 设置等待的 goroutine 数量。然后每个 goroutine 运行并在完成时调用 Done。同时，Wait 可以用来阻塞，直到所有 goroutine 都完成。</p><p>通过在做出断言之前等待wg.Wait()完成，我们可以确定所有的 goroutine 都已尝试Inc过Counter。</p><p>A Mutex must not be copied after first use.
Use channels when passing ownership of data</p><p>Use mutexes for managing state</p><h3 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h3><p><a href=https://go.dev/blog/context>context</a></p><p>我们所做的是从我们的request中派生一个新的 cancellingCtx，它返回一个cancel函数。然后，我们使用 time.AfterFunc 安排在 5 毫秒内调用该函数。最后，我们通过调用 request.WithContext 在请求中使用这个新上下文。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Server</span><span class=p>(</span><span class=nx>store</span> <span class=nx>Store</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Context</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>data</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>data</span> <span class=o>&lt;-</span> <span class=nx>store</span><span class=p>.</span><span class=nf>Fetch</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>d</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>data</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprint</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>			<span class=nx>store</span><span class=p>.</span><span class=nf>Cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>context有一个方法Done()返回一个channel，当context“完成”或“取消”时，该通道会发送信号。
我们想要监听该信号并在收到该信号时调用 <code>store.Cancel</code>，但如果我们Store设法在Fetch它之前就忽略它。</p><p>对服务器的传入请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传播上下文，可以选择将其替换为使用 WithCancel、WithDeadline、WithTimeout 或 WithValue 创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><h3 id=property-based-tests>Property based tests<a hidden class=anchor aria-hidden=true href=#property-based-tests>#</a></h3><p>strings.Builder 用于使用写入方法高效构建字符串。它最大限度地减少了内存复制。</p><p>罗马数字的规则是同一字符不能在一行中重复超过 3 次。
取而代之的是取下一个最高的符号，然后在其左侧放置一个符号来 “减去”。
并非所有符号都可以用作减法器；只有 I (1)、X (10) 和 C (100)。</p><p>例如，罗马数字中的 5 是 V。要创建 4，您不执行 IIII，而是执行 IV。</p><p>RomanNumeral规则：</p><ul><li><p>不能有超过 3 个连续的符号</p></li><li><p>只有 I (1), X (10) 和 C (100) 是 「减法器」</p></li><li><p>将 ConvertToRoman(N) 的结果传递给 ConvertToArabic ，应该返回 N。</p></li></ul><p>基于属性的测试通过向代码中抛出随机数据并验证所描述的规则始终为真来帮助您做到这一点。很多人认为基于属性的测试主要是关于随机数据的，但他们是错误的。 基于属性的测试面临的真正挑战是你对你的领域有「很好的」理解，这样您就可以编写这些属性。</p><p>从底部读取，我们为 quick.Check 提供了一个函数，它将运行一些随机的输入，如果函数返回 false，它将被视为检查失败。</p><p>上面的 assertion 函数接受随机数并运行函数来测试属性。</p><ul><li><p>你不能用罗马数字表示负数</p></li><li><p>根据我们最多 3 个连续符号的规则，我们不能表示大于 3999 的值 (罗马数字的最大值)，而 int 的最大值比 3999 大得多。
因此使用<code>uint16</code></p></li></ul><p>内置的路由机制叫做 ServeMux（request multiplexer，多路请求复用器），它允许你将 http.Handler 附加到特定的请求路径。</p><p>We changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.</p><p>Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.</p><p>这意味着我们的 PlayerServer 现在已经有了 http.Handler 所有的方法，也就是 ServeHTTP。</p><p>为了 “填充” http.Handler，我们将它分配给我们在 NewPlayerServer 中创建的 router。我们可以这样做是因为 http.ServeMux 具有 ServeHTTP 方法。</p><p>这允许我们删除我们的 ServeHTTP 方法，因为我们已经通过嵌入类型公开了它。</p><p>嵌入是一个非常有意思的语法特性。你可以用它将接口组成新的接口。</p><h3 id=io和排序>IO和排序<a hidden class=anchor aria-hidden=true href=#io和排序>#</a></h3><p>服务器重启会重置积分</p><p><code>os.OpenFile</code> 允许你定义打开文件的权限，在我们的例子中，<code>O_RDWR</code> 意味着我们想要读写权限，<code>os.O_CREATE</code> 是指如果文件不存在，则创建该文件。</p><p>创建一个新类型来封装我们的「当写入时，从头部开始」功能。我把它叫做 Tape.</p><p>file.Stat 返回我们的文件的统计数据。我们可以检查文件的大小，如果它是空的，我们就会编写一个空的 JSON 数组，然后 Seek 到开始位置，为剩下的代码做准备。</p><h3 id=命令行和项目结构>命令行和项目结构<a hidden class=anchor aria-hidden=true href=#命令行和项目结构>#</a></h3><p>当用户输入 Ruth wins 时，它只需要能够记录玩家的胜出情况，最终目的是作为一个帮助用户玩扑克的工具。</p><p>产品负责人希望在两个应用程序之间共享数据库，以便玩家league根据新程序中记录的wins进行更新。</p><ul><li><p>第一个需求就是当用户输入 {PlayerName} wins 时记录一次胜利。</p></li><li><p>bufio 包实现了 I/O 缓冲。它封装了一个 io.Reader 或 io.Writer 对象，创建了另一个对象（Reader 或 Writer），也实现了接口，并为文本 I/O 提供了缓冲和一些帮助。</p></li><li><p>Scanner.Scan() 会逐行读取内容。
然后使用 Scanner.Text() 来返回 scanner 读取的 string。
我们将它封装到一个名为 readLine() 的函数中。</p></li></ul><h2 id=benchmarking---基准测试>Benchmarking - 基准测试<a hidden class=anchor aria-hidden=true href=#benchmarking---基准测试>#</a></h2><p>用 <code>go test -bench=.</code> 来运行基准测试。 (如果在 Windows Powershell 环境下使用 <code>go test -bench="."</code>)</p><p>Tips: benchmarks默认顺序执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkRepeat</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Repeat</span><span class=p>(</span><span class=s>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>testing.B</code> 可使你访问隐性命名（cryptically named）<code>b.N</code>。</p><p>基准测试运行时，代码会运行 <code>b.N</code> 次，并测量需要多长时间。</p><p>代码运行的次数不会对你产生影响，测试框架会选择一个它所认为的最佳值，以便让你获得更合理的结果。</p><h2 id=goconvey测试框架>GoConvey（测试框架）<a hidden class=anchor aria-hidden=true href=#goconvey测试框架>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/smartystreets/goconvey/convey&#34;</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=nx>get</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>smartystreets</span><span class=o>/</span><span class=nx>goconvey</span>
</span></span></code></pre></td></tr></table></div></div><p><code>convey.Convey</code> 定义了测试用例名称、t 指针、测试代码。
<code>convey.S</code>o` 用来判断预期结果。
convey 提供了大量的断言函数，比如刚才使用的 convey.ShouldBeTrue，就是判断 ok 的值应该为 true。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestCheckUrl</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>convey</span><span class=p>.</span><span class=nf>Convey</span><span class=p>(</span><span class=s>&#34;TestCheckTeachUrl&#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ok</span><span class=o>:=</span><span class=nf>CheckUrl</span><span class=p>(</span><span class=s>&#34;learnku.com&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>convey</span><span class=p>.</span><span class=nf>So</span><span class=p>(</span><span class=nx>ok</span><span class=p>,</span><span class=nx>convey</span><span class=p>.</span><span class=nx>ShouldBeTrue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>GoConvey 官方文档：<a href=https://github.com/smartystreets/goconvey/wiki/Assertions>Assertions · smartystreets/goconvey Wiki · GitHub</a></p><h2 id=testify断言>Testify（断言）<a hidden class=anchor aria-hidden=true href=#testify断言>#</a></h2><p>Testify 也是一个断言库，功能相对于 GoConvey 而言比较简单，主要是在提供断言功能之外，提供了 mock 的功能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/stretchr/testify&#34;</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=nx>get</span> <span class=o>-</span><span class=nx>t</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>stretchr</span><span class=o>/</span><span class=nx>testify</span>
</span></span></code></pre></td></tr></table></div></div><p>eg:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestCheckUrl3</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span> <span class=o>:=</span> <span class=nx>assert</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>tests</span> <span class=p>=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>input</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>        <span class=nx>expected</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;xdcute.com&#34;</span><span class=p>,</span> <span class=kc>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s>&#34;xxx.com&#34;</span><span class=p>,</span> <span class=kc>false</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>test</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>test</span><span class=p>.</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>assert</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nf>CheckUrl</span><span class=p>(</span><span class=nx>test</span><span class=p>.</span><span class=nx>input</span><span class=p>),</span> <span class=nx>test</span><span class=p>.</span><span class=nx>expected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=gomock模拟接口>GoMock（模拟接口）<a hidden class=anchor aria-hidden=true href=#gomock模拟接口>#</a></h2><p>mock 工具的作用是指定函数的行为（模拟函数的行为）。可以对入参进行校验，对出参进行设定，还可以指定函数的返回值。</p><h2 id=并行测试>并行测试<a hidden class=anchor aria-hidden=true href=#并行测试>#</a></h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><h2 id=参考文章>参考文章<a hidden class=anchor aria-hidden=true href=#参考文章>#</a></h2><ul><li>&ldquo;<a href=https://studygolang.gitbook.io/learn-go-with-tests/%22>https://studygolang.gitbook.io/learn-go-with-tests/"</a></li><li>&ldquo;<a href=https://quii.gitbook.io/learn-go-with-tests/%22>https://quii.gitbook.io/learn-go-with-tests/"</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://erica423.github.io/tags/%E6%8A%80%E6%9C%AF/>技术</a></li></ul><nav class=paginav><a class=prev href=https://erica423.github.io/posts/rpc/><span class=title>« Prev</span><br><span>RPC相关</span>
</a><a class=next href=https://erica423.github.io/posts/question/><span class=title>Next »</span><br><span>Q&amp;A | 面经</span></a></nav></footer><div id=waline></div><script>Waline.init({el:"#waline",dark:"body.dark",serverURL:"https://waline.vercel.app"})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://erica423.github.io/>Erica-Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>