<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入理解Go sync.Map | Erica-Blog</title>
<meta name=keywords content="技术"><meta name=description content="众所周知，在Go中，标准内置的map类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生竞"><meta name=author content="erica423"><link rel=canonical href=https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/><link crossorigin=anonymous href=/assets/css/stylesheet.0fd2af49d7c8b1a279992ba82155f4ce3b1d94189758b3b0a99c8692cfdc0be9.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=16x16 href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=32x32 href=https://erica423.github.io/images/dls_icon.png><link rel=apple-touch-icon href=https://erica423.github.io/images/dls_icon.png><link rel=mask-icon href=https://erica423.github.io/images/dls_icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>(function(){""&&prompt("请输入文章密码")!==""&&(alert("密码错误！"),history.back())})()</script><link rel=stylesheet href=https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap" rel=stylesheet><script src=https://unpkg.com/@waline/client@v2/dist/waline.js></script><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><meta property="og:title" content="深入理解Go sync.Map"><meta property="og:description" content="众所周知，在Go中，标准内置的map类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生竞"><meta property="og:type" content="article"><meta property="og:url" content="https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-27T15:54:06+08:00"><meta property="article:modified_time" content="2024-10-27T15:54:06+08:00"><meta property="og:site_name" content="erica-blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解Go sync.Map"><meta name=twitter:description content="众所周知，在Go中，标准内置的map类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生竞"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erica423.github.io/posts/"},{"@type":"ListItem","position":2,"name":"深入理解Go sync.Map","item":"https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解Go sync.Map","name":"深入理解Go sync.Map","description":"众所周知，在Go中，标准内置的map类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生竞","keywords":["技术"],"articleBody":"众所周知，在Go中，标准内置的map类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生竞态条件。\n1 fatal error: concurrent map read and map write 传统解决方案：给map添加互斥锁 sync.Mutex 或读写锁 sync.RWMutex 来同步对map的访问。但如果在操作频繁的情况下十分影响性能。\nGo sync.Map sync.Map是在Go的sync包中提供的一个并发安全的map类型。它通过内部的同步机制保证了在多个goroutine并发访问时的安全性。\n为什么需要sync.Map 主要是为了满足以下两种常见的使用场景：\nKey基本不变，但是Value会并发更新.\n在这种场景下，sync.Map通过将热点数据分离出来，减少了锁的争用，提高了性能。\nKey-Value对的添加和删除操作比较少，但是读操作非常频繁\nsync.Map在读取操作上做了优化，读操作通常无需加锁，这大大提高了并发读的性能。很符合大部分互联网操作读多写少的情况。\nsync.Map与普通map的区别 并发安全：sync.Map内部使用了锁和其他同步原语来保证并发访问的安全性\n无需初始化：sync.Map不需要像内置map那样使用make函数初始化，可以直接声明后使用。\n特殊的API：sync.Map提供了特定的方法如Load, Store, LoadOrStore, Delete, 和Range，而不是使用内置map的语法。\n设计目标和适用场景 sync.Map的设计目标是为了提供一个高效的并发安全的map，特别是在读多写少的场景下。\n最小化锁的争用：通过使用只读和读写分离的数据结构，减少了锁的争用。 延迟删除：通过标记删除而不是立即删除来提高性能。 动态调整：根据实际的使用模式动态调整内部数据结构，以优化性能。 sync.Map适用于以下场景：\n并发环境下的缓存系统：缓存项被频繁读取，但更新和删除操作较少。 长时间运行的监听器列表：监听器被添加后很少改变，但可能会被频繁触发。 全局状态和配置：全局配置可能会在程序启动时被设置，之后只会被读取。 基本用法 基于go1.20的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 type Map struct {} // 常用 func (m *Map) Store(key, value any) func (m *Map) Delete(key any) func (m *Map) Load(key any) (value any, ok bool) func (m *Map) Range(f func(key, value any) bool) // 其他 func (m *Map) LoadAndDelete(key any) (value any, loaded bool) func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool) func (m *Map) Swap(key, value any) (previous any, loaded bool) func (m *Map) CompareAndDelete(key, old any) (deleted bool) func (m *Map) CompareAndSwap(key, old, new any) bool 声明 sync.Map不需要初始化，可以直接声明后使用。它的声明方式如下：\n1 var m1 sync.Map // 也可以使用 m := new(sync.Map) 来创建一个sync.Map实例 Load()方法 Load方法用于从sync.Map中检索一个键的值。如果该键存在于map中，Load将返回键对应的值和true；如果不存在，将返回nil和false。\n1 2 3 4 5 6 7 8 // m.Load(key interface{}) (value interface{}, ok bool) value, ok := m.Load(key) if ok { // key存在，value是对应的值 } else { // key不存在 } Store()方法 Store方法用于将key-value键值对保存到sync.Map中。如果key已经存在，它的值将被覆盖。\n1 2 // m.Store(key, value interface{}) m.Store(key, value) LoadOrStore()方法 LoadOrStore方法将尝试从sync.Map中加载一个键的值。如果 key 已经存在于 map 中，则返回其值和 true。否则，将 value 存储到 map 中，并返回 value 和 false。\n1 2 3 4 5 6 actual, loaded := m.LoadOrStore(key, value) if loaded { // 键已经存在，actual是已存在的值 } else { // 键不存在，已存储提供的值，actual是提供的值 } Delete()方法 Delete方法用于从sync.Map中删除一个键及其对应的值。如果 key 存在，它将从 map 中移除。 1 2 // m.Delete(key interface{}) m.Delete(key) Range()方法 Range方法用于迭代sync.Map中的所有键值对。它接受一个函数作为参数，该函数会被调用每个键值对。如果该函数返回false，迭代将停止。 1 2 3 4 5 m.Range(func(key, value interface{}) bool { // 使用key和value // 如果要停止迭代，返回false return true }) 请注意，Range方法不保证每次迭代的顺序，且在迭代过程中如果有其他goroutine修改map，迭代器可能会反映这些修改。\n其他方法 StoreIfAbsent() 、LoadAndDelete()、 Len() 1 2 3 4 5 6 7 8 // 仅当 key 不存在时，将 value 存储到 map 中。如果 key 存在，则返回其值和 true。否则，返回 value 和 false。 m.StoreIfAbsent(key, value interface{}) (actual interface{}, loaded bool) // 删除 key 并对其实行 Load 操作。如果 key 存在，则返回其值和 true，否则返回 nil 和 false m.LoadAndDelete(key interface{}) (value interface{}, loaded bool) // 返回 map 中的元素数量。注意，这个操作可能会很昂贵，因为它需要合并 .dirty 和 .read map。 m.Len() int sync.Map源码分析 核心设计思想 尽可能无锁化： 要实现并发安全，很难做到无锁化。但是为了提升性能，应该尽可能使用原子操作，最大化减少锁的使用。 读写分离： 读写分离式针对读多写少场景的常用手段，面对读多写少的场景能够提供高性能的访问。 sync.Map的数据结构分析 sync.Map采用了装饰器模式，对普通的map加以修饰，实现读写分离和接近Lock-Free的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // sync/map.go 1.20 type Map struct { mu Mutex // 互斥锁，用于保护dirty字段和misses字段。 read atomic.Pointer[readOnly] // 存储read数据的readOnly指针类型 dirty map[any]*entry // 全量数据dirty map，存储了所有可写的键值对。 misses int // 一个计数器，记录了从read读取失败的次数，用于触发将数据从dirty迁移到read的决策。 } // readOnly is an immutable struct stored atomically in the Map.read field. // readOnly 是一个 不可变的结构体，原子化存储在 sync.Map的read 字段中。 type readOnly struct { m map[any]*entry // 其中map[key]，key为泛型，任意类型。 amended bool // true if the dirty map contains some key not in m. // amended (简单说，就是记录一种状态的，标记dirty和read有无差异) // 1 ：有差异，返回true。 // 2 ：没有差异。返回false } type entry struct { p atomic.Pointer[any] } sync.Map使用两个原生的map （本质上是map[any]*entry）来作为数据的存储空间分别是：\nread：只读字典， 使用atomic.Value来承载，保证原子性和高性能, 但不保证数据的完整性（不保证拥有全部的Key），相当于某个时间的Key-value对的快照。 dirty：脏字典， 用互斥锁Map.mu来保护，保证了并发安全。如果 m.dirty!=nil ，则dirty包含了所有的Key-Value对。当新增一个Key时，会先存放在dirty中，然后等满足一定条件后再同步给read。 dirty里是全量数据，read里的数据是dirty某个节点同步过去的上个时间段的全量数据。\n同步时机：\n增加了一个字段misses，来记录未命中read，击中dirty的次数。当次数达到dirty的长度时候，会同步。\ndirty同步到read的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // missLocked 当m.misses未击中 read map，走到 dirty map 中的 次数小于 len(m.dirty)， // 会一直走到这里，m.misses增加1次 func (m *Map) missLocked() { m.misses++ if m.misses \u003c len(m.dirty) { return } // 当 m.misses 达到 len(m.dirty)次数, // 把 dirty map 增加到 read map 中。（此时 read map中的m值为原来的 read + dirty; amended 重置为false ） // 然后把 dirty map置空，m.misses归0，重新开始。 m.read.Store(\u0026readOnly{m: m.dirty}) m.dirty = nil m.misses = 0 } （未完待续）\n参考资料：\nhttps://segmentfault.com/a/1190000043399164\nhttps://zhuanlan.zhihu.com/p/685297529\n","wordCount":"2810","inLanguage":"en","datePublished":"2024-10-27T15:54:06+08:00","dateModified":"2024-10-27T15:54:06+08:00","author":{"@type":"Person","name":"erica423"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/"},"publisher":{"@type":"Organization","name":"Erica-Blog","logo":{"@type":"ImageObject","url":"https://erica423.github.io/images/dls_icon.png"}}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erica423.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://erica423.github.io/images/dls_icon.png alt aria-label=logo height=25>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://erica423.github.io/archives/ title=🎮动态><span>🎮动态</span></a></li><li><a href=https://erica423.github.io/tags/ title=🎲标签><span>🎲标签</span></a></li><li><a href=https://erica423.github.io/search/ title="🎯搜索 (Alt + /)" accesskey=/><span>🎯搜索</span></a></li><li><a href=https://github.com/Erica423/Erica423.github.io/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erica423.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://erica423.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入理解Go sync.Map</h1><div class=post-meta><span title='2024-10-27 15:54:06 +0800 +0800'>October 27, 2024</span>&nbsp;·&nbsp;erica423&nbsp;|&nbsp;<a href=https://github.com/Erica423/Erica423.github.io rel="noopener noreferrer" target=_blank>主页</a><div class=meta-item>&nbsp·&nbsp
	      <span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#go-syncmap>Go sync.Map</a><ul><li><a href=#为什么需要syncmap>为什么需要sync.Map</a></li><li><a href=#syncmap与普通map的区别>sync.Map与普通map的区别</a></li><li><a href=#设计目标和适用场景>设计目标和适用场景</a></li><li><a href=#基本用法>基本用法</a></li></ul></li><li><a href=#syncmap源码分析>sync.Map源码分析</a></li></ul></nav></div></details></div><div class=post-content><p>众所周知，在Go中，标准内置的<code>map</code>类型不是并发安全的，也就是说在没有额外同步机制的情况下，多个goroutine同时读写一个 map 可能会发生<strong>竞态条件</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fatal</span> <span class=kt>error</span><span class=p>:</span> <span class=nx>concurrent</span> <span class=kd>map</span> <span class=nx>read</span> <span class=nx>and</span> <span class=kd>map</span> <span class=nx>write</span>
</span></span></code></pre></td></tr></table></div></div><p>传统解决方案：给map添加互斥锁 <code>sync.Mutex</code> 或读写锁 <code>sync.RWMutex</code> 来同步对map的访问。但如果在操作频繁的情况下十分影响性能。</p><h2 id=go-syncmap>Go sync.Map<a hidden class=anchor aria-hidden=true href=#go-syncmap>#</a></h2><p><code>sync.Map</code>是在Go的<code>sync</code>包中提供的一个并发安全的map类型。它通过内部的同步机制保证了在多个goroutine并发访问时的安全性。</p><h3 id=为什么需要syncmap>为什么需要sync.Map<a hidden class=anchor aria-hidden=true href=#为什么需要syncmap>#</a></h3><p>主要是为了满足以下两种常见的使用场景：</p><ol><li><p>Key基本不变，但是Value会并发更新.</p><p>在这种场景下，sync.Map通过将热点数据分离出来，减少了锁的争用，提高了性能。</p></li><li><p>Key-Value对的添加和删除操作比较少，但是读操作非常频繁</p><p>sync.Map在读取操作上做了优化，读操作通常无需加锁，这大大提高了并发读的性能。很符合大部分互联网操作<strong>读多写少</strong>的情况。</p></li></ol><h3 id=syncmap与普通map的区别>sync.Map与普通map的区别<a hidden class=anchor aria-hidden=true href=#syncmap与普通map的区别>#</a></h3><ol><li><p>并发安全：sync.Map内部使用了锁和其他同步原语来保证并发访问的安全性</p></li><li><p>无需初始化：sync.Map不需要像内置map那样使用make函数初始化，可以直接声明后使用。</p></li><li><p>特殊的API：sync.Map提供了特定的方法如<code>Load</code>, <code>Store</code>, <code>LoadOrStore</code>, <code>Delete</code>, 和<code>Range</code>，而不是使用内置map的语法。</p></li></ol><h3 id=设计目标和适用场景>设计目标和适用场景<a hidden class=anchor aria-hidden=true href=#设计目标和适用场景>#</a></h3><p>sync.Map的设计目标是为了提供一个高效的并发安全的map，特别是在读多写少的场景下。</p><ol><li>最小化锁的争用：通过使用只读和读写分离的数据结构，减少了锁的争用。</li><li>延迟删除：通过标记删除而不是立即删除来提高性能。</li><li>动态调整：根据实际的使用模式动态调整内部数据结构，以优化性能。</li></ol><p>sync.Map适用于以下场景：</p><ol><li>并发环境下的缓存系统：缓存项被频繁读取，但更新和删除操作较少。</li><li>长时间运行的监听器列表：监听器被添加后很少改变，但可能会被频繁触发。</li><li>全局状态和配置：全局配置可能会在程序启动时被设置，之后只会被读取。</li></ol><h3 id=基本用法>基本用法<a hidden class=anchor aria-hidden=true href=#基本用法>#</a></h3><p>基于go1.20的功能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=c1>// 常用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Store</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=p>(</span><span class=nx>value</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Range</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=nx>any</span><span class=p>)</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 其他
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>LoadAndDelete</span><span class=p>(</span><span class=nx>key</span> <span class=nx>any</span><span class=p>)</span> <span class=p>(</span><span class=nx>value</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>loaded</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>LoadOrStore</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=nx>any</span><span class=p>)</span> <span class=p>(</span><span class=nx>actual</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>loaded</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=nx>any</span><span class=p>)</span> <span class=p>(</span><span class=nx>previous</span> <span class=nx>any</span><span class=p>,</span> <span class=nx>loaded</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>CompareAndDelete</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>old</span> <span class=nx>any</span><span class=p>)</span> <span class=p>(</span><span class=nx>deleted</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span> <span class=nx>any</span><span class=p>)</span> <span class=kt>bool</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>声明</li></ol><p><code>sync.Map</code>不需要初始化，可以直接声明后使用。它的声明方式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>m1</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>   <span class=c1>// 也可以使用 m := new(sync.Map) 来创建一个sync.Map实例
</span></span></span></code></pre></td></tr></table></div></div><ol><li><code>Load()</code>方法</li></ol><p>Load方法用于从sync.Map中检索一个键的值。如果该键存在于map中，Load将返回键对应的值和true；如果不存在，将返回nil和false。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// m.Load(key interface{}) (value interface{}, ok bool)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// key存在，value是对应的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// key不存在
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>Store()方法</li></ol><p>Store方法用于将key-value键值对保存到sync.Map中。如果key已经存在，它的值将被覆盖。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// m.Store(key, value interface{})
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>LoadOrStore()方法</li></ol><p>LoadOrStore方法将尝试从sync.Map中加载一个键的值。如果 key 已经存在于 map 中，则返回其值和 true。否则，将 value 存储到 map 中，并返回 value 和 false。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>actual</span><span class=p>,</span> <span class=nx>loaded</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>LoadOrStore</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>loaded</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 键已经存在，actual是已存在的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 键不存在，已存储提供的值，actual是提供的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=5><li>Delete()方法
Delete方法用于从sync.Map中删除一个键及其对应的值。如果 key 存在，它将从 map 中移除。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// m.Delete(key interface{})
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ol start=6><li>Range()方法
Range方法用于迭代sync.Map中的所有键值对。它接受一个函数作为参数，该函数会被调用每个键值对。如果该函数返回false，迭代将停止。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>Range</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用key和value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果要停止迭代，返回false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>请注意，Range方法不保证每次迭代的顺序，且在迭代过程中如果有其他goroutine修改map，迭代器可能会反映这些修改。</p><ol start=7><li>其他方法
<code>StoreIfAbsent()</code> 、<code>LoadAndDelete()</code>、 <code>Len()</code></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 仅当 key 不存在时，将 value 存储到 map 中。如果 key 存在，则返回其值和 true。否则，返回 value 和 false。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>StoreIfAbsent</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>actual</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>loaded</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 删除 key 并对其实行 Load 操作。如果 key 存在，则返回其值和 true，否则返回 nil 和 false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>LoadAndDelete</span><span class=p>(</span><span class=nx>key</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>value</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>loaded</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 返回 map 中的元素数量。注意，这个操作可能会很昂贵，因为它需要合并 .dirty 和 .read map。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=kt>int</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=syncmap源码分析>sync.Map源码分析<a hidden class=anchor aria-hidden=true href=#syncmap源码分析>#</a></h2><ol><li>核心设计思想</li></ol><ul><li>尽可能无锁化： 要实现并发安全，很难做到无锁化。但是为了提升性能，应该尽可能使用原子操作，最大化减少锁的使用。</li><li>读写分离： 读写分离式针对读多写少场景的常用手段，面对读多写少的场景能够提供高性能的访问。
<img loading=lazy src=/images/syncmap%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb.png alt="sync.map读写分离alt text"></li></ul><ol><li>sync.Map的数据结构分析</li></ol><p>sync.Map采用了<code>装饰器</code>模式，对普通的map加以修饰，实现读写分离和接近<code>Lock-Free</code>的访问。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sync/map.go 1.20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mu</span> <span class=nx>Mutex</span>          <span class=c1>// 互斥锁，用于保护dirty字段和misses字段。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>read</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>[</span><span class=nx>readOnly</span><span class=p>]</span> <span class=c1>// 存储read数据的readOnly指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>dirty</span> <span class=kd>map</span><span class=p>[</span><span class=nx>any</span><span class=p>]</span><span class=o>*</span><span class=nx>entry</span> <span class=c1>// 全量数据dirty map，存储了所有可写的键值对。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>misses</span> <span class=kt>int</span>    <span class=c1>// 一个计数器，记录了从read读取失败的次数，用于触发将数据从dirty迁移到read的决策。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// readOnly is an immutable struct stored atomically in the Map.read field.
</span></span></span><span class=line><span class=cl><span class=c1>// readOnly 是一个 不可变的结构体，原子化存储在 sync.Map的read 字段中。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>readOnly</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span>       <span class=kd>map</span><span class=p>[</span><span class=nx>any</span><span class=p>]</span><span class=o>*</span><span class=nx>entry</span> <span class=c1>// 其中map[key]，key为泛型，任意类型。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>amended</span> <span class=kt>bool</span>           <span class=c1>// true if the dirty map contains some key not in m.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// amended (简单说，就是记录一种状态的，标记dirty和read有无差异)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1 ：有差异，返回true。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 2 ：没有差异。返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>entry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>[</span><span class=nx>any</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>sync.Map使用两个原生的map （本质上是map[any]*entry）来作为数据的存储空间分别是：</p><ul><li>read：只读字典， 使用atomic.Value来承载，保证原子性和高性能, 但不保证数据的完整性（不保证拥有全部的Key），相当于某个时间的Key-value对的快照。</li><li>dirty：脏字典， 用互斥锁Map.mu来保护，保证了并发安全。如果 m.dirty!=nil ，则dirty包含了所有的Key-Value对。当新增一个Key时，会先存放在dirty中，然后等满足一定条件后再同步给read。</li></ul><p>dirty里是全量数据，read里的数据是dirty某个节点同步过去的上个时间段的全量数据。</p><blockquote><p>同步时机：</p><p>增加了一个字段misses，来记录未命中read，击中dirty的次数。当次数达到dirty的长度时候，会同步。</p></blockquote><p>dirty同步到read的源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// missLocked 当m.misses未击中 read map，走到 dirty map 中的 次数小于 len(m.dirty)，
</span></span></span><span class=line><span class=cl><span class=c1>// 会一直走到这里，m.misses增加1次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>missLocked</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 当 m.misses 达到 len(m.dirty)次数,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 把 dirty map 增加到 read map 中。（此时 read map中的m值为原来的 read + dirty; amended 重置为false ）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 然后把 dirty map置空，m.misses归0，重新开始。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>readOnly</span><span class=p>{</span><span class=nx>m</span><span class=p>:</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=/images/%e5%90%8c%e6%ad%a5%e5%90%8e%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb%e7%8a%b6%e6%80%81.png alt=同步后的状态></p><p>（未完待续）</p><hr><p>参考资料：</p><p><a href=https://segmentfault.com/a/1190000043399164>https://segmentfault.com/a/1190000043399164</a></p><p><a href=https://zhuanlan.zhihu.com/p/685297529>https://zhuanlan.zhihu.com/p/685297529</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://erica423.github.io/tags/%E6%8A%80%E6%9C%AF/>技术</a></li></ul><nav class=paginav><a class=prev href=https://erica423.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3redis/><span class=title>« Prev</span><br><span>一文理解和使用Redis</span>
</a><a class=next href=https://erica423.github.io/posts/mq/><span class=title>Next »</span><br><span>消息队列</span></a></nav></footer><div id=waline></div><script>Waline.init({el:"#waline",dark:"body.dark",serverURL:"https://waline.vercel.app"})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://erica423.github.io/>Erica-Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>