[{"content":" 基于Hugo搭建的个人静态博客，使用主题theme为Hugo_PaperMod 部署前提：\n安装Git 安装Hugo 1 搭建hugo博客 PaperMod主题创建及配置：line hugo server -D 启动服务，浏览器访问 http://localhost:1313 2 Github部署 重头戏来啦！GitHub Actions 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。这里给出的是Github Actions自动部署的过程，常规部署操作比较麻烦（第一次部署狠狠踩坑了只能全部删除重来\u0026hellip;）\n新建github仓库，命名为 {自己的github用户名}.github.io，设置为公开。这个仓库用来存public文件夹中的静态html文件，也就是展示博客的内容 打开当前仓库的Setting -\u0026gt; Pages -\u0026gt; Branch 选择main分支，save保存 再新建一个私有仓库，可以命名为xxx-blog（随意就可），用于存放hugo源文件 打开github主页（注意不是仓库的）的Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)。自主选择token的过期时间，并勾选repo和workflow选项。注意保存好生成的token，之后就查看不了了。 转到源文件仓库！将刚才生成的token存入仓库的变量中。打开Settings -\u0026gt; Secrets and variables -\u0026gt; Actions new一个secret。 在源文件中创建.github/workflows/deploy.yaml配置文件，复制以下配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: deploy on: push: branches: - main workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.自己的token变量名 }} EXTERNAL_REPOSITORY: 自己的github名/自己的github名.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_meassage: auto deploy # commit_message: ${{ github.event.head_commit.message }} 新建.gitignore 1 2 3 4 # 自动生成的文件 public resources .hugo_build.lock 最后就可以推送源文件到仓库啦，成功push后就会自动触发Github Actions自动部署。(新设备记得添加ssh秘钥) 1 2 3 4 5 6 7 8 # git config --global user.name \u0026#39;xxx\u0026#39; # git config --global user.email \u0026#39;xxx\u0026#39; git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {仓库地址} git push -u origin main 访问xxx.github.io看到博客页面就是部署成功啦！🥳🥳🥳 3 其他插件 二编：添加阅读量、用户访问量功能（busuanzi计数器）\n参考地址：\u0026ldquo;https://zhuanlan.zhihu.com/p/649952987\u0026quot;\n","permalink":"https://erica423.github.io/posts/first/","summary":"基于Hugo搭建的个人静态博客，使用主题theme为Hugo_PaperMod 部署前提： 安装Git 安装Hugo 1 搭建hugo博客 PaperM","title":"【完】使用Github Actions实现Hugo静态博客自动部署"},{"content":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位的默认 int 位数为 4。 int类型 数据范围 int8 -128 ~ 127 int16 -32768 ~ 32767 int32 -2147483648 ~ 2147483647 (2 * 10^9) int64 -9223372036854775808 ~ 9223372036854775807 (9 * 10^18) uint8 0 ~ 255 uint16 0 ~ 65535 uint32 0 ~ 4294967295 uint64 0 ~ 18446744073709551615 1.2 二分查找 前提：有序数组，无重复元素\n重点：区间的定义（区间就是不变量！)\n写法1 [left, right]\nwhile (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的\nif (target \u0026lt; nums[middle]) right = middle - 1，因为当前这个nums[middle] 一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1. left = mid + 1.\n写法2 [left, right)\nwhile (left \u0026lt; right)\nright = mid, left = mid + 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // [l, r]版本 func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid - 1 } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } // [l, r) func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt; r { mid := l + (r - l) / 2 if nums[mid] \u0026gt; target { r = mid } else if nums[mid] \u0026lt; target { l = mid + 1 } else { return mid } } return -1 } Go二分查找库函数：index := sort.Search(n int, f func(i int) bool) int)\n该函数使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True。 如果无法找到该index值，则该方法为返回n. ⚠️常用场景: 一般用于从一个已经排序的数组中找到某个值所对应的索引。 或者从字符串数组中，找到满足某个条件的最小索引值，比如etcd中的键值范围查询就用到了该方法。 1.3 原地移除元素 要求：删除数组中值等于val的元素，不可以使用额外的空间。\n重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 暴力做法：两层for循环，第一个for查找值等于val的元素，第二层for依次将后续元素提前一位覆盖掉前一位元素。 复杂度：O(n^2) O(1)\n快慢指针做法 实现一个快指针一个慢指针，用一个for循环解决。复杂度：O(n) O(1) 定义： 快指针：寻找组成新数组的元素（不含=val的元素）； 慢指针：指向更新 新数组下标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func removeElement(nums []int, target int) int { slow := 0 for fast := 0; fast \u0026lt; len(nums); fast ++ { if nums[fast] != val { nums[slow] = nums[fast] slow ++ } } nums = nums[:slow] return nums } // 双向双指针 func removeElement(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u0026lt;= r { for l \u0026lt;= r \u0026amp;\u0026amp; nums[l] != val { l ++ } for l \u0026lt;= r \u0026amp;\u0026amp; nums[r] != val { r -- } // 找到左侧的val和右侧的非val后开始覆盖，覆盖后继续寻找 if l \u0026lt; r { nums[l] = nums[r] l ++ r -- } } return l } 1.4 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 暴力：每个数平方后排序，时间复杂度O(n + nlogn)\n双指针 i 指向起始位置，j 指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。\n如果A[i] * A[i] \u0026lt; A[j] * A[j] 那么result[k--] = A[j] * A[j]; 。\n如果A[i] * A[i] \u0026gt;= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func sortedSquares(nums []int) []int { n := len(nums) i, j, k := 0, n - 1, n - 1 res := make([]int, n) for i \u0026lt;= j { lm, rm := nums[i] * nums[i], nums[j] * nums[j] if lm \u0026gt; rm { res[k] = lm i ++ } else { res[k] = rm j -- } k -- } } 1.5 长度最小的连续子数组 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 暴力：两个for循环，时间复杂度 O(n^2)\n滑动窗口 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。 O(n)\n在本题中实现滑动窗口，主要确定如下三点：\n窗口内是什么？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n如何移动窗口的起始位置？ 如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n如何移动窗口的结束位置？ 窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n1 2 3 4 5 while (sum \u0026gt;= s) { subLen = (j - i + 1); res = min(res, subLen); sum -= nums[i ++ ];\t// 滑动窗口的精髓，不断变更起始位置 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func minSubArrayLen(target int, nums []int) int { n := len(nums) res := n + 1 i, sum := 0, 0 for j := 0; j \u0026lt; n; j ++ { sum += nums[j] for sum \u0026gt;= target { subLen := j - i + 1 res = min(res, subLen) sum -= nums[i] i ++ } } if res == n + 1 { return 0 } else { return res } } 1.6 (高频)螺旋矩阵II 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n示例:\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n求解本题依然是要坚持循环不变量原则。\n模拟顺时针画矩阵的过程:\n填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。\n可以看出拐角处是让给下一条边画的，也就是左闭右开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(n, vector\u0026lt;int\u0026gt;(n, 0)); int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次 int mid = n / 2; // 矩阵的中心位置 int cnt = 1;// 用来给矩阵中每一个空格赋值 int offset = 1;// 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i, j; while (loop -- ) { i = startx; j = starty; // 上行 for (j; j \u0026lt; n - offset; j ++ ) { res[i][j] = cnt ++ ; } // 右列 for (i; i \u0026lt; n - offset; i ++ ) { res[i][j] = cnt ++ ; } // 下行 for (; j \u0026gt; starty; j -- ) { res[i][j] = cnt ++ ; } // 左列 for (; i \u0026gt; startx; i -- ) { res[i][j] = cnt ++ ; } // 第二圈开始的时候，起始位置要各自加1 startx ++ , startty ++ ; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } if (n % 2) { res[mid][mid] = cnt; } return res; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \u0026#34;fmt\u0026#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { startx, starty := 0, 0 var loop int = n / 2 var center int = n / 2 count := 1 offset := 1 res := make([][]int, n) for i := 0; i \u0026lt; n; i++ { res[i] = make([]int, n) } for loop \u0026gt; 0 { i, j := startx, starty //行数不变 列数在变 for j = starty; j \u0026lt; n-offset; j++ { res[startx][j] = count count++ } //列数不变是j 行数变 for i = startx; i \u0026lt; n-offset; i++ { res[i][j] = count count++ } //行数不变 i 列数变 j-- for ; j \u0026gt; starty; j-- { res[i][j] = count count++ } //列不变 行变 for ; i \u0026gt; startx; i-- { res[i][j] = count count++ } startx++ starty++ offset++ loop-- } if n % 2 == 1 { res[center][center] = n * n } return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u0026lt; n; i++ { matrix[i] = make([]int, n) } for num \u0026lt;= tar { for i := left; i \u0026lt;= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u0026lt;= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u0026gt;= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u0026gt;= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 空间复杂度 O(1) 2 链表 https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\n单链表：\n双链表：\n循环链表：解决约瑟夫环问题\n存储方式 链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义 C/C++ 定义链表节点\n1 2 3 4 5 6 7 8 9 // 单链表 struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 } // 初始化 ListNode* head = new ListNode(5) go 定义链表节点\n1 2 3 4 5 6 type ListNode struct { Val int Next *ListNode } head := new(ListNode) 2.1 删除链表元素 题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n如果删除的是头结点该怎么办呢？\n直接使用原来的链表来进行删除操作。 设置一个虚拟头结点在进行删除操作。 1 2 3 4 5 6 7 8 9 10 11 12 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { for head != nil \u0026amp;\u0026amp; head.Val == val { head = head.Next } } 这样移除了一个头结点，在单链表中移除头结点 和 移除其他节点的操作方式是不一样, 那么可不可以 以一种统一的逻辑来移除 链表的节点呢。\n可以设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026amp;ListNode{} dummyHead.Next = head cur := dummyHead // 当前的头指针 for cur != nil \u0026amp;\u0026amp; cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyHead.Next } 2.2 (基础) 设计链表 在链表类中实现这些功能：\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 设计五个接口：\n获取链表第index个节点的数值； 在链表的最前边插入一个节点 在最后插入一个节点 在第index个节点前面插入一个节点 删除第index个节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val) : val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { if (index \u0026gt; (_size - 1) || index \u0026lt; 0) { return -1; } LinkedNode* cur = _dummyHead-\u0026gt;next; while (index -- ) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = newNode; _size ++ ; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cur = cur-\u0026gt;next; } cur-\u0026gt;next = newNode; _size ++ ; } void addAtIndex(int index, int val) { if (index \u0026gt; _size) return; if (index \u0026lt; 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } newNode-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = newNode; _size ++ ; } void deleteAtIndex(int index) { if (index \u0026gt;= _size || index \u0026lt; 0) { return; } LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u0026gt;next; } LinkedNode* tmp = cur-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete tmp; tmp = nullptr; _size -- ; } // 打印 void printLinkedList() { LInkedNode* cur = _dummyHead; while (cur-\u0026gt;next != nullptr) { cout \u0026lt;\u0026lt; cur-\u0026gt;next-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package main import ( \u0026#34;fmt\u0026#34; ) type SingleNode struct { Val int Next *SingleNode } type MyLinkedList struct { dummyHead *SingleNode // 虚拟头结点 Size int // 链表大小 } func main() { list := Constructor() list.AddAtHead(100) list.AddAtTail(242) list.AddAtTail(777) list.AddAtIndex(1, 99999) list.printLinkedList() } // Initialize func Constuctor() MyLinkedList { newNode := \u0026amp;SingleNode { -999, nil, } return MyLinkedList{ dummyHead: newNode, Size: 0, } } func (m *MyLinkedList) Get(index int) int { if m == nil || index \u0026lt; 0 || index \u0026gt;= m.Size { return -1 } cur := m.dummyHead.Next for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } return cur.Val } func (m *MyLinkedList) AddAtHead(val int) { newNode := \u0026amp;SingleNode{Val: val} newNode.Next = m.dummyHead.Next m.dummyHead.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtTail(val int) { newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for cur.Next != nil { cur = cur.Next } cur.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtIndex(index int, val int) { if index \u0026lt; 0 { index = 0 } else index \u0026gt; m.Size { return } newNode := \u0026amp;SingleNode{Val: val} cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } newNode.Next = cur.Next cur.Next = newNode m.Size ++ } func (m *MyLinkedList) DeleteAtIndex(index int) { if index \u0026lt; 0 || index \u0026gt;= m.Size { return } cur := m.dummyHead for i := 0; i \u0026lt; index; i ++ { cur = cur.Next } if cur.Next != nil { cur.Next = cur.Next.Next } m.Size -- } func (m *MyLinkedList) printLinkedList() { cur := m.dummyHead for cur.Next != nil { fmt.Println(cur.Next.Val) cur = cur.Next } } 循环双链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 type Node struct { Val int Next *Node Pre *Node } type MyLinkedList struct { dummy *Node } //仅保存哑节点，pre-\u0026gt; rear, next-\u0026gt; head /** Initialize your data structure here. */ func Constructor() MyLinkedList { rear := \u0026amp;Node{ Val: -1, Pre: nil, Next: nil, } rear.Next = rear rear.Pre = rear return MyLinkedList{rear} } func (m *MyLinkedList) Get(index int) int { head := m.dummy.Next for head != m.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { index -- head = head.Next } if 0 != index { return -1 } return head.Val } func (m *MyLinkedList) AddAtHead(val int) { dummy := m.dummy node := \u0026amp;Node{ Val: val, Pre: dummy, Next: dummy.Next, } dummy.Next.Pre = node dummy.Next = node } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { dummy := this.dummy rear := \u0026amp;Node{ Val: val, //rear.Next = dummy(哑节点) Next: dummy, //rear.Pre = ori_rear Pre: dummy.Pre, } //ori_rear.Next = rear dummy.Pre.Next = rear //update dummy dummy.Pre = rear //以上两步不能反 } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { head := this.dummy.Next //head = MyLinkedList[index] for head != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } if index \u0026gt; 0 { return } node := \u0026amp;Node{ Val: val, //node.Next = MyLinkedList[index] Next: head, //node.Pre = MyLinkedList[index-1] Pre: head.Pre, } //MyLinkedList[index-1].Next = node head.Pre.Next = node //MyLinkedList[index].Pre = node head.Pre = node //以上两步不能反 } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { //链表为空 if this.dummy.Next == this.dummy { return } head := this.dummy.Next //head = MyLinkedList[index] for head.Next != this.dummy \u0026amp;\u0026amp; index \u0026gt; 0 { head = head.Next index-- } //验证index有效 if index == 0 { //MyLinkedList[index].Pre = index[index-2] head.Next.Pre = head.Pre //MyLinedList[index-2].Next = index[index] head.Pre.Next = head.Next //以上两步顺序无所谓 } } 2.3 (高频) 反转链表 思路：\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。 其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n双指针法 O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = null; while (cur) { temp = cur-\u0026gt;next; // 保存cur的下一个节点 cur-\u0026gt;next = pre; // 翻转操作 pre = cur; cur = temp; } } }; 递归法 不同的地方在初始化 O(n) O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: ListNode* reverse(ListNode* pre, ListNode* cur) { if (cur == NULL) return pre; ListNode* temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; return reverse(cur, temp); } ListNode* reverseList(ListNode* head) { return reverse(NULL, head); } }; Go版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 双指针写法 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } // 递归 func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode) *ListNode { if head == nil { return pre } tmp := head,Next head.Next = pre return help(head, tmp) } 2.4 两两交换相邻节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n用虚拟头结点，之后模拟就可以了。O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func swapPairs(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{ Next: head, } //head=list[i] //cur=list[i-1] cur := dummy for head != nil \u0026amp;\u0026amp; head.Next != nil { cur.Next = head.Next // cur-\u0026gt;2 tmp := head.Next.Next // tmp-\u0026gt;3 head.Next.Next = head // 3-\u0026gt;1 head.Next = tmp // 1-\u0026gt;3 //cur=list[(i+2)-1] cur = head //head=list[(i+2)] head = tmp // head-\u0026gt;3 } return dummy.Next } 2.5 删除链表的倒数第n个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n思路：双指针，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n定义fast和slow指针，初始值为虚拟头结点 fast走n + 1步，因为只有这样同时移动时slow才可以指向被删除节点的上一节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := \u0026amp;ListNode{0, head} fast, slow := dummy, dummy for i := 0; i \u0026lt;= n; i ++ {// 注意\u0026lt;=，否则快指针为空时，慢指针正好在倒数第n个上面 fast = fast.Next } for fast != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return dummy.Next } // O(n) O(1) 2.6 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目保证不存在环形，不能改变原链表。\n思路： 求两个链表交点节点的指针。（注意！是指针相等，不是数值相等）\ncurA指向链表A的头结点，curB指向链表B的头结点； 求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置； 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *curA = headA; ListNode *curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) { lenA ++ ; curA = curA -\u0026gt; next; } while (curB != NULL) { lenB ++ ; curB = curB -\u0026gt; next; } if (lenB \u0026gt; lenA) { // 让curA为最长链表的头 swap(lenA, lenB); swap(curA, curB); } int gap = lenA - lenB; while (gap -- ) { // 两链末尾对齐 curA = curA -\u0026gt; next; } while (curA != NULL) { // 遍历curA和curB，遇到相同则直接返回 if (curA == curB) return curA; curA = curA -\u0026gt; next; curB = curB -\u0026gt; next; } return NULL; } }; // O(n + m) O(1) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA, curB := headA, headB; lenA, lenB := 0, 0 for curA != nil { curA = curA.Next lenA ++ } for curB != nil { curB = curB.Next lenB ++ } var gap int var fast, slow *ListNode if lenA \u0026gt; lenB { gap = lenA - lenB fast, slow = headA, headB } else { gap = lenB - lenA fast, slow = headB, headA } for i := 0; i \u0026lt; gap; i ++ { fast = fast.Next } for fast != slow { // 遍历两个链表，遇到相同的就跳出遍历 fast = fast.Next slow = slow.Next } return fast } // 双指针 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { a, b := headA, headB for a != b { if a != nil { a = a.Next } else { a = headB } if b != nil { b = b.Next } else { b = headA } } return a } 2.7 环形链表II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n考察：\n判断链表是否有环\n快慢指针。fast += 2, slow ++ , 如果 fast 和 slow指针在途中相遇 （必在环中相遇），说明这个链表有环。 有环的话如何找到入口\n从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，此时从 head 和 相遇点，同时查找直至相遇 if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head // 返回环的入口 } } return nil } 哈希表（散列表） 一般哈希表都用快速判断一个元素是否出现在集合里。\nhash function：把某个信息映射到哈希表上的索引。\nhash collisions（哈希碰撞\\冲突）：e.g. 多个姓名都映射到了同一个索引下标。\n拉链法： 线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。 哈希结构：\n数组 集合 set 映射 map c++ 底层：\n集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) **go呢？**go中的hash结构通常是指map，底层是 数组+单链表\nhttps://blog.csdn.net/vince1998/article/details/137185380\n做题技巧：\n题目提示只有小写字母，暗示用数组做哈希。大小不受限，不用数组。 数组大小有限 或 数组空间大但哈希值少，分散，建议set。 要返回下标，不能排序，用map\u0026lt;key, value\u0026gt;结构返回两者。 哈希vs双指针：哈希法对于需要去重的题目效率较低，建议使用双指针。 3.1 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 输出: true\n示例 2: 输入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 输出: false\n说明: 你可以假设字符串只包含小写字母。\n暴力：两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。 哈希表：定一个数组叫做record，大小为26，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。O(n) O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 func isAnagram(s string, t string) bool { record := [26]int{} for _, v := range s { record[v - rune(\u0026#39;a\u0026#39;)] ++ } for _, v := range t { record[v - rune(\u0026#39;a\u0026#39;)] -- } return record == [26]int{} } 3.2 两个数组的交集 使用数组来做哈希的题目，是因为题目都限制了数值的大小。\n没有限制数值的大小就无法使用数组来做哈希表了。\n而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solultion { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt; res; unordered_set\u0026lt;int\u0026gt; nums(nums1.begin(), nums1.end()); for (auto num: nums2) { if (nums.find(num) != nums.end()) { res.insert(num); } } return vector\u0026lt;int\u0026gt;(res.begin(), res.end()); } }; // O(n + m) m是最后要把set转成vector // O(n) go:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func intersection(nums1 []int, nums2 []int) []int { set := make(map[int]struct{}, 0) // map模拟set res := make([]int, 0) for _, v := range nums1 { if _, ok := set[v]; !ok { set[v] = struct{}{} } } for _, v := range nums2 { // if exists in the last array, insert into res, and delete this set value. if _, ok := set[v]; ok { res = append(res, v) delete(set, v) // delete(map, key) } } return res } // v2: use array when the number of data is small func intersection(nums1 []int, nums2 []int) []int { count1 := make([]int, 1001, 1001) count2 := make([]int, 1001, 1001) res := make([]int, 0) for _, v := range nums1 { count1[v] = 1 } for _, v := range nums2 { count2[v] = 1 } for i := 0; i \u0026lt;= 1000; i ++ { if count1[i] + count2[i] == 2 { res = append(res, i) } } return res } 3.3 快乐树 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n思路：判断sum是否重复出现过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; set; while (1) { int sum = getSum(n); if (sum == 1) { return true; } if (set.find(sum) != set.end()) { return false; // sum出现过，死循环了 } else { set.insert(sum); } n = sum; } } // O(logn) O(logn) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getSum(n int) int { sum := 0 for n \u0026gt; 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } func isHappy(n int) bool { m := make(map[int]bool) for n != 1 \u0026amp;\u0026amp; m[n] == 0 { n, m[n] = getSum(n), true } return n == 1 } 3.4 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n242. 有效的字母异位词 (opens new window)这道题目是用数组作为哈希表来解决哈希问题，349. 两个数组的交集 (opens new window)这道题目是通过set作为哈希表来解决哈希问题。\n强调一下 什么时候使用哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n再来看一下使用数组和set来做哈希法的局限。（c++）\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 暴力 func twoSum(nums []int, target int) []int { for k1, _ := range nums { for k2 := k1 + 1; k2 \u0026lt; len(nums); k2 ++ { if target == nums[k1] + nums[k2] { return []int{k1, k2} } } } return []int{} } // map func twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if pre, ok := m[target - v]; ok { return []int{pre, i} } else { m[v] = i } } return []int{} } 3.5 四数相加II (经典题目) 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\n思路 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 最后返回统计值 count 就可以了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) // k: a+b v: a+b数值出现的次数 count := 0 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1 + v2] ++ } } for _, v3 := range nums3 { for _, v4 := range nums4 { count += m[-v3-v4] } } return count } 3.6 赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\nhttps://leetcode.cn/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func canConstruct(ransomNote string, magazine string) bool { if len(ransomNote) \u0026gt; len(magazine) { return false } cnt := [26]int{} for _, v := range magazine { cnt[v - \u0026#39;a\u0026#39;] ++ } for _, v := range ransomNote { cnt[v - \u0026#39;a\u0026#39;] -- if cnt[v - \u0026#39;a\u0026#39;] \u0026lt; 0 { return false } } return true } 3.7 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n要点：去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); // find a+b+c=0 for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (nums[i] \u0026gt; 0) return res; // 去重a，这里不能是nums[i] == nums[i + 1] if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; int l = i + 1; int r = nums.size() - 1; while (r \u0026gt; l) { if (nums[i] + nums[l] + nums[r] \u0026gt; 0) r -- ; else if (nums[i] + nums[l] + nums[r]) l ++ ; else { res.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[l], nums[r]}); // 去重b和c放在找到一个三元组之后 while (r \u0026gt; l \u0026amp;\u0026amp; nums[r] == nums[r - 1]) r -- ; while (r \u0026gt; l \u0026amp;\u0026amp; nums[l] == nums[l + 1]) l ++ ; // 找到答案时双指针同时收缩 r -- , l ++ ; } } } return res; } 我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\n两数之和 就不能使用双指针法，因为1.两数之和 (opens new window)要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。\n如果1.两数之和 (opens new window)要求返回的是数值的话，就可以使用双指针法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func threeSum(nums []int) [][]int { sort.Ints(nums) res := [][]int{} for i := 0; i \u0026lt; len(nums) - 2; i ++ { n1 := nums[i] if n1 \u0026gt; 0 { return res } if i \u0026gt; 0 \u0026amp;\u0026amp; n1 == nums[i - 1] { continue } l, r := i + 1, len(nums) - 1 for l \u0026lt; r { n2, n3 := nums[l], nums[r] if n1 + n2 + n3 == 0 { res = append(res, []int{n1, n2, n3}) for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == n2 { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == n3 { r -- } } else if n1 + n2 + n3 \u0026gt; 0 { r -- } else { l ++ } } } return res } 3.8 四数之和 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n思路：和三数之和一样使用 双指针 ，基本思路就是在此基础上加一层for循环。\n细节：不能判断了nums[k] \u0026gt; target就返回，因为target是任意值，遇到负数就不好直接跳出了；\n但可以做剪枝， nums[i] \u0026gt; target \u0026amp;\u0026amp; (nums[i] \u0026gt;= 0 || target \u0026gt;= 0)\n15.三数之和 (opens new window)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。\n四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。\n那么一样的道理，五数之和、六数之和等等都采用这种解法。\n对于15.三数之和 (opens new window)双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。\n之前我们讲过哈希表的经典题目：454.四数相加II (opens new window)，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。\n双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func fourSum(nums []int, target int) [][]int { if len(nums) \u0026lt; 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u0026lt; len(nums) - 3; i ++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] { continue } for j := i + 1; j \u0026lt; len(nums) - 2; j ++ { if j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1] { continue } l, r := j + 1, len(nums) - 1 for l \u0026lt; r { sum := nums[i] + nums[j] + nums[l] + nums[r] if sum \u0026lt; target { l ++ } else if sum \u0026gt; target { r -- } else { res = append(res, []int{nums[i], nums[j], nums[l], nums[r]}) // 去重 for l \u0026lt; r \u0026amp;\u0026amp; nums[l] == nums[l + 1] { l ++ } for l \u0026lt; r \u0026amp;\u0026amp; nums[r] == nums[r - 1] { r -- } // 找到答案时，l r同时靠近 r -- l ++ } } } } return res } 字符串（完） 4.1 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1： 输入：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\n思路：\n双指针。字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。\n对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。 1 2 3 4 5 6 7 8 func reverseString(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.2 反转2 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseStr(s string, k int) string { bs := []byte(s) for i := 0; i \u0026lt; len(s); i += 2 * k { if i + k \u0026lt; len(bs) { reverse(bs[i: i + k]) } else { reverse(bs[i: len(s)]) } } return string(bs) } func reverse(s []byte) { l, r := 0, len(s) - 1 for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.3 替换数字 go字符串和C++的区别：\ngo中的string类型是不可修改的，需要转换成[]byte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { var bs []byte fmt.Scanln(\u0026amp;bs) for i := 0; i \u0026lt; len(bs); i ++ { if bs[i] \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; bs[i] \u0026gt;= \u0026#39;0\u0026#39; { insertNum := []byte{\u0026#39;n\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;r\u0026#39;} bs = append(bs[:i], append(insertNum, bs[i+1:]...)...) i = i + len(insertNum) - 1 } } fmt.Printf(string(bs)) } 4.4 翻转字符串里的单词（复杂题目） 给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1： 输入: \u0026ldquo;the sky is blue\u0026rdquo; 输出: \u0026ldquo;blue is sky the\u0026rdquo;\n示例 2： 输入: \u0026quot; hello world! \u0026quot; 输出: \u0026ldquo;world! hello\u0026rdquo; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: \u0026ldquo;a good example\u0026rdquo; 输出: \u0026ldquo;example good a\u0026rdquo; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n思路：\n移除多余空格\n整体翻转\n单词翻转\n要求：不适用辅助空间，空间复杂度O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func reverseWords(s string) string { b := []byte(s) // 移除前面、中间、后面存在的多余空格 slow := 0 for i := 0; i \u0026lt; len(b); i++ { if b[i] != \u0026#39; \u0026#39; { if slow != 0 { b[slow] = \u0026#39; \u0026#39; slow++ } for i \u0026lt; len(b) \u0026amp;\u0026amp; b[i] != \u0026#39; \u0026#39; { // 复制逻辑 b[slow] = b[i] slow++ i++ } } } b = b[0:slow] // 翻转整个字符串 reverse(b) // 翻转每个单词 last := 0 for i := 0; i \u0026lt;= len(b); i++ { if i == len(b) || b[i] == \u0026#39; \u0026#39; { reverse(b[last:i]) last = i + 1 } } return string(b) } func reverse(b []byte) { left := 0 right := len(b) - 1 for left \u0026lt; right { b[left], b[right] = b[right], b[left] left++ right-- } } 4.5 右旋字符串 字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。\n例如，对于输入字符串 \u0026ldquo;abcdefg\u0026rdquo; 和整数 2，函数应该将其转换为 \u0026ldquo;fgabcde\u0026rdquo;。\n思路：先整体反转，再局部反转。abcdefg =\u0026gt; gf | edcba =\u0026gt; fg | abcde\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func reverse(s []byte, l, r int) { for l \u0026lt; r { s[l], s[r] = s[r], s[l] l ++ r -- } } func main() { var s string var k int fmt.Scanln(\u0026amp;k) fmt.Scanln(\u0026amp;s) bs := []byte(s) reverse(bs, 0, len(s) - 1) reverse(bs, 0, k - 1) reverse(bs, k, len(s) - 1) fmt.Println(string(bs)) } 4.6 实现strStr() 实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n示例 1: 输入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 输出: 2\n示例 2: 输入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 输出: -1\n说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。\nKMP算法： 解决字符串匹配问题。当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n当前不匹配位置i前面（包括i）所有子串中的最长相等前后缀的长度，即模式串上重新匹配的位置\n前缀：包含首字母，但不包含尾字母的所有子串 后缀：反之\n为什么用前缀表？ 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。 e.g. 文本串：aabaabaaf 模式串：aabaaf，其前缀表为：010120 next数组| prefix数组\n实现：在匹配时，在模式串f处发生冲突，接下来看f前一位的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\nnext数组的不同实现 整体右移，首位添加-1 ： -1 0 1 0 1 2\n实现：在匹配时，在模式串f处发生冲突，看f的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\n整体减1： -1 0 -1 0 1 -1\n子串 最长相等前后缀长度 a 0 aa 1 (a a) aab 0 aaba 1 (a a) aabaa 2 (aa aa) aabaaf 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 前缀表不减一 or 右移 func getNext(next []int, s string) { j := 0 // j表示 最长相等前后缀长度 next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j] { j = next[j - 1] } if s[i] == s[j] { j ++ } next[i] = j // next[i]是i（包括i）之前的最长相等前后缀长度 } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := 0 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt; 0 \u0026amp;\u0026amp; hayStack[i] != needle[j] { j = next[j - 1] } if hayStack[i] == needle[j] { j ++ } if j == n { return i - n + 1 } } return -1 } // 减一实现 func getNext(next []int, s string) { j := -1 next[0] = -1 for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] // 回退前一位 } if s[i] == s[j + 1] { j ++ } next[i] = j } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := -1 // 模式串的起始位置 next为-1 因此也为-1 next := make([]int, n) getNext(next, needle) for i := 0; i \u0026lt; len(hayStack); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; hayStack[i] != needle[j + 1] { j = next[j] } if hayStack[i] == needle[j + 1] { j ++ } if j == n - 1 { return i - n + 1 } } return -1 } 4.7 重复子串 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n示例 1:\n输入: \u0026ldquo;abab\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: \u0026ldquo;aba\u0026rdquo; 输出: False 示例 3:\n输入: \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或者子字符串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。 思路：\n1.移动匹配 判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。\n1 2 3 4 5 6 7 func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } t := s + s return strings.Contains(t[1:len(t)-1], s) } 2.KMP 最小重复子串：因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\nlen % (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func repeatedSubstringPattern(s string) bool { n := len(s) if len(s) == 0 { return false } j := -1 next := make([]int, len(s)) next[0] = j for i := 1; i \u0026lt; len(s); i ++ { for j \u0026gt;= 0 \u0026amp;\u0026amp; s[i] != s[j + 1] { j = next[j] } if s[i] == s[j + 1] { j ++ } next[i] = j } // next[n-1]+1 最长相同前后缀的长度 if next[n-1] != -1 \u0026amp;\u0026amp; n%(n-(next[n-1]+1)) == 0 { return true } return false } 双指针法（完） 1.3 移除元素\n4.1 反转字符串\n4.3 替换数字\n4.4 翻转串里的单词\n2.3 翻转链表\n2.5\n2.6\n2.7\n3.7\n3.8\n栈和队列（完） go栈\n1 2 3 4 5 6 7 8 9 // create stack stack := make([]int, 0) // push stack = append(stack, 10) // pop val := stack[len(stack)-1] stack = stack[:len(stack)-1] // empty len(stack) == 0 go queue\n1 2 3 4 5 6 7 8 9 // create queue := make([]int, 0) // enqueue queue = append(queue, 10) // dequeue val := queue[0] queue = queue[1:] // empty len(queue) == 0 6.1 栈模拟队列 1 queue = 1 输入stack + 1 输出stack\npush：入队 = 入栈 pop：if输出栈空，就将输入栈中数据all导入输出栈，再从输出栈pop；if输出栈不空，就直接pop empty：if输入栈和输出栈都为空了，则模拟的队列为空。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // ------------stack------------- type MyStack []int func (s *MyStack) Push(v int) { *s = append(*s, v) } func (s *MyStack) Pop() int { val := (*s)[len(*s) - 1] *s = (*s)[:len(*s) - 1] return val } func (s *MyStack) Peek() int { return (*s)[len(*s) - 1] } func (s *MyStack) Size() int { return len(*s) } func (s *MyStack) Empty() bool { return s.Size() == 0 } // ------------queue------------- type MyQueue struct { stackIn *MyStack stackOut *MyStack } func Constructor() MyQueue { return MyQueue { stackIn: \u0026amp;MyStack{}, stackOut: \u0026amp;MyStack{}, } } func (this *MyQueue) Push(x int) { this.stackIn.Push(x) } func (this *MyQueue) Pop() int { this.fillStackOut() return this.stackOut.Pop() } func (this *MyQueue) Peek() int { this.fillStackOut() return this.stackOut.Peek() } func (this *MyQueue) Empty() bool { return this.stackIn.Empty() \u0026amp;\u0026amp; this.stackOut.Empty() } // 填充输出栈 func (this *MyQueue) fillStackOut() { if this.stackOut.Empty() { for !this.stackIn.Empty() { val := this.stackIn.Pop() this.stackOut.Push(val) } } } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 6.2 队列模拟栈 一个队列就可以模拟栈 （如果非要用两个队列，另一个队列仅起到保存元素的作用）\npush：=入栈 pop：将队头元素重新加入队列尾，再弹出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type MyStack struct { queue []int } func Constructor() MyStack { return MyStack { queue: make([]int, 0), } } func (this *MyStack) Push(x int) { this.queue = append(this.queue, x) } func (this *MyStack) Pop() int { n := len(this.queue) - 1 for n != 0 { val := this.queue[0] this.queue = this.queue[1:] this.queue = append(this.queue, val) n -- } val := this.queue[0] this.queue = this.queue[1:] return val } func (this *MyStack) Top() int { val := this.Pop() this.queue = append(this.queue, val) // pop完要重新添加回去 return val } func (this *MyStack) Empty() bool { return len(this.queue) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 6.3 括号匹配 在写代码之前要分析好有哪几种不匹配的情况:\n第一种情况，字符串里左方向的括号多余了 ，所以不匹配。\n第二种情况，括号没有多余，但是 括号的类型没有匹配上。\n第三种情况，字符串里右方向的括号多余了，所以不匹配。\n还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // O(n) O(n) func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } stk := make([]rune, 0) for i := 0; i \u0026lt; n; i ++ { if s[i] == \u0026#39;[\u0026#39; { stk = append(stk, \u0026#39;]\u0026#39;) } else if s[i] == \u0026#39;(\u0026#39; { stk = append(stk, \u0026#39;)\u0026#39;) } else if s[i] == \u0026#39;{\u0026#39; { stk = append(stk, \u0026#39;}\u0026#39;) } else if len(stk) == 0 || stk[len(stk) - 1] != rune(s[i]) { // 如果是右括号，如果栈空 或 栈里没有可以匹配的元素 return false } else { stk = stk[:len(stk) - 1] // pop } } // 遍历完了看时候有剩余 return len(stk) == 0 } 6.4 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\n输入：\u0026ldquo;abbaca\u0026rdquo; 输出：\u0026ldquo;ca\u0026rdquo; 解释：例如，在 \u0026ldquo;abbaca\u0026rdquo; 中，我们可以删除 \u0026ldquo;bb\u0026rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \u0026ldquo;aaca\u0026rdquo;，其中又只有 \u0026ldquo;aa\u0026rdquo; 可以执行重复项删除操作，所以最后的字符串为 \u0026ldquo;ca\u0026rdquo;。 提示：\n1 \u0026lt;= S.length \u0026lt;= 20000 S 仅由小写英文字母组成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func removeDuplicates(s string) string { stack := make([]rune, 0) for _, val := range s { if len(stack) == 0 || val != stack[len(stack)-1] { stack = append(stack, val) } else { stack = stack[:len(stack)-1] } } var res []rune for len(stack) != 0 { // 将栈中元素放到result字符串汇总 res = append(res, stack[len(stack)-1]) stack = stack[:len(stack)-1] } // 此时字符串需要反转一下 l, r := 0, len(res)-1 for l \u0026lt; r { res[l], res[r] = res[r], res[l] l++ r-- } return string(res) } 这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。\n可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。\n此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。\n游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。\n而且在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）\n6.5 逆波兰式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { // is operation c1, c2 := stack[len(stack) - 2], stack[len(stack) - 1] stack = stack[:len(stack) - 2] switch token { case \u0026#34;+\u0026#34;: stack = append(stack, c1 + c2) case \u0026#34;-\u0026#34;: stack = append(stack, c1 - c2) case \u0026#34;*\u0026#34;: stack = append(stack, c1 * c2) case \u0026#34;/\u0026#34;: stack = append(stack, c1 / c2) } } } return stack[0] } 6.6 滑动窗口最大值 （经典：单调队列） 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值。\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 1 \u0026lt;= k \u0026lt;= nums.length 进阶：你能在线性时间复杂度内解决此题吗？\n用一个队列维护当前窗口，随着窗口移动，队列一进一出，希望队头是最大元素。\n要保证队列内元素单调递减（增） –》 单调队列\n但不需要维护窗口里的所有元素，只需要维护可能成为最大值的元素。如果下一个元素比上一个大，那么上一个出队，保存下一个，直到遇到比上一个小的，上一个元素不动，继续保留小于当前值的最大值。\n设计单调队列的时候，pop，和push操作要保持如下规则：\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // O(n) O(k) // 封装单调队列的方式解题 type MyQueue struct { queue []int } func NewMyQueue() *MyQueue { return \u0026amp;MyQueue{ queue: make([]int, 0), } } func (m *MyQueue) Front() int { return m.queue[0] } func (m *MyQueue) Back() int { return m.queue[len(m.queue)-1] } func (m *MyQueue) Empty() bool { return len(m.queue) == 0 } func (m *MyQueue) Push(val int) { for !m.Empty() \u0026amp;\u0026amp; val \u0026gt; m.Back() { m.queue = m.queue[:len(m.queue)-1] } m.queue = append(m.queue, val) } func (m *MyQueue) Pop(val int) { if !m.Empty() \u0026amp;\u0026amp; val == m.Front() { m.queue = m.queue[1:] } } func maxSlidingWindow(nums []int, k int) []int { queue := NewMyQueue() length := len(nums) res := make([]int, 0) // 先将前k个元素放入队列 for i := 0; i \u0026lt; k; i++ { queue.Push(nums[i]) } // 记录前k个元素的最大值 res = append(res, queue.Front()) for i := k; i \u0026lt; length; i++ { // 滑动窗口移除最前面的元素 queue.Pop(nums[i-k]) // 滑动窗口添加最后面的元素 queue.Push(nums[i]) // 记录最大值 res = append(res, queue.Front()) } return res } 6.7 前k个高频元素（经典：优先队列/堆） 统计出现元素的频率 map:[key, value] 对频率排序 priority queue / 取前k个频率的元素 什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。\n那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。\n而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？\n所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 快排 func topKFrequent(nums []int, k int) []int { res := []int{} cnt := make(map[int]int) for _, val := range nums { cnt[val] ++ } for k, _ := range cnt { res = append(res, k) } sort.Slice(res, func(a, b int) bool { return cnt[res[a]] \u0026gt; cnt[res[b]] }) return res[:k] // qian k } // 小顶堆 func topKFrequent(nums []int, k int) []int { map_num:=map[int]int{} //记录每个元素出现的次数 for _,item:=range nums{ map_num[item]++ } h:=\u0026amp;IHeap{} heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num{ heap.Push(h,[2]int{key,value}) if h.Len()\u0026gt;k{ heap.Pop(h) } } res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i\u0026lt;k;i++{ res[k-i-1]=heap.Pop(h).([2]int)[0] } return res } //构建小顶堆 type IHeap [][2]int func (h IHeap) Len()int { return len(h) } func (h IHeap) Less (i,j int) bool { return h[i][1]\u0026lt;h[j][1] } func (h IHeap) Swap(i,j int) { h[i],h[j]=h[j],h[i] } func (h *IHeap) Push(x interface{}){ *h=append(*h,x.([2]int)) } func (h *IHeap) Pop() interface{}{ old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x } Go: 深入理解堆实现及应用-腾讯云开发者社区-腾讯云 (tencent.com)\n堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或小于等于（最小堆）其子节点。Go语言中的堆通过container/heap包实现，该包提供了对数据结构进行堆操作的接口和方法。\n二叉树 满二叉树 完全二叉树 二叉搜索树 平衡二叉搜索树 AVL 二叉树存储：\n链式 顺序：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树主要有两种遍历方式：\n深度优先遍历：先往深走，遇到叶子节点再往回走。 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历：一层一层的去遍历。 层次遍历（迭代法） 之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n二叉树定义\n1 2 3 4 5 6 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} } 1 2 3 4 5 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 7.1 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { // 注意入参 if node == nil { // 注意终止条件 return } // 前序遍历 res = append(res, node.Val) traversal(node.Left) traversal(node.Right) // 中序遍历 // ntraversal(node.Left) // res = append(res, node.Val) // traversal(node.Right) // 后序遍历 // traversal(node.Left) // traversal(node.Right) // res = append(res, node.Val) } traversal(root) return } 7.2 二叉树递归 确定递归函数入参和返回值 确定递归退出条件 确定单次递归内容 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n7.3 二叉树迭代 前后序用栈，后序用指针\nstk.Len()\nstk.PushBack(ndoe)\nstk.Back() 返回栈中的最后一个元素，即栈顶元素。\nstk.Remove(stk.Back()) 从栈中移除并返回最后一个元素。这里移除的元素是栈顶元素。\n(*TreeNode) 是类型断言，将移除的元素转换为 *TreeNode 类型。\n统一迭代 单调栈（完） 739.每日温度 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n思路：找到右边第一个比自己大的数\n在遍历过程中用栈记录右边第一个比当前大的元素，O(n). 栈中只存对应元素下标即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 暴力 func dailyTemperatures(t []int) []int { var res []int for i := 0; i \u0026lt; len(t) - 1; i ++ { j := i + 1 for ; j \u0026lt; len(t); j ++ { if t[j] \u0026gt; t[i] { res = append(res, j - i) break // 找到第一个就退出 } } if j == len(t) { // 如果找完了都没有 res = append(res, 0) } } return append(res, 0) // 最后一日肯定是0 } // 单调栈(增) func dailyTemperatures(t []int) []int { res := make([]int, len(t)) stk := []int{0} // 初始化栈顶元素为第一个下标索引0 for i := 1; i \u0026lt; len(t); i ++ { top := stk[len(stk) - 1] // 当前栈顶 if t[top] \u0026gt;= t[i] { stk = append(stk, i) } else { for len(stk) != 0 \u0026amp;\u0026amp; t[i] \u0026gt; t[top] { res[top] = i - top stk = stl[:len(stk)-1] // pop if len(stk) != 0 { top = stk[len(stk) - 1] // 更新栈顶 } } stk = append(stk, i) } } return res } // 单调栈(递减) func dailyTemperatures(t []int) []int { res: := make([]int, len(t)) stk := []int{} for i, v := range t { // 栈不空且当前遍历元素 v 破坏了栈的单调性 for len(stk) != 0 \u0026amp;\u0026amp; v \u0026gt; t[stk[len(stk)-1]] { // 大于当前栈顶，就pop，更新 top := stk[len(stk)-1] stk = stk[:len(stk)-1] res[top] = i - top } stk = append(stk, i) } return res } 496.下一个更大元素 I 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n示例 1:\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1]\n没有重复元素，可以用map来做映射，可以根据数值快速找下标，并且可以判断nums2[i]是否在nums1中出现过。\nres数组默认值为-1（找不到）。\n遍历哪个数组呢？要在nums2里找比1里对应位置元素大的，所以遍历nums2\n情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况：此时满足递增栈（栈头到栈底的顺序），所以直接入栈。\n情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于\n情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。\n判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func nextGreaterElement(nums1 []int, nums2 []int) []int { res := make([]int, len(nums1)) for i := range res { res[i] = -1 } mp := map[int]int{} for i, v := range nums1 { mp[v] = i } stack := []int{} stack = append(stack, 0) // nums2下标 for i := 1; i \u0026lt; len(nums2); i ++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums2[i] \u0026gt; nums2[stack[len(stack)-1]] { top := stack[len(stack)-1] if _, ok := mp[nums2[top]]; ok { // 看map里是否存在这个元素 index := mp[nums2[top]] // 根据map找到nums2[top] 在 nums1中的下标 res[index] = nums2[i] } stack = stack[:len(stack)-1] } stack = append(stack, i) // \u0026lt;= } return res } 503.下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n示例 1:\n输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func nextGreaterElements(nums []int) []int { n := len(nums) res := make([]int, n) for i := range nums { res[i] = -1 } // 单调递减，存储数组下标 stk := make([]int, 0) for i := 0; i \u0026lt; n * 2; i ++ { for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[stk[len(stk)-1]] { index := stk[len(stk)-1] stk = stk[:len(stk)-1] res[index] = nums[i % n] } stk = append(stk, i % n) } return res } 42. 接雨水（经典常问） 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 暴力双指针 按列计算：宽度一定是1，再求每一列的雨水高度。每一列的雨水有多高取决于两侧柱子中最短的一个。\n注意第一个和最后一个柱子不接雨水。 在for中求左右两边最高的柱子。 最后计算该列的雨水高度: 当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func trap(height []int) (sum int) { n := len(height) for i, h := range height { if i == 0 || i == n - 1 { continue } ml, mr := h, h for r := i + 1; r \u0026lt; n; r ++ { if height[r] \u0026gt; mr { mr = height[r] } } for l := i - 1; l \u0026gt;= 0; l -- { if height[l] \u0026gt; ml { ml = height[l] } } if min(ml, mr) - h \u0026gt; 0 { sum += min(ml, mr) - h } } return } // 时间复杂度为O(n^2)，空间复杂度为O(1) 双指针优化 为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。\n当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。\n即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);\n从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);\n单调栈 单调栈就是保持栈内元素有序。我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。\n【单调栈是按行计算】\n从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。\n遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func trap(height []int) (sum int) { if len(height) \u0026lt;= 2 { return 0 } stack := []int{} stack = append(stack, 0) // 第一个柱子 for i := range height { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; height[i] \u0026gt; height[stack[len(stack)-1]] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u0026gt; 0 { h := min(height[i], height[stack[len(stack)-1]]) - height[mid] w := i - stack[len(stack)-1] - 1 sum += h * w } } stack = append(stack, i) } return } 84. 柱状图中的最大矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n1 2 3 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 【与接雨水的区别】要记录每个柱子左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 暴力双指针 func largestRectangleArea(height []int) int { n := len(height) minl := make([]int, n) minr := make([]int, n) minl[0] = -1 for i := 1; i \u0026lt; n; i ++ { t := i - 1 for t \u0026gt;= 0 \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minl[t] = minl[t], t } } minr[n - 1] = n for i := n - 2; i \u0026gt;= 0; i -- { t := i + 1 for t \u0026lt; n \u0026amp;\u0026amp; height[t] \u0026gt;= height[i] { t, minr[t] = minr[t], t } } sum := 0 for i := 0; i \u0026lt; n; i ++ { s := height[i] * (minr[i] - minl[i] - 1) sum = max(sum, s) } return sum } 单调栈 42. 接雨水 (opens new window)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度\n注：在height数组头尾加一个0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func largestRectangleArea(heights []int) (res int) { stack := make([]int, 0) heights = append([]int{0}, heights...) heights = append(heights, 0) stack = append(stack, 0) for i := 1; i \u0026lt; len(heights); i ++ { for heights[stack[len(stack)-1]] \u0026gt; heights[i] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] sum := heights[mid] * (i - left - 1) if sum \u0026gt; res { res = sum } } stack = append(stack, i) } return res } 贪心 DP 基础题 背包：01、完全、多重 打家劫舍系列 股票问题 子序列问题 动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。\n问题分解：\n确定dp数组以及下标的含义 确定状态转移方程（递推公式） dp数组如何初始化 确定遍历顺序 举例推导dp数组 如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。\n如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。\n如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。\n509. 斐波那契数（入门） 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给你n ，请计算 F(n) 。\n示例 1：\n输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 提示：\n0 \u0026lt;= n \u0026lt;= 30 思路：\n确定dp数组及下表的意义：dp[i] 定义为第i个数的斐波那契数值 递推公式：题目给了 dp[i] = dp[i - 1] + dp[i - 2] 初始化：题目给了 dp[0] = 0, dp[1] = 1 遍历顺序：从公式看出，dp[i] 依赖 dp[i - 1]和dp[i - 2]，所以是从前到后遍历 举例推导dp数组：N = 10时，dp数组应该是：0 1 1 2 3 5 8 13 21 34 55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 递归 func fib(n int) int { if n \u0026lt; 2 { return n } return fib(n - 1) + fib(n - 2) } // dp func fib(n int) int { if n \u0026lt; 2 { return n } dp0, dp1, dp := 0, 1, 0 for i := 1; i \u0026lt; n; i ++ { dp = dp0 + dp1 dp0, dp1 = dp1, dp } return dp } 70. 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。\n示例 1：\n输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：\n输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 思路：\ndp[i]: 爬到第i层时，有dp[i]种方法 dp[i] = dp[i - 1] + dp[i - 2] 不考虑dp[0], dp[1] = 1, dp[2] = 2, 从3开始递推 顺序：从前到后 举例：n = 5时， dp数组：1 2 3 5 8 1 2 3 4 5 6 7 8 9 10 11 func climbStairs(n int) int { if n == 1 { return n } dp := make([]int, n + 1) dp[1], dp[2] = 1, 2 for i := 3; i \u0026lt;= n; i ++ { dp[i] = dp[i - 1] + dp[i - 2] } return dp[n] } 746. 最小花费爬楼梯 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n思路：\ndp[i] ： 到达第i个台阶所花费的最少费用\ndp[i] = dp[i - 1] + cost[i - 1], dp[i - 1] = dp[i - 2] + cost[i - 2].\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n初始化：根据题目意思，dp[0] = dp[1] = 0 (因为从0或1开题跳都可以，意思就是不计费)\n遍历顺序：从前到后\n举例推导：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n0 0 1 2 2 3 3 4 4 5 6\n1 2 3 4 5 6 7 8 func minCostClimbingStairs(cost []int) int { f := make([]int, len(cost) + 1) f[0], f[1] = 0, 0 for i := 2; i \u0026lt;= len(cost); i ++ { f[i] = min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2]) } return f[len(cost)] } 62. 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\ndp[i ] [j] : 表示从（0,0）出发到（i,j)的不同路径数 公式：dp[ i ] [ j ] = dp[i] [j - 1] + dp[i - 1] [j] （从左边和上边来的） 初始化：dp[i] [0] = 1, dp[0] [j] = 1 遍历顺序：从左到右一层层遍历即可 举例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j \u0026lt; n; j ++ { dp[0][j] = 1 } for i := 1; i \u0026lt; m; i ++ { for j := 1; j \u0026lt; n; j ++ { dp[i][j] = dp[i - 1][j] + dp[i][j - 1] } } return dp[m - 1][n - 1] } // 优化：二维简化到一维，滚动数组 T: O(mn), S: O(mn) -\u0026gt; O(n) // 数论做法：对于m行n列的矩形，走到终点都需要m+n-2步。在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。C_(m+m-2)^(m-1) //需要在计算分子的时候，不断除以分母 func uniquePaths(m int, n int) int { numerator := 1 denominator := m - 1 // fenmu cnt := m - 1 t := m + n - 2 for cnt \u0026gt; 0 { numerator *= t t -- for denominator != 0 \u0026amp;\u0026amp; numerator % denominator == 0 { numerator /= denominator denominator -- } cnt -- } return numerator } // O(m) O(1) 求组合的时候，要防止两个int相乘溢出！ 所以不能把算式的分子都算出来，分母都算出来再做除法。\n数位DP 数的大小和复杂度没什么关系，数位变化有关。\nf[i, mask, isLimit, isNum]\n返回从i开始填数字，i前面的数字的集合是mask，共构造出的特殊数的数量；is_limit表示前面填的数是否都是n对应位置上的，if true，则当前位之多为s[i], 否则至多为’9’; is_num表示前面是否填了数字（是否跳过），if true则当前可以从0开始，false可以跳过或从1开始。\n1 2 3 func f(i int, mask int, is_limit bool, is_num bool) int { if i == len(s) } 集合可以用二进制表示，二进制从低到高第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 对应的二进制数为 1101 (2)\n设集合对应的二进制数为 x。本题需要用到两个位运算操作：\n判断元素 d 是否在集合中：x \u0026raquo; d \u0026amp; 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 \u0026laquo; d)。\n","permalink":"https://erica423.github.io/posts/algorithm/","summary":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位","title":"算法"},{"content":"Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx、go-micro 等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。\nGeeRPC 选择从零实现 Go 语言官方的标准库 net/rpc，并在此基础上，新增了：\n协议交换(protocol exchange) 注册中心(registry) 服务发现(service discovery) 负载均衡(load balance) 超时处理(timeout processing)等特性。 消息的序列化和反序列化 RPC调用：\n1 err := client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) 其中，客户端发送的请求包括：服务名Arith，方法名Multiply，参数args；服务端的响应包括错误信息err和返回值reply。\n","permalink":"https://erica423.github.io/posts/rpc/","summary":"Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx、go-micro 等都是非常成熟的框架。一般而言，RP","title":"RPC相关"},{"content":" GO在线编译器：go playground\nTest-Driven Development(TDD) - 测试驱动开发 周期：\n编写一个测试\n让编译通过\n运行测试，查看失败原因并检查错误消息是很有意义的\n编写足够的代码以使测试通过\n重构\n常用功能 测试文件命名规则：xxx_test.go, 与xxx.go放在同一个package下\n测试函数命令以Test开头\n测试函数只接受一个*testing.T类型的参数t （t就是测试框架中的钩子hook）\nt.Errorf(): 格式化记录错误信息，但测试继续进行。f 表示格式化，允许我们构建一个字符串，并将值插入占位符值 %q 中。\nt.Fatalf(): 报告致命错误，并终止测试。\nt.Fail(): 标记测试结果为失败的，不同的是t.Fail只把测试结果标记为失败，不会终止当前测试，t.FailNow则会立即终止当前的测试函数，并标记为失败。\nt.Helper(): 告诉测试套件这个方法是辅助函数（helper）。通过这样做，当测试失败时所报告的行号将在函数调用中而不是在辅助函数内部。\nSubtest - 子测试 有时，对一个「事情」进行分组测试，然后再对不同场景进行子测试非常有效。\n1 2 3 4 5 6 7 8 9 func TestMain(t *testing.T) { t.Run(\u0026#34;show expected output of this function\u0026#34;, func(t *testing.T) { }) t.Run(\u0026#34;...\u0026#34;, func(t *testing.T) { }) } 这种方法的好处是，你可以建立在其他测试中也能够使用的共享代码。 重要的是，你的测试清楚地说明了代码需要做什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func TestHello(t *testing.T) { assertCorrectMessage := func(t *testing.T, got, want string) { t.Helper() if got != want { t.Errorf(\u0026#34;got \u0026#39;%q\u0026#39; want \u0026#39;%q\u0026#39;\u0026#34;, got, want) } } t.Run(\u0026#34;saying hello to people\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;Chris\u0026#34;) want := \u0026#34;Hello, Chris\u0026#34; assertCorrectMessage(t, got, want) }) t.Run(\u0026#34;empty string defaults to \u0026#39;world\u0026#39;\u0026#34;, func(t *testing.T) { got := Hello(\u0026#34;\u0026#34;) want := \u0026#34;Hello, World\u0026#34; assertCorrectMessage(t, got, want) }) } 及时添加注释，方便生成API文档 Swagger自动生成文档\nsyntax 句法\nAdd AND assignment operactor 自增赋值运算符 +=\n数组 \u0026amp; 切片 we are using the %v placeholder to print the \u0026ldquo;default\u0026rdquo; format, which works well for arrays.\n在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种比较简单的办法是使用 reflect.DeepEqual，它在判断两个变量是否相等时十分有用。但不是类型安全的。\n接口 在 Go 语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。\n测试覆盖率 1 go test -cover Table driven tests - 表格驱动测试 适合处理同质化的测试内容, 如果你要测试一个接口的不同实现，或者传入函数的数据有很多不同的测试需求，这个武器将非常给力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func TestArea(t *testing.T) { areaTests := []struct { shape Shape want float64 }{ {Rectangle{10.0, 20.0}, 200.0}, {Circle{10.0}, 314.1592653589793}, } for _, tt := range areaTests { got := tt.shape.Area() if got != tt.want { t.Errorf(\u0026#34;want %.2f but got %.2f\u0026#34;, tt.want, got) } } } 使用了匿名结构体 - anonymous struct, 用含有两个域 shape 和 want 的 []struct 声明了一个结构体切片。\n可以改进错误输出为 %#v got %.2f want %.2f. %#v，这样会打印结构体中域的值。能一眼看出被测试的属性。\n关于列表驱动测试的最后一点提示是使用 t.Run。\n在每个用例中使用 t.Run，测试用例的错误输出中会包含用例的名字：\n1 2 3 -------- FAIL: TestArea (0.00s) --- FAIL: TestArea/Rectangle (0.00s) shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10 运行列表中指定的测试用例：go test -run TestArea/Rectangle\n检查未经检查的error 有一种情况我们还没有测试过。要找到它，在一个终端中运行以下命令来安装 errcheck，这是许多可用的 linters（代码检测工具）之一。\ngo get -u github.com/kisielk/errcheck\n然后，在代码目录中运行 errcheck .\n依赖注入： io.Writer 是一个很好的通用接口，用于「将数据放在某个地方」。\nfmt.Fprintf 和 fmt.Printf 一样，只不过 fmt.Fprintf 会接收一个 Writer 参数，用于把字符串传递过去，而 fmt.Printf 默认是标准输出。\n注入 - Mocking 将依赖关系定义为一个接口。这样我们就可以在 main 使用 真实的 Sleeper，并且在我们的测试中使用 spy sleeper。通过使用接口，我们的 Countdown 函数忽略了这一点，并为调用者增加了一些灵活性。\nConcurrency 匿名函数有许多有用的特性。首先，它们可以在声明的同时执行 —— 这就是匿名函数末尾的 () 实现的。其次，它们维护对其所定义的词汇作用域的访问权 —— 在声明匿名函数时所有可用的变量也可在函数体内使用。\n上面匿名函数的主体和之前循环体中的完全一样。唯一的区别是循环的每次迭代都会启动一个新的 goroutine，与当前进程（WebsiteChecker 函数）同时发生，每个循环都会将结果添加到 results map 中。\n1 2 3 4 5 6 7 for _, url := range urls { go func() { results[url] = wc(url) }() } time.Sleep(2 * time.Second) 这里的问题是变量 url 被重复用于 for 循环的每次迭代 —— 每次都会从 urls 获取新值。但是我们的每个 goroutine 都是 url 变量的引用 —— 它们没有自己的独立副本。所以他们 都 会写入在迭代结束时的 url —— 最后一个 url。这就是为什么我们得到的结果是最后一个 url。\n1 2 3 4 5 6 7 for _, url := range urls { go func(u string) { results[u] = wc(u) }(url) } time.Sleep(2 * time.Second) 通过给每个匿名函数一个参数 url(u)，然后用 url 作为参数调用匿名函数，我们确保 u 的值固定为循环迭代的 url 值，重新启动 goroutine。u 是 url 值的副本，因此无法更改。\n用channel解决数据竞争 data race\ngoroutines 是 Go 的基本并发单元，它让我们可以同时检查多个网站。\nanonymous functions（匿名函数），我们用它来启动每个检查网站的并发进程。\nchannels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。\nthe race detector（竞争探测器） 帮助我们调试并发代码的问题。\n使用 select 时，time.After 是一个很好用的函数。当你监听的 channel 永远不会返回一个值时你可以潜在地编写永远阻塞的代码，尽管在我们的案例中它没有发生。time.After 会在你定义的时间过后发送一个信号给 channel 并返回一个 chan 类型（就像 ping 那样）。\nvalue 有一个方法 NumField，它返回值中的字段数\nSync Sync\nWaitGroup 等待 goroutine 集合完成。主 goroutine 调用 Add 设置等待的 goroutine 数量。然后每个 goroutine 运行并在完成时调用 Done。同时，Wait 可以用来阻塞，直到所有 goroutine 都完成。\n通过在做出断言之前等待wg.Wait()完成，我们可以确定所有的 goroutine 都已尝试Inc过Counter。\nA Mutex must not be copied after first use. Use channels when passing ownership of data\nUse mutexes for managing state\nContext context\n我们所做的是从我们的request中派生一个新的 cancellingCtx，它返回一个cancel函数。然后，我们使用 time.AfterFunc 安排在 5 毫秒内调用该函数。最后，我们通过调用 request.WithContext 在请求中使用这个新上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func Server(store Store) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { ctx := r.Context() data := make(chan string, 1) go func() { data \u0026lt;- store.Fetch() }() select { case d := \u0026lt;-data: fmt.Fprint(w, d) case \u0026lt;-ctx.Done(): store.Cancel() } } } context有一个方法Done()返回一个channel，当context“完成”或“取消”时，该通道会发送信号。 我们想要监听该信号并在收到该信号时调用 store.Cancel，但如果我们Store设法在Fetch它之前就忽略它。\n对服务器的传入请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传播上下文，可以选择将其替换为使用 WithCancel、WithDeadline、WithTimeout 或 WithValue 创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。\nProperty based tests strings.Builder 用于使用写入方法高效构建字符串。它最大限度地减少了内存复制。\n罗马数字的规则是同一字符不能在一行中重复超过 3 次。 取而代之的是取下一个最高的符号，然后在其左侧放置一个符号来 “减去”。 并非所有符号都可以用作减法器；只有 I (1)、X (10) 和 C (100)。\n例如，罗马数字中的 5 是 V。要创建 4，您不执行 IIII，而是执行 IV。\nRomanNumeral规则：\n不能有超过 3 个连续的符号\n只有 I (1), X (10) 和 C (100) 是 「减法器」\n将 ConvertToRoman(N) 的结果传递给 ConvertToArabic ，应该返回 N。\n基于属性的测试通过向代码中抛出随机数据并验证所描述的规则始终为真来帮助您做到这一点。很多人认为基于属性的测试主要是关于随机数据的，但他们是错误的。 基于属性的测试面临的真正挑战是你对你的领域有「很好的」理解，这样您就可以编写这些属性。\n从底部读取，我们为 quick.Check 提供了一个函数，它将运行一些随机的输入，如果函数返回 false，它将被视为检查失败。\n上面的 assertion 函数接受随机数并运行函数来测试属性。\n你不能用罗马数字表示负数\n根据我们最多 3 个连续符号的规则，我们不能表示大于 3999 的值 (罗马数字的最大值)，而 int 的最大值比 3999 大得多。 因此使用uint16\n内置的路由机制叫做 ServeMux（request multiplexer，多路请求复用器），它允许你将 http.Handler 附加到特定的请求路径。\nWe changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.\nGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.\n这意味着我们的 PlayerServer 现在已经有了 http.Handler 所有的方法，也就是 ServeHTTP。\n为了 “填充” http.Handler，我们将它分配给我们在 NewPlayerServer 中创建的 router。我们可以这样做是因为 http.ServeMux 具有 ServeHTTP 方法。\n这允许我们删除我们的 ServeHTTP 方法，因为我们已经通过嵌入类型公开了它。\n嵌入是一个非常有意思的语法特性。你可以用它将接口组成新的接口。\nIO和排序 服务器重启会重置积分\nos.OpenFile 允许你定义打开文件的权限，在我们的例子中，O_RDWR 意味着我们想要读写权限，os.O_CREATE 是指如果文件不存在，则创建该文件。\n创建一个新类型来封装我们的「当写入时，从头部开始」功能。我把它叫做 Tape.\nfile.Stat 返回我们的文件的统计数据。我们可以检查文件的大小，如果它是空的，我们就会编写一个空的 JSON 数组，然后 Seek 到开始位置，为剩下的代码做准备。\n命令行和项目结构 当用户输入 Ruth wins 时，它只需要能够记录玩家的胜出情况，最终目的是作为一个帮助用户玩扑克的工具。\n产品负责人希望在两个应用程序之间共享数据库，以便玩家league根据新程序中记录的wins进行更新。\n第一个需求就是当用户输入 {PlayerName} wins 时记录一次胜利。\nbufio 包实现了 I/O 缓冲。它封装了一个 io.Reader 或 io.Writer 对象，创建了另一个对象（Reader 或 Writer），也实现了接口，并为文本 I/O 提供了缓冲和一些帮助。\nScanner.Scan() 会逐行读取内容。 然后使用 Scanner.Text() 来返回 scanner 读取的 string。 我们将它封装到一个名为 readLine() 的函数中。\nBenchmarking - 基准测试 用 go test -bench=. 来运行基准测试。 (如果在 Windows Powershell 环境下使用 go test -bench=\u0026quot;.\u0026quot;)\nTips: benchmarks默认顺序执行。\n1 2 3 4 5 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u0026lt; b.N; i ++ { Repeat(\u0026#34;A\u0026#34;) } } testing.B 可使你访问隐性命名（cryptically named）b.N。\n基准测试运行时，代码会运行 b.N 次，并测量需要多长时间。\n代码运行的次数不会对你产生影响，测试框架会选择一个它所认为的最佳值，以便让你获得更合理的结果。\nGoConvey（测试框架） 1 2 import \u0026#34;github.com/smartystreets/goconvey/convey\u0026#34; go get github.com/smartystreets/goconvey convey.Convey 定义了测试用例名称、t 指针、测试代码。 convey.So` 用来判断预期结果。 convey 提供了大量的断言函数，比如刚才使用的 convey.ShouldBeTrue，就是判断 ok 的值应该为 true。\n1 2 3 4 5 6 func TestCheckUrl(t *testing.T) { convey.Convey(\u0026#34;TestCheckTeachUrl\u0026#34;, t, func() { ok:=CheckUrl(\u0026#34;learnku.com\u0026#34;) convey.So(ok,convey.ShouldBeTrue) }) } GoConvey 官方文档：Assertions · smartystreets/goconvey Wiki · GitHub\nTestify（断言） Testify 也是一个断言库，功能相对于 GoConvey 而言比较简单，主要是在提供断言功能之外，提供了 mock 的功能。\n1 2 import \u0026#34;github.com/stretchr/testify\u0026#34; go get -t github.com/stretchr/testify eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func TestCheckUrl3(t *testing.T) { assert := assert.New(t) var tests = []struct { input string expected bool }{ {\u0026#34;xdcute.com\u0026#34;, true}, {\u0026#34;xxx.com\u0026#34;, false}, } for _, test := range tests { fmt.Println(test.input) assert.Equal(CheckUrl(test.input), test.expected) } } GoMock（模拟接口） mock 工具的作用是指定函数的行为（模拟函数的行为）。可以对入参进行校验，对出参进行设定，还可以指定函数的返回值。\n并行测试 func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试。\nRunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。\n参考文章 \u0026ldquo;https://studygolang.gitbook.io/learn-go-with-tests/\u0026quot; \u0026ldquo;https://quii.gitbook.io/learn-go-with-tests/\u0026quot; ","permalink":"https://erica423.github.io/posts/singletest/","summary":"GO在线编译器：go playground Test-Driven Development(TDD) - 测试驱动开发 周期： 编写一个测试 让编译通过 运行测试，查看失败原因并检查错误消息是很有意义的 编写足够的代码以使测试通","title":"单元测试"},{"content":" Go 1. 垃圾回收 (Garbage Collection) 垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。\n引用计数 标记 - 清除 缺点：需要STW（stop the world） 分代收集 GC的触发条件：\n主动触发：runtime.GC 被动触发：(1)步调算法pacing (2)系统控制 Go GC三色标记？【百度go二面】** 什么是GC三色标记法？ 一种垃圾回收算法，用于追踪和标记活跃对象。不活跃的就会被回收。\n三色标记法规则？ 黑：完全标记，确定活跃，不会回收\n白：初态，未标记和追踪，最后被回收\n灰：被发现但未完全追踪\n初始状态下所有对象都是白色的。GC开始，从根节点开始遍历所有对象，将直接可达的对象标记为灰色；\n遍历灰色集合，灰色对象直接可达的对象标记为灰色，自身标记为黑色；\n通过 写屏障(write-barrier) 检测对象有变化，重复2，直到灰色对象全部变成黑色；\n回收白色对象(垃圾)\n什么是强弱三色不变式？ 强三色不变式：不存在黑色对象引用白色对象；\n弱三色：所有被黑色引用的白色必须有灰色上游对象；\n目的：他们都解决的都是漏标问题（黑对白的引用)\n什么是写屏障？ 在特定程序运行时刻，当对对象的指针进行写操作（修改引用关系）时触发的处理机制。目的是确保GC过程能正确追踪对象的引用关系，防止错误或遗漏回收，仅作用于堆上的内存回收。\n插入写屏障：如果有黑指白，则把白变灰；\n删除写屏障：当灰色删除一个指向白色的关系，白色标记为灰色。\n什么是混合写屏障？\n插入+删除:\n在GC开始时将栈上对象全部扫描并标记为黑色（不进行二次scan） 在GC期间任何栈上创建的对象都标记为黑色，避免二次scan 在GC期间删除任何的对象都标记为灰色 在GC期间创建的任何对象都标记为灰色 栈区没有写屏障逻辑，加重运行负担；把新加进栈的直接标成黑色（减少stw次数）\n为什么面试会问这个？\n基本用不到，可能就调调参数回收时间等。\nSTW (Stop The World) 为了避免在垃圾回收 (GC) 的过程中，对象之间的引用关系发生新的变更，使GC的结果发生错误，停止所有正在运行的协程。 STW对性能有一些影响，但go目前已经可以做到1ms以下的STW。 写屏障 (Write Barrier) 为了减小STW对程序的影响，要通过写屏障尽可能缩短STW时间。\n造成引用对象丢失的条件: 一个黑色的节点A新增了指向白色节点C的引用，并且白色节点C没有除了A之外的其他灰色节点的引用，或者存在但是在GC过程中被删除了。以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明白色节点C无其他灰色节点的引用了，即扫描结束后会被忽略 。\n写屏障破坏两个条件其一即可\n破坏条件1：Dijistra写屏障\n满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色\n破坏条件2：Yuasa写屏障 满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色\nselect可以用于什么？ golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。每个case语句里必须是一个面向channel的IO操作。\nGo函数中为什么发生内存泄漏？ goroutine需要维护执行用户代码的上下文信息，在运行过程中需要消耗一定的内存来保存这类信息。如果一个程序持续不断地产生新的goroutine且不结束已创建的goroutine并复用这部分内存，就会造成内存泄漏。\nGoroutine发生了泄漏如何检测？ Go自带的工具pprof或者使用Gops检测诊断当前在系统上运行的go进程占用的资源。\nGo内存对齐？ CPU访问内存时，不是逐个字节访问，而是以字长(word size)为单位进行访问。如32位的CPU，字长为4字节，那么CPU访问内存的单位也是4字节。\nCPU始终以字长访问内存，如果不进行内存对齐，很可能增加CPU访问内存的次数。\n可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的。如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。\n合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。\nGo函数传参是值类型还是引用类型？ Go中只存在值传递，要么传的是值的副本，要么是指针的副本。无论是值类型的变量还是引用类型的变量还是指针类型的变量，在作为参数传递时都会发生copy，开辟新的内存空间。\n另外值传递、引用传递和值类型、引用类型是两个不同的概念，不要混淆了。引用类型作为变量传递可以影响到函数外部是因为发生值拷贝后新旧变量指向了相同的内存地址。\nGo主协程如何等其余协程结束再操作？ 使用sync.WaitGroup，用来等待一组操作完成。WaitGroup内部实现了一个计数器，用来记录未完成的操作个数；Add()用来添加计数；Done()用来在操作结束时调用，使计数-1； Wait()用来等待所有的操作结束，在计数不为0时等待，为0时立即返回。\n","permalink":"https://erica423.github.io/posts/question/","summary":"Go 1. 垃圾回收 (Garbage Collection) 垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。 引用计数 标记 - 清除 缺点：需要STW（stop the world） 分代收集","title":"Q\u0026A | 面经"},{"content":"go语言slice和map底层实现原理 slice和map都是引用类型，长度不固定。\nslice底层： slice指向一个底层array，声明时不需要指定长度。\nappend函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。\nmap底层： map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是int类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。\nmap是无序的，如何map进行有序的排序？ 开一个空切片，把key拿出来，对key进行排序，再按排好序的key中map中拿value。\nslice的扩容机制 在使用 append 向 slice 追加元素时，若 slice 空间不足则会发生扩容，扩容会重新分配一块更大的内存，将原 slice 拷贝到新 slice ，然后返回新 slice。扩容后再将数据追加进去。\n扩容操作只对容量，扩容后的 slice 长度不变，容量变化规则如下：\n1.18版本之前：若 slice 容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。 若 slice 容量够用，则将新元素追加进去，slice.len++，返回原 slice 若 slice 容量不够用，将 slice 先扩容，扩容得到新 slice，将新元素追加进新 slice，slice.len++，返回新 slice。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { s1 := make([]int64, 0) for i := 0; i \u0026lt; 1025; i++ { s1 = append(s1, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s1), cap(s1)) // output: len = 1025, cap = 1280 s2 := make([]int32, 0) for i := 0; i \u0026lt; 1025; i++ { s2 = append(s2, 1) } fmt.Printf(\u0026#34;len = %d, cap = %d\\n\u0026#34;, len(s2), cap(s2)) // output: len = 1025, cap = 1344 } 原因是golang库下runtime/slice.go中的growslice函数的逻辑。核心是后半的内存对齐。switch的几个case分支，就是针对不同类型的slice。以et.size == sys.PtrSize分支为例，其思想就是首先计算出slice的内存大小，然后调用roundupsize函数内存对齐，然后计算出最终的容量。\nroundupsize函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var size_to_class8 = [1024/8 + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var class_to_size = [68]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} func roundupsize(size uintptr) uintptr { if size \u0026lt; _MaxSmallSize { // 32K内存以内 // class_to_size 68个不同的内存长度（包含0），对应runtime/sizeclasses.go中表格 // 当小于等于1016时，从size_to_class8中找，结果时1到32，对应class_to_size中的index // 否则从size_to_class128中找，结果是32到68。 最终都是根据index到class_to_size中最终的结果。 // 其作用就是67个内存长度中找到大于等于size的最接近的长度。 应该是为了效率考虑，直接查的方式，比挨个比较的效率更高。空间换时间 if size \u0026lt;= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { fmt.Println(divRoundUp(size-smallSizeMax, largeSizeDiv)) return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) } } if size+_PageSize \u0026lt; size { // 这种情况只会发生在溢出时，变成负数了 return size } return alignUp(size, _PageSize) } // 按8192的倍数向上取整，采用位运算的方式，更加高效 func alignUp(n, a uintptr) uintptr { return (n + a - 1) \u0026amp;^ (a - 1) } 到这里就可以解释int32的切片扩容后为什么是1344了:\n正常情况下，按照1.25被扩容后，容量为1024 * 1.25 = 1280; int32占4字节，其切片内存大小为，1280 * 4 = 5120; 通过查下面的表，可以得出大于等于5120的最接近的是5376; 最终的容量为 5376 / 4 = 1344 同样，也可以算出int64的切片内存对齐后，和原来是没有变化，仍然是1280。简单计算下：\n1280 * 8 = 10240; 查表仍然是10240 10240 / 8 = 1280。所以没有变化。 go 1.18版本后的修改 小于256时，双倍扩容；大于等于256时，扩容后容量 = 1.25倍的原容量 + 192。目的主要为了是内存的变化更加平滑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func growslice(et *_type, old slice, cap int) slice { // 省略。。。 newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } // 省略。。。 } 补充： int 类型大小为 8 字节, go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节; 如果是64位操作系统，int类型的大小就是8个字节\nint8 类型大小为 1 字节\nint16 类型大小为 2 字节\nint32 类型大小为 4 字节\nint64 类型大小为 8 字节\n取值范围\nint8: -128 ~ 127\nint16: -32768 ~ 32767\nint32: -2147483648 ~ 2147483647\nint64: -9223372036854775808 ~ 9223372036854775807\n结构体里的变量不加tag可以转json字符串吗？ 如果变量首字母小写，即为private变量，无论加不加tag都不可能转为json字段，因为获取不到反射信息。 反射？\n如果变量首字母大写，为public变量： 不加tag：可以转，json内字段名和结构体内字段原名一致； 加tag，转json的字段名就是tag里的字段名（也就是别名）。 生成json：jsonInfo, err := json.Marshal(struct_J)\n展示json内容：string(jsonInfo)\njson对象只支持string作为key。channel、complex、function不能被编码成json。\ngo语言TCP、UDP具体实现原理 TCP (Transmission Connect Protocol, 传输控制协议) 面向连接的、可靠的、基于字节流的传输层通信协议。提供了全双工通信、流量控制、错误控制等功能。\nTCP基本原理： 三次握手：通过三次握手建立TCP连接。 (1) client向server发送SYN包，请求连接；\n(2) server收到SYN包，向client发送SYN+ACK包，同意连接并确认client的SYN包；\n(3) client收到SYN+ACK包后，向server发送ACK包，确认连接。\n四次挥手：通过四次挥手断开TCP连接。 (1) client向server发送FIN包，表示不再发送数据；\n(2) server收到FIN包，向client发送ACK包，确认收到FIN包；\n(3) server向client发送FIN包，表示不再接收数据；\n(4) client收到FIN包后，向server发送ACK包，确认断连。\n流量控制：TCP使用滑动窗口机制进行流量控制。 server向client发送数据时，需要考虑client的接收能力，避免数据溢出。\n错误控制：TCP使用ACK和NACK机制进行错误控制。 当client收到server发送的数据时，需要发送ACK包确认。如果收到的数据有错，就发送NACK包。\nUDP (User Datagram Protocol, 用户数据报协议) 面向事务的、无连接、不可靠的传输层通信协议。 提供了简单快速的数据传输功能。\nUDP基本原理： 无连接：UDP不需要建立连接，数据包直接发送到目的地址。 不可靠：不提供可靠性保证，数据包可能丢失、错误或重复。 简单快速：UDP数据包的head只有8 byte，相对于TCP的20byte head更加简单快速。 Go语言的网络编程主要涉及以下几个核心概念： net包：Go语言提供了net包，用于实现网络编程。net包提供了TCP/UDP的基本功能，包括创建、监听、连接、读写等\nconn：conn是net包中的一个类型，表示一个网络连接。conn包含了连接的两端的地址和数据缓冲区。\nio包：Go语言的io包提供了一系列的读写器接口，用于实现各种数据流操作。网络编程中，我们经常使用io包的Reader和Writer接口来处理网络数据。\nbufio包：bufio包提供了基于缓冲的I/O功能，可以提高网络编程的性能。我们可以使用bufio包的Reader和Writer来实现高效的网络数据处理。\nTCP：使用 net.Dial/ net.Listen / conn.Write / conn.Read 等 UDP：使用 net.Dial / net.Listen / conn.Write / conn.ReadFrom / conn.SetReadDeadline 问：net.Listen和net.ListenTCPandnet.ListenUDP有啥区别？？\nnet.Listen()返回一个接口net.Listener，该接口只保证它支持以下方法：Accept()、Close()和Addr()。\nnet.ListenTCP()返回一个支持上述三种方法的类型*net.TCPListener，因此(鸭子类型duckTyping)它支持net.Listener接口。但是，它还支持更多特定于TCP的功能，并且可以控制连接接受的低级别方面。像设置SetDeadline()之类的事情。\n使用场景 Web服务：使用net/http包构建Web服务，提供RESTful API接口。 聊天室：使用TCP协议实现客户端和服务器之间的实时通信。 文件传输：使用UDP协议实现高速文件传输，例如P2P文件共享。 游戏服务器：使用TCP协议实现在线游戏服务器，处理玩家之间的实时通信和数据同步。 TCP和UDP的客户端实现 一致，只有net.Dial()的第一个参数不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Connect TCP conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) // Connect udp conn, err := net.Dial(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer conn.Close() //simple Read buffer := make([]byte, 1024) conn.Read(buffer) //simple write conn.Write([]byte(\u0026#34;Hello from client\u0026#34;)) TCP和UDP的服务端实现： 不同，在实现TCP时要用Listener接口监听和建立TCP连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // TCP l, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { return err } defer l.Close() for { conn, err := l.Accept() if err != nil { return err } go handleConnection(conn) } func handleConnection(conn net.Conn) { // ... buffer := make([]byte, 1024) conn.Read(buffer) conn.Write([]byte(\u0026#34;Hello from server\u0026#34;)) } 实现UDP时用PacketConn接口取代了Conn接口和Listener。\n与类型Conn不同的是，PackerConn并不支持io.reader和io.writer接口，但是它支持两个特殊的读写方法ReadFrom() 和 WriteTo() 。WriteTo()方法需要提供一个参数作为发送的数据到哪个地址，ReadFrom()则返回数据是从哪个地址接收的。 1 2 3 4 5 6 7 8 9 10 // UDP pc, err := net.ListenPacket(\u0026#34;udp\u0026#34;, \u0026#34;host:port\u0026#34;) if err != nil { log.Fatal(err) } buffer := make([]byte, 1024) pc.ReadFrom(buffer) pc.WriteTo([]byte(\u0026#34;Hello from client\u0026#34;), addr) go协程调度原理，协程为什么快？ goroutine的理解： goroutine，协程，是一种轻量级的用户线程（可以避免用户态到内核态的切换，从而节省了资源开销），由Go运行时调度器进行管理。Go中的每一个协程都会被分配到一个较小的栈空间（默认大小2KB），以非常低的成本进行创建和销毁。\ngoroutine的运行： Go运行时调度器采用了 M:N 的模型，即在M个操作系统线程上运行N个协程。具体来说，Go运行时初始化了一个或多个GOMAXPROCS指定数量的操作系统线程，并在这些线程上运行协程。\n​当一个协程阻塞时，调度器会自动将其与当前协程解除绑定，并将其转移到等待队列中，然后运行其它的协程，从而实现了高效地利用了CPU的时间片。\ngoroutine的优势： 协程不像传统多线程编程那样必须避免线程竞争和加锁解锁等操作。\n在Go中通常通过channel实现协程之间的同步和通信。Go的channel机制提供了一种非常有效且安全的协程同步方式，可以避免竞争条件和死锁等问题。\n同时，协程可以自我调节、自我管理，从而可以避免了频繁的线程切换带来的性能损耗。这使得协程有非常快的相应速度和高效的并发处理能力。\n扩展：\n并发(concurrency) vs 并行(parallelism) 在单个CPU 核上，线程通过时间片或者让出控制权来实现任务切换，达到 \u0026ldquo;同时\u0026rdquo; 运行多个任务的目的，这就是所谓的并发。但实际上任何时刻都只有一个任务被执行，其他任务通过某种算法来排队。\n只用多核CPU可以让同一进程内的\u0026quot;多个线程\u0026quot; 做到真正意义上的同时运行。\n进程 vs 线程 vs 协程 进程：系统进行资源分配的基本单位，占有独立的内存空间。\n线程：CPU调度和分配的基本单位，依附于进程存在，每个线程共享父进程的资源。\n线程的上下文切换？\n由于中断处理，多任务处理，用户态切换等原因会导致 CPU 从一个线程切换到另一个线程，切换过程需要保存当前进程的状态并恢复另一个进程的状态。代价是高昂的。\n协程：用户态的轻量级线程，调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。\nGoroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；\n线程栈空间通常是 2M，Goroutine 栈空间最小 2K；\nGolang 程序中可以轻松支持10w 级别的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。\nGo调度器是啥？ Go调度器模型通常叫做GPM模型，Go程序通过调度器来调度goroutine在内核线程上执行，但是goroutine（G）不直接绑定os线程（M）运行，而是由 goroutine scheduler 中的逻辑处理器（P）来作为获取内核线程资源的“中介”。\n包括4个重要结构，分别是G、P、M、Sched：(G砖头 M地鼠 P小车)\nG: Goroutine，协程，运行在线程上；每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。\nM: Machine，thread，即线程，循环调取协程并执行；OS 内核线程抽象，代表着真正执行计算的资源。在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取。\nM 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。\nM 并不保留 G 状态，这是 G 可以跨 M 调度的基础。\nP: Processor，处理器；对 G 来说，P 相当于 CPU 核，G 只有绑定到 P 才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 \u0026gt;= P 的数量）。\nP 的数量由用户设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256。\nSched: Go 调度器，它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复。\n具体讲解地址\ngo实现基本的排序和查找算法 详细内容\n（1）基本排序算法 基于Big-O(n^2)的排序\n选择排序：选数组中最小的元素和第一个元素交换；再选剩下元素中最小的和第二个元素交换，\u0026hellip; 空间O(1)，不稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func selectSort(arr []int) { for i := 0; i \u0026lt; len(arr); i ++ { minIndex := i for j := i + 1; j \u0026lt; len(arr); j ++ { if arr[minIndex] \u0026gt; arr[j] { minIndex = j; } } swap(arr, i, minIndex) } } func swap(arr []int, i, j int) { temp := arr[i] arr[i] = arr[j] arr[j] = temp } 冒泡排序: 从第一个元素开始，每次比较相邻元素，按顺序交换，否则继续往后比较下一对，\u0026hellip; 空间O(1)，稳定 1 2 3 4 5 6 7 8 9 10 func bubbleSort(arr []int) { for e := len(arr) - 1; e \u0026gt; 0; e -- { for i := 0; i \u0026lt; e; i ++ { // 升序 if arr[i] \u0026gt; arr[i + 1] { swap(arr, i, i + 1) } } } } 插入排序：冒泡的每一次冒，都要把无序序列轮一遍；插入排序恰恰相反，一旦你遇到比自己大或小的了，你就知道，后面都是比自己大或小的，现在坐下，当前元素就进入了有序序列。插入的每一次插，都不一定要轮一遍有序序列。 1 2 3 4 5 6 7 8 9 10 11 func insertSort(arr []int) { // 未排序区间 for i := 1; i \u0026lt; len(arr); i ++ { // 已排序区间 for j := i - 1; j \u0026gt;= 0; j -- { if arr[j] \u0026gt; arr[j + 1] { swap(arr, j, j + 1) } } } } 基于Big-O(nlogn)的排序\n快排：分治思想，空间O(logn), 不稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func quickSort(arr []int, L int, R int) { if(L \u0026lt; R){ lF, rF := float32(L), float32(R) rand.Seed(time.Now().UnixNano()) randomIndex := int(lF + rand.Float32() * (rF - lF + 1))//数组中随机获取下标 swap(arr, randomIndex, R) var p []int = partition(arr, L, R) //partition操作返回p[0]和p[1] quickSort(arr, L, p[0] - 1) //p[0]-1为随机下标对应的值的左边 quickSort(arr, p[1] + 1, R) //p[1]+1为随机下标对应的值的右边 } } func partition(arr []int, L int, R int) []int { less, more := L - 1, R //less区域为小于随机下标对应的值，more区域为大于随机下标对应的值 for L \u0026lt; more { if arr[L] \u0026lt; arr[R] { less++ swap(arr, less, L) L++ } else if arr[L] \u0026gt; arr[R]{ more-- swap(arr, more, L) } else { L++ } } swap(arr, more, R) return []int {less + 1, more} } 归并排：空间复杂度O(n)，稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func mergeSort(arr []int, L int, Mid int, R int) { if len(arr) \u0026lt; 2 { return } help := make([]int, 0, R - L + 1) p1, p2 := L, Mid + 1 for p1 \u0026lt;= Mid \u0026amp;\u0026amp; p2 \u0026lt;= R { if arr[p1] \u0026lt;= arr[p2] { help = append(help, arr[p1]) p1++ } else { help = append(help, arr[p2]) p2++ } } for p1 \u0026lt;= Mid { help = append(help, arr[p1]) p1++ } for p2 \u0026lt;= R { help = append(help, arr[p2]) p2++ } for i := 0; i \u0026lt; len(help); i++ { arr[L + i] = help[i] } } 堆排（优先队列）： heapInsert(arr []int, index int) 建立大根堆，(index * 2) + 1为该节点左孩子，(index * 2) + 2 为该节点右孩子，(index - 1) / 2 为该节点的父节点。若该节点大于父节点，就交换，并且index = (index - 1) / 2。\nheapify(arr []int, index int, heapSize int), 找到最后一个节点lastNode，该节点与当前根节点交换，同时heap\u0026ndash;，即最后位置上为最大值，根节点为极小值。此时从根结点出发，继续heapify的过程(左孩子右孩子较大者与根节点交换, lastNode节点 来到孩子节点较大者位置，继续左右孩子较大者比较，直至没有左右孩子)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func heapInsert(arr []int, index int){ for arr[index] \u0026gt; arr[(index - 1) / 2] { swap(arr, index, (index - 1) / 2) index = (index - 1) / 2 } } //index * 2 + 1 左孩子节点 //index * 2 + 2 右孩子节点 //(index - 1) / 2 父节点 func heapify(arr []int, index int, heapSize int){ var largestIndex int leftNode := index * 2 + 1 for leftNode \u0026lt; heapSize { if leftNode + 1 \u0026lt; heapSize \u0026amp;\u0026amp; arr[leftNode + 1] \u0026gt; arr[leftNode] { largestIndex = leftNode + 1 } else { largestIndex = leftNode } if arr[largestIndex] \u0026lt; arr[index] { largestIndex = index } if largestIndex == index { break } swap(arr, largestIndex, index) index = largestIndex leftNode = index * 2 + 1 } } （2）基本查找算法 博文link\n七大查找算法： 顺序查找、二分查找、差值查找、斐波那契查找、 树表查找 (二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树)、分块查找、哈希查找、图查找 (广度优先查找、深度优先查找)\n分类： 静态查找 vs 动态查找\n有序查找 vs 无序查找\nmysql索引分为几种？ 按数据结构：B+tree索引、Hash索引、Full-text索引。\n按物理存储：聚簇索引、二级索引（辅助索引或者非主键索引）。\nMySQL索引按叶子节点存储的是否为完整表数据分为：聚簇索引、二级索引（辅助索引）。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。\n按字段特性：主键索引、普通索引、前缀索引。\n按字段个数：单列索引、联合索引（复合索引、组合索引）。\nRedis vs MySQL 区别： 数据类型 mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。\nredis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。\n本质区别 Redis：基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，而内存成本较高；\nMySQL：基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高；\nredis优缺点 优点 速度快：Redis 数据存储在内存中，读写速度非常快，适用于需要高速数据处理的场景。\n数据结构丰富：Redis 支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，可以满足不同类型的数据存储需求。\n支持分布式：Redis 可以通过主从复制和哨兵机制实现分布式部署，提高系统的可靠性和可用性。\n轻量级：Redis 相对其他数据库来说比较轻量级，占用资源少，启动速度快。\n可扩展性：Redis 可以通过插件或扩展机制实现更多的功能，如 Redis Modules。\n支持事务：Redis 提供了简单的事务机制，保证了数据的一致性。\n缺点 内存限制：由于数据存储在内存中，Redis 的内存容量有限，无法处理大量的数据\n数据持久性：Redis 默认情况下是将数据存储在内存中的，如果没有正确配置持久化机制，数据在服务器重启或故障时可能会丢失。\n复杂性：虽然 Redis 相对简单，但在分布式环境下的管理和配置可能会变得复杂。\n不支持复杂查询：Redis 主要用于简单的数据操作，对于复杂的查询和分析功能较弱。\n使用场景 缓存：Redis 最常见的用途之一是作为缓存服务器，将频繁访问的数据存储在内存中，以加速数据访问速度。由于 Redis 具有快速的读写速度和丰富的数据结构，适用于各种缓存场景，如网页缓存、会话缓存、对象缓存等。\n会话存储：Redis 可以用作会话存储，将用户会话数据存储在内存中，以提供快速的会话访问和管理。这对于需要跨多个服务器共享会话数据的 Web 应用程序非常有用。\n消息队列：Redis 支持发布/订阅模式（Pub/Sub），可以用作轻量级的消息队列系统，实现消息的发布和订阅，用于异步任务处理、事件通知等场景。\n计数器：Redis 的原子操作能力使其成为实现计数器功能的理想选择。它可以用于统计网站访问量、用户点击量、商品销量等。\n分布式锁：Redis 的分布式锁功能可以用于实现分布式系统中的互斥操作，确保共享资源的安全访问。这对于控制并发访问、避免资源竞争非常有用。\n实时数据分析：Redis 支持持久化和数据备份，可以用于实时数据分析和监控系统，存储实时数据，并支持数据的快速查询和分析。\n任务队列：Redis 可以用作任务队列，用于存储和管理需要异步处理的任务，如后台任务、定时任务等。\n地理位置服务：Redis 的地理位置数据类型（Geo）可以用于存储地理位置信息，并支持基于位置的搜索和查询，用于实现位置服务和地理信息系统。\nmysql优缺点 优点 开源和免费：MySQL 是开源软件，可以免费使用，降低了企业的成本负担。\n跨平台性：MySQL 可以在多种操作系统上运行，包括 Windows、Linux、Mac 等，具有良好的跨平台性。\n易于使用：MySQL 的安装和配置相对简单，具有良好的用户文档和社区支持，使得用户可以快速上手并进行数据库管理和查询。\n高性能：MySQL 具有较高的性能，能够处理大量的并发请求，提供高效的数据存取和查询能力。\n可扩展性：MySQL 支持主从复制、分区表、分布式数据库等功能，可以方便地进行系统扩展和负载均衡。\n缺点 性能瓶颈：在处理大规模数据和高并发请求时，MySQL 可能会遇到性能瓶颈，需要进行优化和调整以满足需求。\n单点故障：MySQL 在单机部署时存在单点故障的风险，需要采取合适的容错和备份策略来保证系统的可靠性和稳定性。\n复杂的管理：虽然 MySQL 相对易于使用，但在大规模部署和管理时，需要花费一定的时间和精力来进行数据库的管理和维护。\n存储引擎限制：MySQL 的存储引擎数量有限，不同的存储引擎具有不同的特性和性能，选择合适的存储引擎需要根据具体需求进行评估。\n事务支持有限：在某些场景下，MySQL 的事务支持可能有限，不适合要求严格事务一致性的应用场景。\n使用场景 Web 应用程序：MySQL 是许多 Web 应用程序的首选数据库，包括电子商务网站、博客、社交网络、论坛等。它能够处理大量的并发请求，并提供良好的性能和可靠性。\n日志和监控系统：MySQL 可以用于存储日志和监控数据，用于分析系统的运行状态和性能指标，帮助管理员监控和管理系统的运行情况。\n企业应用程序：许多企业级应用程序使用 MySQL 作为其关键的数据存储和管理工具。这些应用程序可能涉及客户关系管理（CRM）、企业资源规划（ERP）、人力资源管理（HRM）等各种业务功能。\n数据仓库和报告系统：MySQL 可以作为数据仓库和报告系统的后端存储，用于存储和管理大量的历史数据，并支持复杂的查询和报告生成。\nes具体的使用方法好在哪里？ Elasticsearch是一个开源的分布式全文搜索引擎，它构建在Apache Lucene库之上。它专注于提供快速、弹性和可靠的全文搜索、结构化搜索、分析和可视化功能。\n详细介绍\n分布式架构： Elasticsearch被设计为在多台服务器上运行，并自动管理数据的分片和复制。这使得它能够处理大规模的数据，并提供高可用性和容错性。\n全文搜索： Elasticsearch使用倒排索引技术，可以高效地进行全文搜索。它支持各种查询类型，包括匹配、模糊搜索、范围搜索等。\n实时数据： Elasticsearch对数据的更改几乎是实时的，通常在毫秒级别内就可以被索引并可查询。这使得它非常适合需要及时反馈的应用场景，如日志分析、监控数据处理等。\n多语言支持： Elasticsearch提供了广泛的语言客户端，使得开发人员可以使用自己熟悉的语言与之交互，如Java、Python、Node.js等。\n弹性扩展： Elasticsearch支持水平扩展，可以通过添加更多的节点来增加存储容量和负载能力。它还提供了自动分片和负载均衡机制，使得数据在集群中的分布更加均匀。\n多种数据类型支持： 除了文本数据，Elasticsearch也可以处理结构化数据和地理位置数据。它支持各种数据类型的索引和查询，包括字符串、数字、日期、布尔值、数组等。\n易于使用的API： Elasticsearch提供了RESTful风格的API，可以使用HTTP协议与之进行交互。这使得开发人员可以轻松地索引、查询、修改和删除数据。\n数据聚合与分析： Elasticsearch提供了丰富的聚合功能，可以对数据进行统计、分组、筛选和排序等操作。同时，它还集成了Kibana工具，用于可视化和分析数据。\nHTTP状态码 1XX - 提示信息 2XX - success 3XX - 重定向 4XX - 客户端错误，请求有语法错误or请求无法实现 400 - bad request 错误请求 服务器不理解请求的语法 401 - unauthorized 未授权 请求要求身份验证 402 - 为了将来可能的需求而预留的 403 - forbidden 禁止 服务器拒绝请求 404 - not found 未找到 服务器找不到请求的网页 5XX - 服务端错误，服务器未能实现合法的请求 你在开发过程中遇到了什么困难 以及怎么解决的 ","permalink":"https://erica423.github.io/posts/tech/","summary":"go语言slice和map底层实现原理 slice和map都是引用类型，长度不固定。 slice底层： slice指向一个底层array，声明时不","title":"Go相关"},{"content":" 2024暑期找实习学习进度\n计划：golang后端开发 实习的准备程度:\n数据结构与算法: 代码随想录4 刷, 部分labuladong笔记 剑指offer1 leetcode 350\n计算机网络: 小林coding图解网络 计算机网络自顶向下\n操作系统: 小林coding图解系统 操作系统导论\nMysql: MySQL必知必会 从根上理解MySQL 小林MySQL图解\nRedis: Redis设计与实现 小林coding Redis部分\n编程语言:\nGo: Go语言圣经 GoWeb编程 Go语言设计与实现 Go专家编程\nC++: \u0026lt;C++ Primer\u0026gt; \u0026lt;Efficient C++\u0026gt; \u0026lt;TCP/IP网络编程\u0026gt;\n项目写一个Redis单机服务器, 另外还有一个就是https://betxin.one了\nGo 1. 语言基础 《Go语言学习笔记》（语法部分） 单测练手：learn-go-with-tests （全部部分） Go底层 b站视频 2. 进阶 《Go Web编程》link （5.9 finish） Gin (5.10) Gorm 文档 微服务框架：go-zero (√) / kratos 3. 项目 pacgo 吃豆子项目 7daysGolang link Gee link go-gin-example link 搭建自己的blog：静态Hugo，维护中\u0026hellip; 在学项目：基于go-zero的IM实时聊天项目 Go面经 Go大厂面试真题(130页-带答案).pdf Go后端开发大厂面试题(八股文-188页-带答案).pdf Golang修养之路.pdf Golang开发岗面试笔记(26页-带答案).pdf Go程序员面试笔试宝典.txt 链接 Golang常见面试题解析(129页-带答案).pdf 算法 代码随想录: 链接\n数组 链表 哈希表 字符串 双指针法 栈和队列 二叉树 回溯算法 贪心算法 动态规划 单调栈 图论 。。。 ","permalink":"https://erica423.github.io/posts/todo/","summary":"2024暑期找实习学习进度 计划：golang后端开发 实习的准备程度: 数据结构与算法: 代码随想录4 刷, 部分labuladong笔记 剑指offe","title":"ToDo List"}]