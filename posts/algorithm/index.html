<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>算法 | Erica-Blog</title>
<meta name=keywords content="技术"><meta name=description content="1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位"><meta name=author content="erica423"><link rel=canonical href=https://erica423.github.io/posts/algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.765a84d67992a2542387ba60a51d1ca92b3fe2e3791d5ca120ea783131514435.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=16x16 href=https://erica423.github.io/images/dls_icon.png><link rel=icon type=image/png sizes=32x32 href=https://erica423.github.io/images/dls_icon.png><link rel=apple-touch-icon href=https://erica423.github.io/images/dls_icon.png><link rel=mask-icon href=https://erica423.github.io/images/dls_icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://erica423.github.io/posts/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>(function(){""&&prompt("请输入文章密码")!==""&&(alert("密码错误！"),history.back())})()</script><meta property="og:title" content="算法"><meta property="og:description" content="1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位"><meta property="og:type" content="article"><meta property="og:url" content="https://erica423.github.io/posts/algorithm/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-15T15:28:02+08:00"><meta property="article:modified_time" content="2024-08-15T15:28:02+08:00"><meta property="og:site_name" content="erica-blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="算法"><meta name=twitter:description content="1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erica423.github.io/posts/"},{"@type":"ListItem","position":2,"name":"算法","item":"https://erica423.github.io/posts/algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"算法","name":"算法","description":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位","keywords":["技术"],"articleBody":"1 数组 1.1 数组存储 不论一维数组还是二维数组，其存储地址空间都是线性连续的。 go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位的默认 int 位数为 4。 Go int类型数据长度：\n列1 列2 文本居中 文本居右 1.2 二分查找 前提：有序数组，无重复元素\n重点：区间的定义（区间就是不变量！)\n写法1 [l, r] while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= ;\nif (nums[middle] \u003e target) right = middle - 1，因为当前这个nums[middle] 一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1. left = mid + 1.\n写法2 [l, r) while (left \u003c right)\nright = mid, left = mid + 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // [l, r]版本 func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u003c= r { mid := l + (r - l) / 2 if nums[mid] \u003e target { r = mid - 1 } else if nums[mid] \u003c target { l = mid + 1 } else { return mid } } return -1 } // [l, r) func search(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u003c r { mid := l + (r - l) / 2 if nums[mid] \u003e target { r = mid } else if nums[mid] \u003c target { l = mid + 1 } else { return mid } } return -1 } golang二分查找的库函数：index := sort.Search(n int, f func(i int) bool) int)\n该函数使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True。 如果无法找到该index值，则该方法为返回n. 常用场景 该方法一般用于从一个已经排序的数组中找到某个值所对应的索引。 或者从字符串数组中，找到满足某个条件的最小索引值，比如etcd中的键值范围查询就用到了该方法。 1.3 原地移除元素 要求：删除数组中值等于val的元素，不可以使用额外的空间。\n重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。\n暴力做法 两层for循环，第一个for查找值等于val的元素，第二层for依次将后续元素提前一位覆盖掉前一位元素。 复杂度：O(n^2) O(1) 快慢指针做法 实现一个快指针一个慢指针用一个for循环解决。复杂度：O(n) O(1) 定义： 快指针：寻找组成新数组的元素（不含=val的元素）； 慢指针：指向更新 新数组下标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func removeElement(nums []int, target int) int { slow := 0 for fast := 0; fast \u003c len(nums); fast ++ { if nums[fast] != val { nums[slow] = nums[fast] slow ++ } } nums = nums[:slow] return nums } // 双向双指针 func removeElement(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u003c= r { for l \u003c= r \u0026\u0026 nums[l] != val { l ++ } for l \u003c= r \u0026\u0026 nums[r] != val { r -- } // 找到左侧的val和右侧的非val后开始覆盖，覆盖后继续寻找 if l \u003c r { nums[l] = nums[r] l ++ r -- } } return l } 1.4 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 暴力思路： 每个数平方后排序，时间复杂度O(n + nlogn)\n双指针法： i指向起始位置，j指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。\n如果A[i] * A[i] \u003c A[j] * A[j] 那么result[k--] = A[j] * A[j]; 。\n如果A[i] * A[i] \u003e= A[j] * A[j] 那么result[k--] = A[i] * A[i]; 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func sortedSquares(nums []int) []int { n := len(nums) i, j, k := 0, n - 1, n - 1 res := make([]int, n) for i \u003c= j { lm, rm := nums[i] * nums[i], nums[j] * nums[j] if lm \u003e rm { res[k] = lm i ++ } else { res[k] = rm j -- } k -- } } 1.5 长度最小的数组 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u003c= target \u003c= 10^9 1 \u003c= nums.length \u003c= 10^5 1 \u003c= nums[i] \u003c= 10^5 暴力： 两个for循环，时间复杂度 O(n^2)\n滑动窗口 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。 O(n)\n在本题中实现滑动窗口，主要确定如下三点：\n窗口内是什么？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n如何移动窗口的起始位置？ 如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n如何移动窗口的结束位置？ 窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 while (sum \u003e= s) { subLen = (j - i + 1); res = min(res, subLen); sum -= nums[i ++ ]；\t// 滑动窗口的精髓，不断变更起始位置 } func minSubArrayLen(target int, nums []int) int { n := len(nums) res := n + 1 i, sum := 0, 0 for j := 0; j \u003c n; j ++ { sum += nums[j] for sum \u003e= target { subLen := j - i + 1 res = min(res, subLen) sum -= nums[i] i ++ } } if res == n + 1 { return 0 } else { return res } } func min(x int, y int) int { if x \u003e y { return y } else { return x } } 1.6 螺旋矩阵II (高频) 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n示例:\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n求解本题依然是要坚持循环不变量原则。\n模拟顺时针画矩阵的过程:\n填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。\n可以看出拐角处是让给下一条边画的，也就是左闭右开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vector\u003cvector\u003cint\u003e\u003e res(n, vector\u003cint\u003e(n, 0)); int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次 int mid = n / 2; // 矩阵的中心位置 int cnt = 1;// 用来给矩阵中每一个空格赋值 int offset = 1;// 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i, j; while (loop -- ) { i = startx; j = starty; // 上行 for (j; j \u003c n - offset; j ++ ) { res[i][j] = cnt ++ ; } // 右列 for (i; i \u003c n - offset; i ++ ) { res[i][j] = cnt ++ ; } // 下行 for (; j \u003e starty; j -- ) { res[i][j] = cnt ++ ; } // 左列 for (; i \u003e startx; i -- ) { res[i][j] = cnt ++ ; } // 第二圈开始的时候，起始位置要各自加1 startx ++ , startty ++ ; // offset 控制每一圈里每一条边遍历的长度 offset += 1; } if (n % 2) { res[mid][mid] = cnt; } return res; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import \"fmt\" func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { startx, starty := 0, 0 var loop int = n / 2 var center int = n / 2 count := 1 offset := 1 res := make([][]int, n) for i := 0; i \u003c n; i++ { res[i] = make([]int, n) } for loop \u003e 0 { i, j := startx, starty //行数不变 列数在变 for j = starty; j \u003c n-offset; j++ { res[startx][j] = count count++ } //列数不变是j 行数变 for i = startx; i \u003c n-offset; i++ { res[i][j] = count count++ } //行数不变 i 列数变 j-- for ; j \u003e starty; j-- { res[i][j] = count count++ } //列不变 行变 for ; i \u003e startx; i-- { res[i][j] = count count++ } startx++ starty++ offset++ loop-- } if n%2 == 1 { res[center][center] = n * n } return res } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u003c n; i++ { matrix[i] = make([]int, n) } for num \u003c= tar { for i := left; i \u003c= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u003c= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u003e= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u003e= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间 空间复杂度 O(1) 链表 https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\n链表的类型 单链表：\n双链表：\n循环链表：解决约瑟夫环问题\n存储方式 链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义 C/C++ 定义链表节点\n1 2 3 4 5 6 7 8 9 // 单链表 struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 } // 初始化 ListNode* head = new ListNode(5) go 定义链表节点\n1 2 3 4 5 6 type ListNode struct { Val int Next *ListNode } head := new(ListNode) 2.1 移除链表元素 题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n如果删除的是头结点该怎么办呢？\n直接使用原来的链表来进行删除操作。 设置一个虚拟头结点在进行删除操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { for head != nil \u0026\u0026 head.Val == val { head = head.Next } } 这样移除了一个头结点，在单链表中移除头结点 和 移除其他节点的操作方式是不一样, 那么可不可以 以一种统一的逻辑来移除 链表的节点呢。\n可以设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026ListNode{} dummyHead.Next = head cur := dummyHead // 当前的头指针 for cur != nil \u0026\u0026 cur.Next != nil { if cur.Next.Val == val { cur.Next = cur.Next.Next } else { cur = cur.Next } } return dummyHead.Next } 2.2 设计链表 在链表类中实现这些功能：\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 设计五个接口：\n获取链表第index个节点的数值； 在链表的最前边插入一个节点 在最后插入一个节点 在第index个节点前面插入一个节点 删除第index个节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val) : val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { if (index \u003e (_size - 1) || index \u003c 0) { return -1; } LinkedNode* cur = _dummyHead-\u003enext; while (index -- ) { cur = cur-\u003enext; } return cur-\u003eval; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-\u003enext = _dummyHead-\u003enext; _dummyHead-\u003enext = newNode; _size ++ ; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (cur-\u003enext != nullptr) { cur = cur-\u003enext; } cur-\u003enext = newNode; _size ++ ; } void addAtIndex(int index, int val) { if (index \u003e _size) return; if (index \u003c 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u003enext; } newNode-\u003enext = cur-\u003enext; cur-\u003enext = newNode; _size ++ ; } void deleteAtIndex(int index) { if (index \u003e= _size || index \u003c 0) { return; } LinkedNode* cur = _dummyHead; while (index -- ) { cur = cur-\u003enext; } LinkedNode* tmp = cur-\u003enext; cur-\u003enext = cur-\u003enext-\u003enext; delete tmp; tmp = nullptr; _size -- ; } // 打印 void printLinkedList() { LInkedNode* cur = _dummyHead; while (cur-\u003enext != nullptr) { cout \u003c\u003c cur-\u003enext-\u003eval \u003c\u003c \" \"; cur = cur-\u003enext; } cout \u003c\u003c endl; } private: int _size; LinkedNode* _dummyHead; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package main import ( \"fmt\" ) type SingleNode struct { Val int Next *SingleNode } type MyLinkedList struct { dummyHead *SingleNode // 虚拟头结点 Size int // 链表大小 } func main() { list := Constructor() list.AddAtHead(100) list.AddAtTail(242) list.AddAtTail(777) list.AddAtIndex(1, 99999) list.printLinkedList() } // Initialize func Constuctor() MyLinkedList { newNode := \u0026SingleNode { -999, nil, } return MyLinkedList{ dummyHead: newNode, Size: 0, } } func (m *MyLinkedList) Get(index int) int { if m == nil || index \u003c 0 || index \u003e= m.Size { return -1 } cur := m.dummyHead.Next for i := 0; i \u003c index; i ++ { cur = cur.Next } return cur.Val } func (m *MyLinkedList) AddAtHead(val int) { newNode := \u0026SingleNode{Val: val} newNode.Next = m.dummyHead.Next m.dummyHead.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtTail(val int) { newNode := \u0026SingleNode{Val: val} cur := m.dummyHead for cur.Next != nil { cur = cur.Next } cur.Next = newNode m.Size ++ } func (m *MyLinkedList) AddAtIndex(index int, val int) { if index \u003c 0 { index = 0 } else index \u003e m.Size { return } newNode := \u0026SingleNode{Val: val} cur := m.dummyHead for i := 0; i \u003c index; i ++ { cur = cur.Next } newNode.Next = cur.Next cur.Next = newNode m.Size ++ } func (m *MyLinkedList) DeleteAtIndex(index int) { if index \u003c 0 || index \u003e= m.Size { return } cur := m.dummyHead for i := 0; i \u003c index; i ++ { cur = cur.Next } if cur.Next != nil { cur.Next = cur.Next.Next } m.Size -- } func (m *MyLinkedList) printLinkedList() { cur := m.dummyHead for cur.Next != nil { fmt.Println(cur.Next.Val) cur = cur.Next } } 循环双链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 type Node struct { Val int Next *Node Pre *Node } type MyLinkedList struct { dummy *Node } //仅保存哑节点，pre-\u003e rear, next-\u003e head /** Initialize your data structure here. */ func Constructor() MyLinkedList { rear := \u0026Node{ Val: -1, Pre: nil, Next: nil, } rear.Next = rear rear.Pre = rear return MyLinkedList{rear} } func (m *MyLinkedList) Get(index int) int { head := m.dummy.Next for head != m.dummy \u0026\u0026 index \u003e 0 { index -- head = head.Next } if 0 != index { return -1 } return head.Val } func (m *MyLinkedList) AddAtHead(val int) { dummy := m.dummy node := \u0026Node{ Val: val, Pre: dummy, Next: dummy.Next, } dummy.Next.Pre = node dummy.Next = node } /** Append a node of value val to the last element of the linked list. */ func (this *MyLinkedList) AddAtTail(val int) { dummy := this.dummy rear := \u0026Node{ Val: val, //rear.Next = dummy(哑节点) Next: dummy, //rear.Pre = ori_rear Pre: dummy.Pre, } //ori_rear.Next = rear dummy.Pre.Next = rear //update dummy dummy.Pre = rear //以上两步不能反 } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ func (this *MyLinkedList) AddAtIndex(index int, val int) { head := this.dummy.Next //head = MyLinkedList[index] for head != this.dummy \u0026\u0026 index \u003e 0 { head = head.Next index-- } if index \u003e 0 { return } node := \u0026Node{ Val: val, //node.Next = MyLinkedList[index] Next: head, //node.Pre = MyLinkedList[index-1] Pre: head.Pre, } //MyLinkedList[index-1].Next = node head.Pre.Next = node //MyLinkedList[index].Pre = node head.Pre = node //以上两步不能反 } /** Delete the index-th node in the linked list, if the index is valid. */ func (this *MyLinkedList) DeleteAtIndex(index int) { //链表为空 if this.dummy.Next == this.dummy { return } head := this.dummy.Next //head = MyLinkedList[index] for head.Next != this.dummy \u0026\u0026 index \u003e 0 { head = head.Next index-- } //验证index有效 if index == 0 { //MyLinkedList[index].Pre = index[index-2] head.Next.Pre = head.Pre //MyLinedList[index-2].Next = index[index] head.Pre.Next = head.Next //以上两步顺序无所谓 } } 2.3 反转链表(高频) 思路：\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。\n其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n1 双指针法 O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; ListNode* cur = head; ListNode* pre = null; while (cur) { temp = cur-\u003enext; // 保存cur的下一个节点 cur-\u003enext = pre; // 翻转操作 pre = cur; cur = temp; } } }; 2 递归法：不同的地方在初始化 O(n) O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: ListNode* reverse(ListNode* pre, ListNode* cur) { if (cur == NULL) return pre; ListNode* temp = cur-\u003enext; cur-\u003enext = pre; return reverse(cur, temp); } ListNode* reverseList(ListNode* head) { return reverse(NULL, head); } }; Go版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 双指针写法 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } // 递归 func reverseList(head *ListNode) *ListNode { return help(nil, head) } func help(pre, head *ListNode) *ListNode { if head == nil { return pre } tmp := head,Next head.Next = pre return help(head, tmp) } 2.4 两两交换相邻节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n用虚拟头结点，之后模拟就可以了。O(n) O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func swapPairs(head *ListNode) *ListNode { dummy := \u0026ListNode{ Next: head, } //head=list[i] //cur=list[i-1] cur := dummy for head != nil \u0026\u0026 head.Next != nil { cur.Next = head.Next // cur-\u003e2 tmp := head.Next.Next // tmp-\u003e3 head.Next.Next = head // 3-\u003e1 head.Next = tmp // 1-\u003e3 //cur=list[(i+2)-1] cur = head //head=list[(i+2)] head = tmp // head-\u003e3 } return dummy.Next } 2.5 删除链表的倒数第n个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n思路：双指针，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n定义fast和slow指针，初始值为虚拟头结点 fast走n + 1步，因为只有这样同时移动时slow才可以指向被删除节点的上一节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := \u0026ListNode{0, head} fast, slow := dummy, dummy for i := 0; i \u003c= n; i ++ {// 注意\u003c=，否则快指针为空时，慢指针正好在倒数第n个上面 fast = fast.Next } for fast != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return dummy.Next } // O(n) O(1) 2.6 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目保证不存在环形，不能改变原链表。\n思路： 求两个链表交点节点的指针。（注意！是指针相等，不是数值相等）\ncurA指向链表A的头结点，curB指向链表B的头结点； 求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置； 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *curA = headA; ListNode *curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) { lenA ++ ; curA = curA -\u003e next; } while (curB != NULL) { lenB ++ ; curB = curB -\u003e next; } if (lenB \u003e lenA) { // 让curA为最长链表的头 swap(lenA, lenB); swap(curA, curB); } int gap = lenA - lenB; while (gap -- ) { // 两链末尾对齐 curA = curA -\u003e next; } while (curA != NULL) { // 遍历curA和curB，遇到相同则直接返回 if (curA == curB) return curA; curA = curA -\u003e next; curB = curB -\u003e next; } return NULL; } }; // O(n + m) O(1) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func getIntersectionNode(headA, headB *ListNode) *ListNode { curA, curB := headA, headB; lenA, lenB := 0, 0 for curA != nil { curA = curA.Next lenA ++ } for curB != nil { curB = curB.Next lenB ++ } var gap int var fast, slow *ListNode if lenA \u003e lenB { gap = lenA - lenB fast, slow = headA, headB } else { gap = lenB - lenA fast, slow = headB, headA } for i := 0; i \u003c gap; i ++ { fast = fast.Next } for fast != slow { // 遍历两个链表，遇到相同的就跳出遍历 fast = fast.Next slow = slow.Next } return fast } // 双指针 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { a, b := headA, headB for a != b { if a != nil { a = a.Next } else { a = headB } if b != nil { b = b.Next } else { b = headA } } return a } 2.7 环形链表II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n考察：\n判断链表是否有环\n快慢指针。fast += 2, slow ++ , 如果 fast 和 slow指针在途中相遇 （必在环中相遇），说明这个链表有环。 有环的话如何找到入口\n从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，此时从 head 和 相遇点，同时查找直至相遇 if fast == slow { for slow != head { slow = slow.Next head = head.Next } return head // 返回环的入口 } } return nil } 哈希表（散列表） 一般哈希表都用快速判断一个元素是否出现在集合里。\nhash function：把某个信息映射到哈希表上的索引。\nhash collisions（哈希碰撞\\冲突）：e.g. 多个姓名都映射到了同一个索引下标。\n拉链法： 线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。 哈希结构：\n数组 集合 set 映射 map c++ 底层：\n集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) **go呢？**go中的hash结构通常是指map，底层是 数组+单链表\nhttps://blog.csdn.net/vince1998/article/details/137185380\n做题技巧：\n题目提示只有小写字母，暗示用数组做哈希。大小不受限，不用数组。 数组大小有限 或 数组空间大但哈希值少，分散，建议set。 要返回下标，不能排序，用map结构返回两者。 哈希vs双指针：哈希法对于需要去重的题目效率较低，建议使用双指针。 3.1 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true\n示例 2: 输入: s = “rat”, t = “car” 输出: false\n说明: 你可以假设字符串只包含小写字母。\n暴力：两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。 哈希表：定一个数组叫做record，大小为26，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。O(n) O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 func isAnagram(s string, t string) bool { record := [26]int{} for _, v := range s { record[v - rune('a')] ++ } for _, v := range t { record[v - rune('a')] -- } return record == [26]int{} } 3.2 两个数组的交集 使用数组来做哈希的题目，是因为题目都限制了数值的大小。\n没有限制数值的大小就无法使用数组来做哈希表了。\n而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solultion { public: vector\u003cint\u003e intersection(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { unordered_set\u003cint\u003e res; unordered_set\u003cint\u003e nums(nums1.begin(), nums1.end()); for (auto num: nums2) { if (nums.find(num) != nums.end()) { res.insert(num); } } return vector\u003cint\u003e(res.begin(), res.end()); } }; // O(n + m) m是最后要把set转成vector // O(n) go:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func intersection(nums1 []int, nums2 []int) []int { set := make(map[int]struct{}, 0) // map模拟set res := make([]int, 0) for _, v := range nums1 { if _, ok := set[v]; !ok { set[v] = struct{}{} } } for _, v := range nums2 { // if exists in the last array, insert into res, and delete this set value. if _, ok := set[v]; ok { res = append(res, v) delete(set, v) // delete(map, key) } } return res } // v2: use array when the number of data is small func intersection(nums1 []int, nums2 []int) []int { count1 := make([]int, 1001, 1001) count2 := make([]int, 1001, 1001) res := make([]int, 0) for _, v := range nums1 { count1[v] = 1 } for _, v := range nums2 { count2[v] = 1 } for i := 0; i \u003c= 1000; i ++ { if count1[i] + count2[i] == 2 { res = append(res, i) } } return res } 3.3 快乐树 编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n思路：判断sum是否重复出现过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int getSum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n /= 10; } return sum; } bool isHappy(int n) { unordered_set\u003cint\u003e set; while (1) { int sum = getSum(n); if (sum == 1) { return true; } if (set.find(sum) != set.end()) { return false; // sum出现过，死循环了 } else { set.insert(sum); } n = sum; } } // O(logn) O(logn) go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getSum(n int) int { sum := 0 for n \u003e 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } func isHappy(n int) bool { m := make(map[int]bool) for n != 1 \u0026\u0026 m[n] == 0 { n, m[n] = getSum(n), true } return n == 1 } 3.4 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n242. 有效的字母异位词 (opens new window)这道题目是用数组作为哈希表来解决哈希问题，349. 两个数组的交集 (opens new window)这道题目是通过set作为哈希表来解决哈希问题。\n强调一下 什么时候使用哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n再来看一下使用数组和set来做哈希法的局限。（c++）\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 暴力 func twoSum(nums []int, target int) []int { for k1, _ := range nums { for k2 := k1 + 1; k2 \u003c len(nums); k2 ++ { if target == nums[k1] + nums[k2] { return []int{k1, k2} } } } return []int{} } // map func twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if pre, ok := m[target - v]; ok { return []int{pre, i} } else { m[v] = i } } return []int{} } 3.5 四数相加II (经典题目) 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！\n如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。\n思路 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 最后返回统计值 count 就可以了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := make(map[int]int) // k: a+b v: a+b数值出现的次数 count := 0 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1 + v2] ++ } } for _, v3 := range nums3 { for _, v4 := range nums4 { count += m[-v3-v4] } } return count } 3.6 赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(“a”, “b”) -\u003e false canConstruct(“aa”, “ab”) -\u003e false canConstruct(“aa”, “aab”) -\u003e true\nhttps://leetcode.cn/problems/ransom-note/description/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func canConstruct(ransomNote string, magazine string) bool { if len(ransomNote) \u003e len(magazine) { return false } cnt := [26]int{} for _, v := range magazine { cnt[v - 'a'] ++ } for _, v := range ransomNote { cnt[v - 'a'] -- if cnt[v - 'a'] \u003c 0 { return false } } return true } 3.7 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n要点：去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e res; sort(nums.begin(), nums.end()); // find a+b+c=0 for (int i = 0; i \u003c nums.size(); i ++ ) { if (nums[i] \u003e 0) return res; // 去重a，这里不能是nums[i] == nums[i + 1] if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; int l = i + 1; int r = nums.size() - 1; while (r \u003e l) { if (nums[i] + nums[l] + nums[r] \u003e 0) r -- ; else if (nums[i] + nums[l] + nums[r]) l ++ ; else { res.push_back(vector\u003cint\u003e{nums[i], nums[l], nums[r]}); // 去重b和c放在找到一个三元组之后 while (r \u003e l \u0026\u0026 nums[r] == nums[r - 1]) r -- ; while (r \u003e l \u0026\u0026 nums[l] == nums[l + 1]) l ++ ; // 找到答案时双指针同时收缩 r -- , l ++ ; } } } return res; } 我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\n两数之和 就不能使用双指针法，因为1.两数之和 (opens new window)要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。\n如果1.两数之和 (opens new window)要求返回的是数值的话，就可以使用双指针法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func threeSum(nums []int) [][]int { sort.Ints(nums) res := [][]int{} for i := 0; i \u003c len(nums) - 2; i ++ { n1 := nums[i] if n1 \u003e 0 { return res } if i \u003e 0 \u0026\u0026 n1 == nums[i - 1] { continue } l, r := i + 1, len(nums) - 1 for l \u003c r { n2, n3 := nums[l], nums[r] if n1 + n2 + n3 == 0 { res = append(res, []int{n1, n2, n3}) for l \u003c r \u0026\u0026 nums[l] == n2 { l ++ } for l \u003c r \u0026\u0026 nums[r] == n3 { r -- } } else if n1 + n2 + n3 \u003e 0 { r -- } else { l ++ } } } return res } 3.8 四数之和 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n思路：和三数之和一样使用 双指针 ，基本思路就是在此基础上加一层for循环。\n细节：不能判断了nums[k] \u003e target就返回，因为target是任意值，遇到负数就不好直接跳出了；\n但可以做剪枝， nums[i] \u003e target \u0026\u0026 (nums[i] \u003e= 0 || target \u003e= 0)\n15.三数之和 (opens new window)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。\n四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。\n那么一样的道理，五数之和、六数之和等等都采用这种解法。\n对于15.三数之和 (opens new window)双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。\n之前我们讲过哈希表的经典题目：454.四数相加II (opens new window)，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。\n双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func fourSum(nums []int, target int) [][]int { if len(nums) \u003c 4 { return nil } sort.Ints(nums) var res [][]int for i := 0; i \u003c len(nums) - 3; i ++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] { continue } for j := i + 1; j \u003c len(nums) - 2; j ++ { if j \u003e i + 1 \u0026\u0026 nums[j] == nums[j - 1] { continue } l, r := j + 1, len(nums) - 1 for l \u003c r { sum := nums[i] + nums[j] + nums[l] + nums[r] if sum \u003c target { l ++ } else if sum \u003e target { r -- } else { res = append(res, []int{nums[i], nums[j], nums[l], nums[r]}) // 去重 for l \u003c r \u0026\u0026 nums[l] == nums[l + 1] { l ++ } for l \u003c r \u0026\u0026 nums[r] == nums[r - 1] { r -- } // 找到答案时，l r同时靠近 r -- l ++ } } } } return res } 字符串（完） 4.1 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1： 输入：[“h”,“e”,“l”,“l”,“o”] 输出：[“o”,“l”,“l”,“e”,“h”]\n思路：\n双指针。字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。\n对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。 1 2 3 4 5 6 7 8 func reverseString(s []byte) { l, r := 0, len(s) - 1 for l \u003c r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.2 反转2 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = “abcdefg”, k = 2 输出: “bacdfeg”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func reverseStr(s string, k int) string { bs := []byte(s) for i := 0; i \u003c len(s); i += 2 * k { if i + k \u003c len(bs) { reverse(bs[i: i + k]) } else { reverse(bs[i: len(s)]) } } return string(bs) } func reverse(s []byte) { l, r := 0, len(s) - 1 for l \u003c r { s[l], s[r] = s[r], s[l] l ++ r -- } } 4.3 替换数字 go字符串和C++的区别：\ngo中的string类型是不可修改的，需要转换成[]byte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \"fmt\" func main() { var bs []byte fmt.Scanln(\u0026bs) for i := 0; i \u003c len(bs); i ++ { if bs[i] \u003c= '9' \u0026\u0026 bs[i] \u003e= '0' { insertNum := []byte{'n','u','m','b','e','r'} bs = append(bs[:i], append(insertNum, bs[i+1:]...)...) i = i + len(insertNum) - 1 } } fmt.Printf(string(bs)) } 4.4 翻转字符串里的单词（复杂题目） 给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1： 输入: “the sky is blue” 输出: “blue is sky the”\n示例 2： 输入: \" hello world! \" 输出: “world! hello” 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: “a good example” 输出: “example good a” 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n思路：\n移除多余空格\n整体翻转\n单词翻转\n要求：不适用辅助空间，空间复杂度O(1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func reverseWords(s string) string { b := []byte(s) // 移除前面、中间、后面存在的多余空格 slow := 0 for i := 0; i \u003c len(b); i++ { if b[i] != ' ' { if slow != 0 { b[slow] = ' ' slow++ } for i \u003c len(b) \u0026\u0026 b[i] != ' ' { // 复制逻辑 b[slow] = b[i] slow++ i++ } } } b = b[0:slow] // 翻转整个字符串 reverse(b) // 翻转每个单词 last := 0 for i := 0; i \u003c= len(b); i++ { if i == len(b) || b[i] == ' ' { reverse(b[last:i]) last = i + 1 } } return string(b) } func reverse(b []byte) { left := 0 right := len(b) - 1 for left \u003c right { b[left], b[right] = b[right], b[left] left++ right-- } } 4.5 右旋字符串 字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。\n例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。\n思路：先整体反转，再局部反转。abcdefg =\u003e gf | edcba =\u003e fg | abcde\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \"fmt\" func reverse(s []byte, l, r int) { for l \u003c r { s[l], s[r] = s[r], s[l] l ++ r -- } } func main() { var s string var k int fmt.Scanln(\u0026k) fmt.Scanln(\u0026s) bs := []byte(s) reverse(bs, 0, len(s) - 1) reverse(bs, 0, k - 1) reverse(bs, k, len(s) - 1) fmt.Println(string(bs)) } 4.6 实现strStr() 实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2\n示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1\n说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。\nKMP算法： 解决字符串匹配问题。当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n当前不匹配位置i前面（包括i）所有子串中的最长相等前后缀的长度，即模式串上重新匹配的位置\n前缀：包含首字母，但不包含尾字母的所有子串 后缀：反之\n为什么用前缀表？ 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。 e.g. 文本串：aabaabaaf 模式串：aabaaf，其前缀表为：010120 next数组| prefix数组\n实现：在匹配时，在模式串f处发生冲突，接下来看f前一位的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\nnext数组的不同实现 整体右移，首位添加-1 ： -1 0 1 0 1 2\n实现：在匹配时，在模式串f处发生冲突，看f的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。\n整体减1： -1 0 -1 0 1 -1\n子串 最长相等前后缀长度 a 0 aa 1 (a a) aab 0 aaba 1 (a a) aabaa 2 (aa aa) aabaaf 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 前缀表不减一 or 右移 func getNext(next []int, s string) { j := 0 // j表示 最长相等前后缀长度 next[0] = j for i := 1; i \u003c len(s); i ++ { for j \u003e 0 \u0026\u0026 s[i] != s[j] { j = next[j - 1] } if s[i] == s[j] { j ++ } next[i] = j // next[i]是i（包括i）之前的最长相等前后缀长度 } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := 0 next := make([]int, n) getNext(next, needle) for i := 0; i \u003c len(hayStack); i ++ { for j \u003e 0 \u0026\u0026 hayStack[i] != needle[j] { j = next[j - 1] } if hayStack[i] == needle[j] { j ++ } if j == n { return i - n + 1 } } return -1 } // 减一实现 func getNext(next []int, s string) { j := -1 next[0] = -1 for i := 1; i \u003c len(s); i ++ { for j \u003e= 0 \u0026\u0026 s[i] != s[j + 1] { j = next[j] // 回退前一位 } if s[i] == s[j + 1] { j ++ } next[i] = j } } func strStr(hayStack string, needle string) int { n := len(needle) if n == 0 { return 0 } j := -1 // 模式串的起始位置 next为-1 因此也为-1 next := make([]int, n) getNext(next, needle) for i := 0; i \u003c len(hayStack); i ++ { for j \u003e= 0 \u0026\u0026 hayStack[i] != needle[j + 1] { j = next[j] } if hayStack[i] == needle[j + 1] { j ++ } if j == n - 1 { return i - n + 1 } } return -1 } 4.7 重复子串 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n示例 1:\n输入: “abab” 输出: True 解释: 可由子字符串 “ab” 重复两次构成。 示例 2:\n输入: “aba” 输出: False 示例 3:\n输入: “abcabcabcabc” 输出: True 解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。 思路：\n1.移动匹配 判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。\n1 2 3 4 5 6 7 func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } t := s + s return strings.Contains(t[1:len(t)-1], s) } 2.KMP 最小重复子串：因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\nlen % (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func repeatedSubstringPattern(s string) bool { n := len(s) if len(s) == 0 { return false } j := -1 next := make([]int, len(s)) next[0] = j for i := 1; i \u003c len(s); i ++ { for j \u003e= 0 \u0026\u0026 s[i] != s[j + 1] { j = next[j] } if s[i] == s[j + 1] { j ++ } next[i] = j } // next[n-1]+1 最长相同前后缀的长度 if next[n-1] != -1 \u0026\u0026 n%(n-(next[n-1]+1)) == 0 { return true } return false } 双指针法（完） 1.3 移除元素\n4.1 反转字符串\n4.3 替换数字\n4.4 翻转串里的单词\n2.3 翻转链表\n2.5\n2.6\n2.7\n3.7\n3.8\n栈和队列（完） go栈\n1 2 3 4 5 6 7 8 9 // create stack stack := make([]int, 0) // push stack = append(stack, 10) // pop val := stack[len(stack)-1] stack = stack[:len(stack)-1] // empty len(stack) == 0 go queue\n1 2 3 4 5 6 7 8 9 // create queue := make([]int, 0) // enqueue queue = append(queue, 10) // dequeue val := queue[0] queue = queue[1:] // empty len(queue) == 0 6.1 栈模拟队列 1 queue = 1 输入stack + 1 输出stack\npush：入队 = 入栈 pop：if输出栈空，就将输入栈中数据all导入输出栈，再从输出栈pop；if输出栈不空，就直接pop empty：if输入栈和输出栈都为空了，则模拟的队列为空。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // ------------stack------------- type MyStack []int func (s *MyStack) Push(v int) { *s = append(*s, v) } func (s *MyStack) Pop() int { val := (*s)[len(*s) - 1] *s = (*s)[:len(*s) - 1] return val } func (s *MyStack) Peek() int { return (*s)[len(*s) - 1] } func (s *MyStack) Size() int { return len(*s) } func (s *MyStack) Empty() bool { return s.Size() == 0 } // ------------queue------------- type MyQueue struct { stackIn *MyStack stackOut *MyStack } func Constructor() MyQueue { return MyQueue { stackIn: \u0026MyStack{}, stackOut: \u0026MyStack{}, } } func (this *MyQueue) Push(x int) { this.stackIn.Push(x) } func (this *MyQueue) Pop() int { this.fillStackOut() return this.stackOut.Pop() } func (this *MyQueue) Peek() int { this.fillStackOut() return this.stackOut.Peek() } func (this *MyQueue) Empty() bool { return this.stackIn.Empty() \u0026\u0026 this.stackOut.Empty() } // 填充输出栈 func (this *MyQueue) fillStackOut() { if this.stackOut.Empty() { for !this.stackIn.Empty() { val := this.stackIn.Pop() this.stackOut.Push(val) } } } /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 6.2 队列模拟栈 一个队列就可以模拟栈 （如果非要用两个队列，另一个队列仅起到保存元素的作用）\npush：=入栈 pop：将队头元素重新加入队列尾，再弹出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type MyStack struct { queue []int } func Constructor() MyStack { return MyStack { queue: make([]int, 0), } } func (this *MyStack) Push(x int) { this.queue = append(this.queue, x) } func (this *MyStack) Pop() int { n := len(this.queue) - 1 for n != 0 { val := this.queue[0] this.queue = this.queue[1:] this.queue = append(this.queue, val) n -- } val := this.queue[0] this.queue = this.queue[1:] return val } func (this *MyStack) Top() int { val := this.Pop() this.queue = append(this.queue, val) // pop完要重新添加回去 return val } func (this *MyStack) Empty() bool { return len(this.queue) == 0 } /** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 6.3 括号匹配 在写代码之前要分析好有哪几种不匹配的情况:\n第一种情况，字符串里左方向的括号多余了 ，所以不匹配。\n第二种情况，括号没有多余，但是 括号的类型没有匹配上。\n第三种情况，字符串里右方向的括号多余了，所以不匹配。\n还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // O(n) O(n) func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } stk := make([]rune, 0) for i := 0; i \u003c n; i ++ { if s[i] == '[' { stk = append(stk, ']') } else if s[i] == '(' { stk = append(stk, ')') } else if s[i] == '{' { stk = append(stk, '}') } else if len(stk) == 0 || stk[len(stk) - 1] != rune(s[i]) { // 如果是右括号，如果栈空 或 栈里没有可以匹配的元素 return false } else { stk = stk[:len(stk) - 1] // pop } } // 遍历完了看时候有剩余 return len(stk) == 0 } 6.4 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\n输入：“abbaca” 输出：“ca” 解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。 提示：\n1 \u003c= S.length \u003c= 20000 S 仅由小写英文字母组成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func removeDuplicates(s string) string { stack := make([]rune, 0) for _, val := range s { if len(stack) == 0 || val != stack[len(stack)-1] { stack = append(stack, val) } else { stack = stack[:len(stack)-1] } } var res []rune for len(stack) != 0 { // 将栈中元素放到result字符串汇总 res = append(res, stack[len(stack)-1]) stack = stack[:len(stack)-1] } // 此时字符串需要反转一下 l, r := 0, len(res)-1 for l \u003c r { res[l], res[r] = res[r], res[l] l++ r-- } return string(res) } 这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。\n可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。\n此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。\n游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。\n而且在企业项目开发中，尽量不要使用递归！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）\n6.5 逆波兰式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func evalRPN(tokens []string) int { stack := []int{} for _, token := range tokens { val, err := strconv.Atoi(token) if err == nil { stack = append(stack, val) } else { // is operation c1, c2 := stack[len(stack) - 2], stack[len(stack) - 1] stack = stack[:len(stack) - 2] switch token { case \"+\": stack = append(stack, c1 + c2) case \"-\": stack = append(stack, c1 - c2) case \"*\": stack = append(stack, c1 * c2) case \"/\": stack = append(stack, c1 / c2) } } } return stack[0] } 6.6 滑动窗口最大值 （经典：单调队列） 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值。\n1 \u003c= nums.length \u003c= 10^5 -10^4 \u003c= nums[i] \u003c= 10^4 1 \u003c= k \u003c= nums.length 进阶：你能在线性时间复杂度内解决此题吗？\n用一个队列维护当前窗口，随着窗口移动，队列一进一出，希望队头是最大元素。\n要保证队列内元素单调递减（增） –》 单调队列\n但不需要维护窗口里的所有元素，只需要维护可能成为最大值的元素。如果下一个元素比上一个大，那么上一个出队，保存下一个，直到遇到比上一个小的，上一个元素不动，继续保留小于当前值的最大值。\n设计单调队列的时候，pop，和push操作要保持如下规则：\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // O(n) O(k) // 封装单调队列的方式解题 type MyQueue struct { queue []int } func NewMyQueue() *MyQueue { return \u0026MyQueue{ queue: make([]int, 0), } } func (m *MyQueue) Front() int { return m.queue[0] } func (m *MyQueue) Back() int { return m.queue[len(m.queue)-1] } func (m *MyQueue) Empty() bool { return len(m.queue) == 0 } func (m *MyQueue) Push(val int) { for !m.Empty() \u0026\u0026 val \u003e m.Back() { m.queue = m.queue[:len(m.queue)-1] } m.queue = append(m.queue, val) } func (m *MyQueue) Pop(val int) { if !m.Empty() \u0026\u0026 val == m.Front() { m.queue = m.queue[1:] } } func maxSlidingWindow(nums []int, k int) []int { queue := NewMyQueue() length := len(nums) res := make([]int, 0) // 先将前k个元素放入队列 for i := 0; i \u003c k; i++ { queue.Push(nums[i]) } // 记录前k个元素的最大值 res = append(res, queue.Front()) for i := k; i \u003c length; i++ { // 滑动窗口移除最前面的元素 queue.Pop(nums[i-k]) // 滑动窗口添加最后面的元素 queue.Push(nums[i]) // 记录最大值 res = append(res, queue.Front()) } return res } 6.7 前k个高频元素（经典：优先队列/堆） 统计出现元素的频率 map:[key, value] 对频率排序 priority queue / 取前k个频率的元素 什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。\n那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。\n而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？\n所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 快排 func topKFrequent(nums []int, k int) []int { res := []int{} cnt := make(map[int]int) for _, val := range nums { cnt[val] ++ } for k, _ := range cnt { res = append(res, k) } sort.Slice(res, func(a, b int) bool { return cnt[res[a]] \u003e cnt[res[b]] }) return res[:k] // qian k } // 小顶堆 func topKFrequent(nums []int, k int) []int { map_num:=map[int]int{} //记录每个元素出现的次数 for _,item:=range nums{ map_num[item]++ } h:=\u0026IHeap{} heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num{ heap.Push(h,[2]int{key,value}) if h.Len()\u003ek{ heap.Pop(h) } } res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i\u003ck;i++{ res[k-i-1]=heap.Pop(h).([2]int)[0] } return res } //构建小顶堆 type IHeap [][2]int func (h IHeap) Len()int { return len(h) } func (h IHeap) Less (i,j int) bool { return h[i][1]\u003ch[j][1] } func (h IHeap) Swap(i,j int) { h[i],h[j]=h[j],h[i] } func (h *IHeap) Push(x interface{}){ *h=append(*h,x.([2]int)) } func (h *IHeap) Pop() interface{}{ old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x } Go: 深入理解堆实现及应用-腾讯云开发者社区-腾讯云 (tencent.com)\n堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或小于等于（最小堆）其子节点。Go语言中的堆通过container/heap包实现，该包提供了对数据结构进行堆操作的接口和方法。\n二叉树 满二叉树 完全二叉树 二叉搜索树 平衡二叉搜索树 AVL 二叉树存储：\n链式 顺序：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树主要有两种遍历方式：\n深度优先遍历：先往深走，遇到叶子节点再往回走。 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历：一层一层的去遍历。 层次遍历（迭代法） 之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n二叉树定义\n1 2 3 4 5 6 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} } 1 2 3 4 5 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 7.1 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) (res []int) { var traversal func(node *TreeNode) traversal = func(node *TreeNode) { // 注意入参 if node == nil { // 注意终止条件 return } // 前序遍历 res = append(res, node.Val) traversal(node.Left) traversal(node.Right) // 中序遍历 // ntraversal(node.Left) // res = append(res, node.Val) // traversal(node.Right) // 后序遍历 // traversal(node.Left) // traversal(node.Right) // res = append(res, node.Val) } traversal(root) return } 7.2 二叉树递归 确定递归函数入参和返回值 确定递归退出条件 确定单次递归内容 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n7.3 二叉树迭代 前后序用栈，后序用指针\nstk.Len()\nstk.PushBack(ndoe)\nstk.Back() 返回栈中的最后一个元素，即栈顶元素。\nstk.Remove(stk.Back()) 从栈中移除并返回最后一个元素。这里移除的元素是栈顶元素。\n(*TreeNode) 是类型断言，将移除的元素转换为 *TreeNode 类型。\n统一迭代 单调栈（完） 739.每日温度 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n思路：找到右边第一个比自己大的数\n在遍历过程中用栈记录右边第一个比当前大的元素，O(n). 栈中只存对应元素下标即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 暴力 func dailyTemperatures(t []int) []int { var res []int for i := 0; i \u003c len(t) - 1; i ++ { j := i + 1 for ; j \u003c len(t); j ++ { if t[j] \u003e t[i] { res = append(res, j - i) break // 找到第一个就退出 } } if j == len(t) { // 如果找完了都没有 res = append(res, 0) } } return append(res, 0) // 最后一日肯定是0 } // 单调栈(增) func dailyTemperatures(t []int) []int { res := make([]int, len(t)) stk := []int{0} // 初始化栈顶元素为第一个下标索引0 for i := 1; i \u003c len(t); i ++ { top := stk[len(stk) - 1] // 当前栈顶 if t[top] \u003e= t[i] { stk = append(stk, i) } else { for len(stk) != 0 \u0026\u0026 t[i] \u003e t[top] { res[top] = i - top stk = stl[:len(stk)-1] // pop if len(stk) != 0 { top = stk[len(stk) - 1] // 更新栈顶 } } stk = append(stk, i) } } return res } // 单调栈(递减) func dailyTemperatures(t []int) []int { res: := make([]int, len(t)) stk := []int{} for i, v := range t { // 栈不空且当前遍历元素 v 破坏了栈的单调性 for len(stk) != 0 \u0026\u0026 v \u003e t[stk[len(stk)-1]] { // 大于当前栈顶，就pop，更新 top := stk[len(stk)-1] stk = stk[:len(stk)-1] res[top] = i - top } stk = append(stk, i) } return res } 496.下一个更大元素 I 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n示例 1:\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1]\n没有重复元素，可以用map来做映射，可以根据数值快速找下标，并且可以判断nums2[i]是否在nums1中出现过。\nres数组默认值为-1（找不到）。\n遍历哪个数组呢？要在nums2里找比1里对应位置元素大的，所以遍历nums2\n情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况：此时满足递增栈（栈头到栈底的顺序），所以直接入栈。\n情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于\n情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。\n判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func nextGreaterElement(nums1 []int, nums2 []int) []int { res := make([]int, len(nums1)) for i := range res { res[i] = -1 } mp := map[int]int{} for i, v := range nums1 { mp[v] = i } stack := []int{} stack = append(stack, 0) // nums2下标 for i := 1; i \u003c len(nums2); i ++ { for len(stack) \u003e 0 \u0026\u0026 nums2[i] \u003e nums2[stack[len(stack)-1]] { top := stack[len(stack)-1] if _, ok := mp[nums2[top]]; ok { // 看map里是否存在这个元素 index := mp[nums2[top]] // 根据map找到nums2[top] 在 nums1中的下标 res[index] = nums2[i] } stack = stack[:len(stack)-1] } stack = append(stack, i) // \u003c= } return res } 503.下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n示例 1:\n输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 提示:\n1 \u003c= nums.length \u003c= 10^4 -10^9 \u003c= nums[i] \u003c= 10^9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func nextGreaterElements(nums []int) []int { n := len(nums) res := make([]int, n) for i := range nums { res[i] = -1 } // 单调递减，存储数组下标 stk := make([]int, 0) for i := 0; i \u003c n * 2; i ++ { for len(stk) \u003e 0 \u0026\u0026 nums[i % n] \u003e nums[stk[len(stk)-1]] { index := stk[len(stk)-1] stk = stk[:len(stk)-1] res[index] = nums[i % n] } stk = append(stk, i % n) } return res } 42. 接雨水（经典常问） 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 暴力双指针 按列计算：宽度一定是1，再求每一列的雨水高度。每一列的雨水有多高取决于两侧柱子中最短的一个。\n注意第一个和最后一个柱子不接雨水。 在for中求左右两边最高的柱子。 最后计算该列的雨水高度: 当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func trap(height []int) (sum int) { n := len(height) for i, h := range height { if i == 0 || i == n - 1 { continue } ml, mr := h, h for r := i + 1; r \u003c n; r ++ { if height[r] \u003e mr { mr = height[r] } } for l := i - 1; l \u003e= 0; l -- { if height[l] \u003e ml { ml = height[l] } } if min(ml, mr) - h \u003e 0 { sum += min(ml, mr) - h } } return } // 时间复杂度为O(n^2)，空间复杂度为O(1) 双指针优化 为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。\n当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。\n即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);\n从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);\n单调栈 单调栈就是保持栈内元素有序。我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。\n【单调栈是按行计算】\n从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。\n遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func trap(height []int) (sum int) { if len(height) \u003c= 2 { return 0 } stack := []int{} stack = append(stack, 0) // 第一个柱子 for i := range height { for len(stack) \u003e 0 \u0026\u0026 height[i] \u003e height[stack[len(stack)-1]] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] if len(stack) \u003e 0 { h := min(height[i], height[stack[len(stack)-1]]) - height[mid] w := i - stack[len(stack)-1] - 1 sum += h * w } } stack = append(stack, i) } return } 84. 柱状图中的最大矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n1 2 3 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 【与接雨水的区别】要记录每个柱子左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 暴力双指针 func largestRectangleArea(height []int) int { n := len(height) minl := make([]int, n) minr := make([]int, n) minl[0] = -1 for i := 1; i \u003c n; i ++ { t := i - 1 for t \u003e= 0 \u0026\u0026 height[t] \u003e= height[i] { t, minl[t] = minl[t], t } } minr[n - 1] = n for i := n - 2; i \u003e= 0; i -- { t := i + 1 for t \u003c n \u0026\u0026 height[t] \u003e= height[i] { t, minr[t] = minr[t], t } } sum := 0 for i := 0; i \u003c n; i ++ { s := height[i] * (minr[i] - minl[i] - 1) sum = max(sum, s) } return sum } 单调栈 42. 接雨水 (opens new window)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度\n注：在height数组头尾加一个0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func largestRectangleArea(heights []int) (res int) { stack := make([]int, 0) heights = append([]int{0}, heights...) heights = append(heights, 0) stack = append(stack, 0) for i := 1; i \u003c len(heights); i ++ { for heights[stack[len(stack)-1]] \u003e heights[i] { mid := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] sum := heights[mid] * (i - left - 1) if sum \u003e res { res = sum } } stack = append(stack, i) } return res } 贪心 DP 基础题 背包：01、完全、多重 打家劫舍系列 股票问题 子序列问题 动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。\n问题分解：\n确定dp数组以及下标的含义 确定状态转移方程（递推公式） dp数组如何初始化 确定遍历顺序 举例推导dp数组 如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。\n如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。\n如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。\n509. 斐波那契数（入门） 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u003e 1 给你n ，请计算 F(n) 。\n示例 1：\n输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 提示：\n0 \u003c= n \u003c= 30 思路：\n确定dp数组及下表的意义：dp[i] 定义为第i个数的斐波那契数值 递推公式：题目给了 dp[i] = dp[i - 1] + dp[i - 2] 初始化：题目给了 dp[0] = 0, dp[1] = 1 遍历顺序：从公式看出，dp[i] 依赖 dp[i - 1]和dp[i - 2]，所以是从前到后遍历 举例推导dp数组：N = 10时，dp数组应该是：0 1 1 2 3 5 8 13 21 34 55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 递归 func fib(n int) int { if n \u003c 2 { return n } return fib(n - 1) + fib(n - 2) } // dp func fib(n int) int { if n \u003c 2 { return n } dp0, dp1, dp := 0, 1, 0 for i := 1; i \u003c n; i ++ { dp = dp0 + dp1 dp0, dp1 = dp1, dp } return dp } 70. 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。\n示例 1：\n输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：\n输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 思路：\ndp[i]: 爬到第i层时，有dp[i]种方法 dp[i] = dp[i - 1] + dp[i - 2] 不考虑dp[0], dp[1] = 1, dp[2] = 2, 从3开始递推 顺序：从前到后 举例：n = 5时， dp数组：1 2 3 5 8 1 2 3 4 5 6 7 8 9 10 11 func climbStairs(n int) int { if n == 1 { return n } dp := make([]int, n + 1) dp[1], dp[2] = 1, 2 for i := 3; i \u003c= n; i ++ { dp[i] = dp[i - 1] + dp[i - 2] } return dp[n] } 746. 最小花费爬楼梯 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n思路：\ndp[i] ： 到达第i个台阶所花费的最少费用\ndp[i] = dp[i - 1] + cost[i - 1], dp[i - 1] = dp[i - 2] + cost[i - 2].\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n初始化：根据题目意思，dp[0] = dp[1] = 0 (因为从0或1开题跳都可以，意思就是不计费)\n遍历顺序：从前到后\n举例推导：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n0 0 1 2 2 3 3 4 4 5 6\n1 2 3 4 5 6 7 8 func minCostClimbingStairs(cost []int) int { f := make([]int, len(cost) + 1) f[0], f[1] = 0, 0 for i := 2; i \u003c= len(cost); i ++ { f[i] = min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2]) } return f[len(cost)] } 62. 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\ndp[i ] [j] : 表示从（0,0）出发到（i,j)的不同路径数 公式：dp[ i ] [ j ] = dp[i] [j - 1] + dp[i - 1] [j] （从左边和上边来的） 初始化：dp[i] [0] = 1, dp[0] [j] = 1 遍历顺序：从左到右一层层遍历即可 举例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for j := 0; j \u003c n; j ++ { dp[0][j] = 1 } for i := 1; i \u003c m; i ++ { for j := 1; j \u003c n; j ++ { dp[i][j] = dp[i - 1][j] + dp[i][j - 1] } } return dp[m - 1][n - 1] } // 优化：二维简化到一维，滚动数组 T: O(mn), S: O(mn) -\u003e O(n) // 数论做法：对于m行n列的矩形，走到终点都需要m+n-2步。在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。C_(m+m-2)^(m-1) //需要在计算分子的时候，不断除以分母 func uniquePaths(m int, n int) int { numerator := 1 denominator := m - 1 // fenmu cnt := m - 1 t := m + n - 2 for cnt \u003e 0 { numerator *= t t -- for denominator != 0 \u0026\u0026 numerator % denominator == 0 { numerator /= denominator denominator -- } cnt -- } return numerator } // O(m) O(1) 求组合的时候，要防止两个int相乘溢出！ 所以不能把算式的分子都算出来，分母都算出来再做除法。\n数位DP 数的大小和复杂度没什么关系，数位变化有关。\nf[i, mask, isLimit, isNum]\n返回从i开始填数字，i前面的数字的集合是mask，共构造出的特殊数的数量；is_limit表示前面填的数是否都是n对应位置上的，if true，则当前位之多为s[i], 否则至多为’9’; is_num表示前面是否填了数字（是否跳过），if true则当前可以从0开始，false可以跳过或从1开始。\n1 2 3 func f(i int, mask int, is_limit bool, is_num bool) int { if i == len(s) } 集合可以用二进制表示，二进制从低到高第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 对应的二进制数为 1101 (2)\n设集合对应的二进制数为 x。本题需要用到两个位运算操作：\n判断元素 d 是否在集合中：x » d \u0026 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 « d)。\n","wordCount":"23941","inLanguage":"en","datePublished":"2024-08-15T15:28:02+08:00","dateModified":"2024-08-15T15:28:02+08:00","author":{"@type":"Person","name":"erica423"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erica423.github.io/posts/algorithm/"},"publisher":{"@type":"Organization","name":"Erica-Blog","logo":{"@type":"ImageObject","url":"https://erica423.github.io/images/dls_icon.png"}}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erica423.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://erica423.github.io/images/dls_icon.png alt aria-label=logo height=25>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://erica423.github.io/archives/ title=🎮动态><span>🎮动态</span></a></li><li><a href=https://erica423.github.io/tags/ title=🎲标签><span>🎲标签</span></a></li><li><a href=https://erica423.github.io/search/ title="🎯搜索 (Alt + /)" accesskey=/><span>🎯搜索</span></a></li><li><a href=https://github.com/Erica423/Erica423.github.io/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://erica423.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://erica423.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">算法</h1><div class=post-meta><span title='2024-08-15 15:28:02 +0800 +0800'>August 15, 2024</span>&nbsp;·&nbsp;erica423&nbsp;|&nbsp;<a href=https://github.com/Erica423/Erica423.github.io rel="noopener noreferrer" target=_blank>主页</a><div class=meta-item>&nbsp·&nbsp
	      <span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-数组存储>1.1 数组存储</a></li><li><a href=#12-二分查找>1.2 二分查找</a><ul><li><a href=#写法1-l-r>写法1 [l, r]</a></li><li><a href=#写法2-l-r>写法2 [l, r)</a></li></ul></li><li><a href=#13-原地移除元素>1.3 原地移除元素</a><ul><li><a href=#暴力做法>暴力做法</a></li><li><a href=#快慢指针做法>快慢指针做法</a></li></ul></li><li><a href=#14-有序数组的平方>1.4 有序数组的平方</a><ul><li></li></ul></li><li><a href=#15-长度最小的数组>1.5 长度最小的数组</a><ul><li></li></ul></li><li><a href=#16-螺旋矩阵ii-高频>1.6 螺旋矩阵II (高频)</a></li></ul><ul><li><a href=#21-移除链表元素>2.1 移除链表元素</a></li><li><a href=#22-设计链表>2.2 设计链表</a></li><li><a href=#23-反转链表高频>2.3 反转链表(高频)</a></li><li><a href=#24-两两交换相邻节点>2.4 两两交换相邻节点</a></li><li><a href=#25-删除链表的倒数第n个节点>2.5 删除链表的倒数第n个节点</a></li><li><a href=#26-链表相交>2.6 链表相交</a></li><li><a href=#27-环形链表ii>2.7 环形链表II</a></li></ul><ul><li><a href=#31-有效的字母异位词>3.1 有效的字母异位词</a></li><li><a href=#32-两个数组的交集>3.2 两个数组的交集</a></li><li><a href=#33-快乐树>3.3 快乐树</a></li><li><a href=#34-两数之和>3.4 两数之和</a></li><li><a href=#35-四数相加ii-经典题目>3.5 四数相加II (经典题目)</a></li><li><a href=#36-赎金信>3.6 赎金信</a></li><li><a href=#37-三数之和>3.7 三数之和</a></li><li><a href=#38-四数之和>3.8 四数之和</a></li></ul><ul><li><a href=#41-反转字符串>4.1 反转字符串</a></li><li><a href=#42-反转2>4.2 反转2</a></li><li><a href=#43-替换数字>4.3 替换数字</a></li><li><a href=#44-翻转字符串里的单词复杂题目>4.4 翻转字符串里的单词（复杂题目）</a></li><li><a href=#45-右旋字符串>4.5 右旋字符串</a></li><li><a href=#46-实现strstr>4.6 实现strStr()</a><ul><li><a href=#kmp算法>KMP算法：</a></li><li><a href=#next数组的不同实现>next数组的不同实现</a></li></ul></li><li><a href=#47-重复子串>4.7 重复子串</a><ul><li><a href=#1移动匹配>1.移动匹配</a></li><li><a href=#2kmp>2.KMP</a></li></ul></li></ul><ul><li><a href=#61-栈模拟队列>6.1 栈模拟队列</a></li><li><a href=#62-队列模拟栈>6.2 队列模拟栈</a></li><li><a href=#63-括号匹配>6.3 括号匹配</a></li><li><a href=#64-删除字符串中的所有相邻重复项>6.4 删除字符串中的所有相邻重复项</a></li><li><a href=#65-逆波兰式求值>6.5 逆波兰式求值</a></li><li><a href=#66-滑动窗口最大值-经典单调队列>6.6 滑动窗口最大值 （经典：单调队列）</a></li><li><a href=#67-前k个高频元素经典优先队列堆>6.7 前k个高频元素（经典：优先队列/堆）</a></li></ul><ul><li><a href=#71-递归遍历>7.1 递归遍历</a></li><li><a href=#72-二叉树递归>7.2 二叉树递归</a></li><li><a href=#73-二叉树迭代>7.3 二叉树迭代</a><ul><li></li></ul></li></ul><ul><li><a href=#739每日温度>739.每日温度</a></li><li><a href=#496下一个更大元素-i>496.下一个更大元素 I</a></li><li><a href=#503下一个更大元素-ii>503.下一个更大元素 II</a></li><li><a href=#42-接雨水经典常问>42. 接雨水（经典常问）</a><ul><li></li></ul></li><li><a href=#84-柱状图中的最大矩形>84. 柱状图中的最大矩形</a><ul><li></li></ul></li></ul><ul><li><a href=#509-斐波那契数入门>509. 斐波那契数（入门）</a></li><li><a href=#70-爬楼梯>70. 爬楼梯</a></li><li><a href=#746-最小花费爬楼梯>746. 最小花费爬楼梯</a></li><li><a href=#62-不同路径>62. 不同路径</a></li><li><a href=#数位dp>数位DP</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-数组>1 数组<a hidden class=anchor aria-hidden=true href=#1-数组>#</a></h1><hr><h2 id=11-数组存储>1.1 数组存储<a hidden class=anchor aria-hidden=true href=#11-数组存储>#</a></h2><ul><li>不论一维数组还是二维数组，其存储地址空间都是线性连续的。</li><li>go中 int 类型长度和操作系统的位数有关：64位的默认 int 位数为 8，32位的默认 int 位数为 4。</li></ul><blockquote><p>Go int类型数据长度：</p><table><thead><tr><th style=text-align:center>列1</th><th style=text-align:right>列2</th></tr></thead><tbody><tr><td style=text-align:center>文本居中</td><td style=text-align:right>文本居右</td></tr></tbody></table></blockquote><hr><h2 id=12-二分查找>1.2 二分查找<a hidden class=anchor aria-hidden=true href=#12-二分查找>#</a></h2><ul><li><p>前提：有序数组，无重复元素</p></li><li><p>重点：区间的定义（<strong>区间就是不变量！</strong>)</p><h3 id=写法1-l-r>写法1 [l, r]<a hidden class=anchor aria-hidden=true href=#写法1-l-r>#</a></h3></li><li><p>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= ;</p></li><li><p>if (nums[middle] > target) right = middle - 1，因为当前这个nums[middle]
一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1. left = mid + 1.</p><h3 id=写法2-l-r>写法2 [l, r)<a hidden class=anchor aria-hidden=true href=#写法2-l-r>#</a></h3></li><li><p>while (left &lt; right)</p></li><li><p>right = mid, left = mid + 1</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// [l, r]版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>search</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=o>&lt;=</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mid</span> <span class=o>:=</span> <span class=nx>l</span> <span class=o>+</span> <span class=p>(</span><span class=nx>r</span> <span class=o>-</span> <span class=nx>l</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>r</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>l</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>mid</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [l, r) 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>search</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=nx>mid</span> <span class=o>:=</span> <span class=nx>l</span> <span class=o>+</span> <span class=p>(</span><span class=nx>r</span> <span class=o>-</span> <span class=nx>l</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>       <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nx>r</span> <span class=p>=</span> <span class=nx>mid</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nx>l</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=nx>mid</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>golang二分查找的库函数：<code>index := sort.Search(n int, f func(i int) bool) int)</code></p><ul><li>该函数使用<strong>二分查找</strong>的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True。
如果无法找到该index值，则该方法为返回n.</li><li>常用场景
该方法一般用于从一个已经排序的数组中找到某个值所对应的索引。
或者从字符串数组中，找到满足某个条件的最小索引值，比如etcd中的键值范围查询就用到了该方法。</li></ul><hr><h2 id=13-原地移除元素>1.3 原地移除元素<a hidden class=anchor aria-hidden=true href=#13-原地移除元素>#</a></h2><ul><li><p>要求：删除数组中值等于val的元素，不可以使用额外的空间。</p></li><li><p>重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能<strong>覆盖</strong>。</p></li></ul><h3 id=暴力做法>暴力做法<a hidden class=anchor aria-hidden=true href=#暴力做法>#</a></h3><ul><li>两层for循环，第一个for查找值等于val的元素，第二层for依次将后续元素提前一位覆盖掉前一位元素。
复杂度：O(n^2) O(1)</li></ul><h3 id=快慢指针做法>快慢指针做法<a hidden class=anchor aria-hidden=true href=#快慢指针做法>#</a></h3><ul><li>实现一个快指针一个慢指针用一个for循环解决。复杂度：O(n) O(1)</li><li>定义：<ul><li>快指针：寻找组成新数组的元素（不含=val的元素）；</li><li>慢指针：指向更新 新数组下标</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeElement</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>slow</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>fast</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>fast</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=k>if</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>fast</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nums</span><span class=p>[</span><span class=nx>slow</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>fast</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>slow</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>       <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>nums</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[:</span><span class=nx>slow</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>nums</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 双向双指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>removeElement</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=o>&lt;=</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>l</span> <span class=o>&lt;=</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>l</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>l</span> <span class=o>&lt;=</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 找到左侧的val和右侧的非val后开始覆盖，覆盖后继续寻找
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>l</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl>            <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>l</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=14-有序数组的平方>1.4 有序数组的平方<a hidden class=anchor aria-hidden=true href=#14-有序数组的平方>#</a></h2><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><ul><li>输入：nums = [-4,-1,0,3,10]</li><li>输出：[0,1,9,16,100]</li><li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p>示例 2：</p><ul><li>输入：nums = [-7,-3,2,3,11]</li><li>输出：[4,9,9,49,121]</li></ul></blockquote><h4 id=暴力思路>暴力思路：<a hidden class=anchor aria-hidden=true href=#暴力思路>#</a></h4><p>每个数平方后排序，时间复杂度O(n + nlogn)</p><h4 id=双指针法>双指针法：<a hidden class=anchor aria-hidden=true href=#双指针法>#</a></h4><p>i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让<code>k</code>指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] >= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sortedSquares</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>j</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>lm</span><span class=p>,</span> <span class=nx>rm</span> <span class=o>:=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>*</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=o>*</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>lm</span> <span class=p>&gt;</span> <span class=nx>rm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>lm</span>
</span></span><span class=line><span class=cl>            <span class=nx>i</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rm</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>k</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=15-长度最小的数组>1.5 长度最小的数组<a hidden class=anchor aria-hidden=true href=#15-长度最小的数组>#</a></h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;= target &lt;= 10^9</li><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^5</li></ul></blockquote><h4 id=暴力>暴力：<a hidden class=anchor aria-hidden=true href=#暴力>#</a></h4><p>两个for循环，时间复杂度 O(n^2)</p><h4 id=滑动窗口>滑动窗口<a hidden class=anchor aria-hidden=true href=#滑动窗口>#</a></h4><p>只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的<strong>终止位置</strong>。 O(n)</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li></ul><blockquote><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p></blockquote><ul><li>如何移动窗口的起始位置？</li></ul><blockquote><p>如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</p></blockquote><ul><li>如何移动窗口的结束位置？</li></ul><blockquote><p>窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>while</span> <span class=p>(</span><span class=nx>sum</span> <span class=o>&gt;=</span> <span class=nx>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>subLen</span> <span class=p>=</span> <span class=p>(</span><span class=nx>j</span> <span class=o>-</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=p>=</span> <span class=nb>min</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>subLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>-=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span> <span class=o>++</span> <span class=p>]</span><span class=err>；</span>	<span class=c1>// 滑动窗口的精髓，不断变更起始位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>minSubArrayLen</span><span class=p>(</span><span class=nx>target</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span><span class=p>,</span> <span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>sum</span> <span class=o>&gt;=</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>subLen</span> <span class=o>:=</span> <span class=nx>j</span> <span class=o>-</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>min</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>subLen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>sum</span> <span class=o>-=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>i</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>res</span> <span class=o>==</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nb>min</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>x</span> <span class=p>&gt;</span> <span class=nx>y</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=16-螺旋矩阵ii-高频>1.6 螺旋矩阵II (高频)<a hidden class=anchor aria-hidden=true href=#16-螺旋矩阵ii-高频>#</a></h2><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p></blockquote><p><strong>求解本题依然是要坚持循环不变量原则。</strong></p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><figure><img loading=lazy src=/algorithm.assets/image-20240426165417555.png alt=image-20240426165417555></figure><p>可以看出拐角处是让给下一条边画的，<strong>也就是左闭右开</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>res</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>startx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>starty</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 定义每循环一个圈的起始位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>loop</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// 每个圈循环几次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>  <span class=c1>// 矩阵的中心位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=c1>// 用来给矩阵中每一个空格赋值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>offset</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=c1>// 需要控制每一条边遍历的长度，每次循环右边界收缩一位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>loop</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>startx</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>j</span> <span class=o>=</span> <span class=n>starty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 上行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>-</span> <span class=n>offset</span><span class=p>;</span> <span class=n>j</span> <span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 右列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>-</span> <span class=n>offset</span><span class=p>;</span> <span class=n>i</span> <span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(;</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=n>starty</span><span class=p>;</span> <span class=n>j</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 左列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>startx</span><span class=p>;</span> <span class=n>i</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 第二圈开始的时候，起始位置要各自加1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>startx</span> <span class=o>++</span> <span class=p>,</span> <span class=n>startty</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// offset 控制每一圈里每一条边遍历的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>offset</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=p>[</span><span class=n>mid</span><span class=p>][</span><span class=n>mid</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span> <span class=o>:=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>generateMatrix</span><span class=p>(</span><span class=nx>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>generateMatrix</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>startx</span><span class=p>,</span> <span class=nx>starty</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>loop</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>n</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>center</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>n</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=nx>count</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>offset</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>loop</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>startx</span><span class=p>,</span> <span class=nx>starty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>//行数不变 列数在变
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>j</span> <span class=p>=</span> <span class=nx>starty</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=nx>offset</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>res</span><span class=p>[</span><span class=nx>startx</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl>			<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>//列数不变是j 行数变
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=p>=</span> <span class=nx>startx</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=o>-</span><span class=nx>offset</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl>			<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>//行数不变 i 列数变 j--
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>;</span> <span class=nx>j</span> <span class=p>&gt;</span> <span class=nx>starty</span><span class=p>;</span> <span class=nx>j</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl>			<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>//列不变 行变
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>;</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=nx>startx</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl>			<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>startx</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=nx>starty</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=nx>offset</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=nx>loop</span><span class=o>--</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>n</span><span class=o>%</span><span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span><span class=p>[</span><span class=nx>center</span><span class=p>][</span><span class=nx>center</span><span class=p>]</span> <span class=p>=</span> <span class=nx>n</span> <span class=o>*</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>generateMatrix</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>top</span><span class=p>,</span> <span class=nx>bottom</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>left</span><span class=p>,</span> <span class=nx>right</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>n</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>num</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>tar</span> <span class=o>:=</span> <span class=nx>n</span> <span class=o>*</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=nx>matrix</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>num</span> <span class=o>&lt;=</span> <span class=nx>tar</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>left</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>right</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>matrix</span><span class=p>[</span><span class=nx>top</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>            <span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>top</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>top</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>bottom</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>right</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>            <span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>right</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>right</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=nx>left</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>matrix</span><span class=p>[</span><span class=nx>bottom</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>            <span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>bottom</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>bottom</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=nx>top</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>left</span><span class=p>]</span> <span class=p>=</span> <span class=nx>num</span>
</span></span><span class=line><span class=cl>            <span class=nx>num</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>left</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>matrix</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</li><li>空间复杂度 O(1)</li></ul><hr><h1 id=链表>链表<a hidden class=anchor aria-hidden=true href=#链表>#</a></h1><p><a href=https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B>https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B</a></p><ul><li>链表的类型</li></ul><p>单链表：</p><figure><img loading=lazy src=algorithm.assets/image-20240428212744936.png alt=image-20240428212744936></figure><p>双链表：</p><figure><img loading=lazy src=algorithm.assets/image-20240428212755537.png alt=image-20240428212755537></figure><p>循环链表：解决<strong>约瑟夫环</strong>问题</p><figure><img loading=lazy src=algorithm.assets/image-20240428213108687.png alt=image-20240428213108687></figure><ul><li>存储方式</li></ul><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><ul><li>链表的定义</li></ul><p>C/C++ 定义链表节点</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 单链表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>next</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 节点的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ListNode</span><span class=o>*</span> <span class=n>head</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ListNode</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>go 定义链表节点</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ListNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Val</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Next</span> <span class=o>*</span><span class=nx>ListNode</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>head</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>ListNode</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=21-移除链表元素>2.1 移除链表元素<a hidden class=anchor aria-hidden=true href=#21-移除链表元素>#</a></h2><blockquote><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head = [], val = 1 输出：[]</p><p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p></blockquote><p>如果删除的是头结点该怎么办呢？</p><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=cm> * type ListNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Next *ListNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeElements</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>head</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Val</span> <span class=o>==</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>head</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这样移除了一个头结点，在单链表中移除头结点 和 移除其他节点的操作方式是不一样, 那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p><strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=cm> * type ListNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Next *ListNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeElements</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummyHead</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>ListNode</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummyHead</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>dummyHead</span>  <span class=c1>// 当前的头指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>cur</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Val</span> <span class=o>==</span> <span class=nx>val</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dummyHead</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=22-设计链表>2.2 设计链表<a hidden class=anchor aria-hidden=true href=#22-设计链表>#</a></h2><blockquote><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul></blockquote><p>设计五个接口：</p><ul><li>获取链表第index个节点的数值；</li><li>在链表的最前边插入一个节点</li><li>在最后插入一个节点</li><li>在第index个节点前面插入一个节点</li><li>删除第index个节点</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyLinkedList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>LinkedNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>val</span><span class=p>),</span> <span class=n>next</span><span class=p>(</span><span class=k>nullptr</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化链表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MyLinkedList</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_dummyHead</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedNode</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>index</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>addAtHead</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedNode</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>newNode</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_dummyHead</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_size</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>addAtTail</span><span class=p>(</span><span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedNode</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_size</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>addAtIndex</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&gt;</span> <span class=n>_size</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedNode</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>index</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>newNode</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_size</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>deleteAtIndex</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>_size</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>index</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_size</span> <span class=o>--</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 打印
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>printLinkedList</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LInkedNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>_dummyHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkedNode</span><span class=o>*</span> <span class=n>_dummyHead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SingleNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Val</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Next</span> <span class=o>*</span><span class=nx>SingleNode</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyLinkedList</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummyHead</span> <span class=o>*</span><span class=nx>SingleNode</span>  <span class=c1>// 虚拟头结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Size</span> <span class=kt>int</span>  <span class=c1>// 链表大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>list</span> <span class=o>:=</span> <span class=nf>Constructor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>list</span><span class=p>.</span><span class=nf>AddAtHead</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>list</span><span class=p>.</span><span class=nf>AddAtTail</span><span class=p>(</span><span class=mi>242</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>list</span><span class=p>.</span><span class=nf>AddAtTail</span><span class=p>(</span><span class=mi>777</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>list</span><span class=p>.</span><span class=nf>AddAtIndex</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>99999</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>list</span><span class=p>.</span><span class=nf>printLinkedList</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Initialize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Constuctor</span><span class=p>()</span> <span class=nx>MyLinkedList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>SingleNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span><span class=mi>999</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kc>nil</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyLinkedList</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dummyHead</span><span class=p>:</span> <span class=nx>newNode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Size</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>m</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>index</span> <span class=o>&gt;=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtHead</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>SingleNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>newNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=o>++</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtTail</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>SingleNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>newNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtIndex</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>index</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>SingleNode</span><span class=p>{</span><span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>newNode</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>newNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>DeleteAtIndex</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>index</span> <span class=o>&gt;=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>Size</span> <span class=o>--</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>printLinkedList</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummyHead</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>循环双链表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Node</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Val</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Next</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl>    <span class=nx>Pre</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyLinkedList</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span> <span class=o>*</span><span class=nx>Node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//仅保存哑节点，pre-&gt; rear, next-&gt; head
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/** Initialize your data structure here. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=nx>MyLinkedList</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rear</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Val</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Pre</span><span class=p>:</span> <span class=kc>nil</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=nx>Next</span><span class=p>:</span> <span class=kc>nil</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rear</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>rear</span>
</span></span><span class=line><span class=cl>    <span class=nx>rear</span><span class=p>.</span><span class=nx>Pre</span> <span class=p>=</span> <span class=nx>rear</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyLinkedList</span><span class=p>{</span><span class=nx>rear</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>head</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>head</span> <span class=o>!=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummy</span> <span class=o>&amp;&amp;</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>index</span> <span class=o>--</span> 
</span></span><span class=line><span class=cl>        <span class=nx>head</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=mi>0</span> <span class=o>!=</span> <span class=nx>index</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtHead</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dummy</span>
</span></span><span class=line><span class=cl>    <span class=nx>node</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=nx>Pre</span><span class=p>:</span> <span class=nx>dummy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Next</span><span class=p>:</span> <span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Pre</span> <span class=p>=</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Append a node of value val to the last element of the linked list. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtTail</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>dummy</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span>
</span></span><span class=line><span class=cl>	<span class=nx>rear</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>//rear.Next = dummy(哑节点)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Next</span><span class=p>:</span> <span class=nx>dummy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>//rear.Pre = ori_rear
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Pre</span><span class=p>:</span> <span class=nx>dummy</span><span class=p>.</span><span class=nx>Pre</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//ori_rear.Next = rear
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>dummy</span><span class=p>.</span><span class=nx>Pre</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>rear</span>
</span></span><span class=line><span class=cl>	<span class=c1>//update dummy
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>dummy</span><span class=p>.</span><span class=nx>Pre</span> <span class=p>=</span> <span class=nx>rear</span>
</span></span><span class=line><span class=cl>	<span class=c1>//以上两步不能反
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>AddAtIndex</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>head</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>	<span class=c1>//head = MyLinkedList[index]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>head</span> <span class=o>!=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span> <span class=o>&amp;&amp;</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>head</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>		<span class=nx>index</span><span class=o>--</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>node</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Node</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Val</span><span class=p>:</span> <span class=nx>val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>//node.Next = MyLinkedList[index]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Next</span><span class=p>:</span> <span class=nx>head</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=c1>//node.Pre = MyLinkedList[index-1]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Pre</span><span class=p>:</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Pre</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>//MyLinkedList[index-1].Next = node
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>head</span><span class=p>.</span><span class=nx>Pre</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl>	<span class=c1>//MyLinkedList[index].Pre = node
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>head</span><span class=p>.</span><span class=nx>Pre</span> <span class=p>=</span> <span class=nx>node</span>
</span></span><span class=line><span class=cl>	<span class=c1>//以上两步不能反
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Delete the index-th node in the linked list, if the index is valid. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyLinkedList</span><span class=p>)</span> <span class=nf>DeleteAtIndex</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//链表为空
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span> <span class=o>==</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>head</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>	<span class=c1>//head = MyLinkedList[index]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>dummy</span> <span class=o>&amp;&amp;</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>head</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>		<span class=nx>index</span><span class=o>--</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>//验证index有效
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//MyLinkedList[index].Pre = index[index-2]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Pre</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Pre</span>
</span></span><span class=line><span class=cl>		<span class=c1>//MyLinedList[index-2].Next = index[index]
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>head</span><span class=p>.</span><span class=nx>Pre</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>		<span class=c1>//以上两步顺序无所谓
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=23-反转链表高频>2.3 反转链表(高频)<a hidden class=anchor aria-hidden=true href=#23-反转链表高频>#</a></h2><p>思路：</p><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p><p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。</p><blockquote><p>1 双指针法 O(n) O(1)</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=o>*</span> <span class=n>reverseList</span><span class=p>(</span><span class=n>ListNode</span><span class=o>*</span> <span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>pre</span> <span class=o>=</span> <span class=n>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>cur</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>  <span class=c1>// 保存cur的下一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>pre</span><span class=p>;</span> <span class=c1>// 翻转操作
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>pre</span> <span class=o>=</span> <span class=n>cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>2 递归法：不同的地方在初始化 O(n) O(n)</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=o>*</span> <span class=n>reverse</span><span class=p>(</span><span class=n>ListNode</span><span class=o>*</span> <span class=n>pre</span><span class=p>,</span> <span class=n>ListNode</span><span class=o>*</span> <span class=n>cur</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>cur</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span><span class=o>*</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>reverse</span><span class=p>(</span><span class=n>cur</span><span class=p>,</span> <span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span><span class=o>*</span> <span class=nf>reverseList</span><span class=p>(</span><span class=n>ListNode</span><span class=o>*</span> <span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>reverse</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>head</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Go版本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 双指针写法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>reverseList</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>pre</span> <span class=o>*</span><span class=nx>ListNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>cur</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>tmp</span> <span class=o>:=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>pre</span>
</span></span><span class=line><span class=cl>        <span class=nx>pre</span> <span class=p>=</span> <span class=nx>cur</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>tmp</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pre</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 递归
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>reverseList</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>help</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>head</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>help</span><span class=p>(</span><span class=nx>pre</span><span class=p>,</span> <span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>head</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>pre</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>tmp</span> <span class=o>:=</span> <span class=nx>head</span><span class=p>,</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>pre</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>help</span><span class=p>(</span><span class=nx>head</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=24-两两交换相邻节点>2.4 两两交换相邻节点<a hidden class=anchor aria-hidden=true href=#24-两两交换相邻节点>#</a></h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>用虚拟头结点，之后模拟就可以了。O(n) O(1)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>swapPairs</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>ListNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Next</span><span class=p>:</span> <span class=nx>head</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//head=list[i]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//cur=list[i-1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>dummy</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>head</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>  <span class=c1>// cur-&gt;2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>tmp</span> <span class=o>:=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>  <span class=c1>// tmp-&gt;3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>head</span>  <span class=c1>// 3-&gt;1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>tmp</span>  <span class=c1>// 1-&gt;3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//cur=list[(i+2)-1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>cur</span> <span class=p>=</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>        <span class=c1>//head=list[(i+2)]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>head</span> <span class=p>=</span> <span class=nx>tmp</span>  <span class=c1>// head-&gt;3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=25-删除链表的倒数第n个节点>2.5 删除链表的倒数第n个节点<a hidden class=anchor aria-hidden=true href=#25-删除链表的倒数第n个节点>#</a></h2><blockquote><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p></blockquote><p>思路：<strong>双指针</strong>，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><ul><li>定义fast和slow指针，初始值为虚拟头结点</li></ul><p><img loading=lazy src=algorithm.assets/image-20240604210923928.png alt=image-20240604210923928></p><ul><li>fast走n + 1步，因为只有这样同时移动时slow才可以指向被删除节点的上一节点</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=cm> * type ListNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Next *ListNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeNthFromEnd</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dummy</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>ListNode</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=nx>head</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fast</span><span class=p>,</span> <span class=nx>slow</span> <span class=o>:=</span> <span class=nx>dummy</span><span class=p>,</span> <span class=nx>dummy</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span><span class=c1>// 注意&lt;=，否则快指针为空时，慢指针正好在倒数第n个上面
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dummy</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// O(n) O(1)
</span></span></span></code></pre></td></tr></table></div></div><hr><h2 id=26-链表相交>2.6 链表相交<a hidden class=anchor aria-hidden=true href=#26-链表相交>#</a></h2><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目保证不存在环形，不能改变原链表。</p></blockquote><ul><li>思路：</li></ul><p>求两个链表交点节点的<strong>指针</strong>。（注意！是指针相等，不是数值相等）</p><blockquote><ol><li>curA指向链表A的头结点，curB指向链表B的头结点；</li><li>求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置；</li><li>比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。</li></ol></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ListNode</span> <span class=o>*</span><span class=n>getIntersectionNode</span><span class=p>(</span><span class=n>ListNode</span> <span class=o>*</span><span class=n>headA</span><span class=p>,</span> <span class=n>ListNode</span> <span class=o>*</span><span class=n>headB</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span> <span class=o>*</span><span class=n>curA</span> <span class=o>=</span> <span class=n>headA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ListNode</span> <span class=o>*</span><span class=n>curB</span> <span class=o>=</span> <span class=n>headB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>lenA</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>lenB</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>curA</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>lenA</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>curA</span> <span class=o>=</span> <span class=n>curA</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>curB</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>lenB</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>curB</span> <span class=o>=</span> <span class=n>curB</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>lenB</span> <span class=o>&gt;</span> <span class=n>lenA</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 让curA为最长链表的头
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>swap</span><span class=p>(</span><span class=n>lenA</span><span class=p>,</span> <span class=n>lenB</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>swap</span><span class=p>(</span><span class=n>curA</span><span class=p>,</span> <span class=n>curB</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>gap</span> <span class=o>=</span> <span class=n>lenA</span> <span class=o>-</span> <span class=n>lenB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>gap</span> <span class=o>--</span> <span class=p>)</span> <span class=p>{</span>  <span class=c1>// 两链末尾对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>curA</span> <span class=o>=</span> <span class=n>curA</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>curA</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 遍历curA和curB，遇到相同则直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>curA</span> <span class=o>==</span> <span class=n>curB</span><span class=p>)</span> <span class=k>return</span> <span class=n>curA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>curA</span> <span class=o>=</span> <span class=n>curA</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>curB</span> <span class=o>=</span> <span class=n>curB</span> <span class=o>-&gt;</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>  <span class=c1>// O(n + m) O(1)
</span></span></span></code></pre></td></tr></table></div></div><p>go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getIntersectionNode</span><span class=p>(</span><span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>curA</span><span class=p>,</span> <span class=nx>curB</span> <span class=o>:=</span> <span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>lenA</span><span class=p>,</span> <span class=nx>lenB</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>curA</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>curA</span> <span class=p>=</span> <span class=nx>curA</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenA</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>curB</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>curB</span> <span class=p>=</span> <span class=nx>curB</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>lenB</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>gap</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>fast</span><span class=p>,</span> <span class=nx>slow</span> <span class=o>*</span><span class=nx>ListNode</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>lenA</span> <span class=p>&gt;</span> <span class=nx>lenB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>gap</span> <span class=p>=</span> <span class=nx>lenA</span> <span class=o>-</span> <span class=nx>lenB</span>
</span></span><span class=line><span class=cl>        <span class=nx>fast</span><span class=p>,</span> <span class=nx>slow</span> <span class=p>=</span> <span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>gap</span> <span class=p>=</span> <span class=nx>lenB</span> <span class=o>-</span> <span class=nx>lenA</span>
</span></span><span class=line><span class=cl>        <span class=nx>fast</span><span class=p>,</span> <span class=nx>slow</span> <span class=p>=</span> <span class=nx>headB</span><span class=p>,</span> <span class=nx>headA</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>gap</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>!=</span> <span class=nx>slow</span> <span class=p>{</span>  <span class=c1>// 遍历两个链表，遇到相同的就跳出遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fast</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 双指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=cm> * type ListNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Next *ListNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getIntersectionNode</span><span class=p>(</span><span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>:=</span> <span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>a</span> <span class=o>!=</span> <span class=nx>b</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>a</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>a</span> <span class=p>=</span> <span class=nx>a</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>a</span> <span class=p>=</span> <span class=nx>headB</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>b</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span> <span class=p>=</span> <span class=nx>headA</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=27-环形链表ii>2.7 环形链表II<a hidden class=anchor aria-hidden=true href=#27-环形链表ii>#</a></h2><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p></blockquote><p>考察：</p><ul><li><p>判断链表是否有环</p><ul><li>快慢指针。fast += 2, slow ++ , 如果 fast 和 slow指针在途中相遇 （必在环中相遇），说明这个链表有环。</li></ul></li><li><p>有环的话如何找到入口</p><ul><li><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=cm> * type ListNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Next *ListNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>detectCycle</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fast</span><span class=p>,</span> <span class=nx>slow</span> <span class=o>:=</span> <span class=nx>head</span><span class=p>,</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 快慢指针相遇，此时从 head 和 相遇点，同时查找直至相遇
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>fast</span> <span class=o>==</span> <span class=nx>slow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>slow</span> <span class=o>!=</span> <span class=nx>head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>                <span class=nx>head</span> <span class=p>=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>head</span>  <span class=c1>// 返回环的入口
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=哈希表散列表>哈希表（散列表）<a hidden class=anchor aria-hidden=true href=#哈希表散列表>#</a></h1><ul><li><p><strong>一般哈希表都用快速判断一个元素是否出现在集合里</strong>。</p></li><li><p>hash function：把某个信息映射到哈希表上的索引。</p></li><li><p>hash collisions（哈希碰撞\冲突）：e.g. 多个姓名都映射到了同一个索引下标。</p><ul><li>拉链法：</li></ul><ul><li>线性探测法：一定要保证tableSize大于dataSize。 需要依靠哈希表中的空位来解决碰撞问题。</li></ul></li><li><p>哈希结构：</p><ul><li>数组</li><li>集合 set</li><li>映射 map</li></ul></li></ul><p>c++ 底层：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>**go呢？**go中的hash结构通常是指map，底层是 数组+单链表</p><p><a href=https://blog.csdn.net/vince1998/article/details/137185380>https://blog.csdn.net/vince1998/article/details/137185380</a></p><blockquote><p>做题技巧：</p><ul><li>题目提示只有小写字母，暗示用数组做哈希。大小不受限，不用数组。</li><li>数组大小有限 或 数组空间大但哈希值少，分散，建议set。</li><li>要返回下标，不能排序，用map&lt;key, value>结构返回两者。</li><li>哈希vs双指针：哈希法对于需要去重的题目效率较低，建议使用双指针。</li></ul></blockquote><h2 id=31-有效的字母异位词>3.1 有效的字母异位词<a hidden class=anchor aria-hidden=true href=#31-有效的字母异位词>#</a></h2><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = &ldquo;anagram&rdquo;, t = &ldquo;nagaram&rdquo; 输出: true</p><p>示例 2: 输入: s = &ldquo;rat&rdquo;, t = &ldquo;car&rdquo; 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p></blockquote><ul><li>暴力：两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。</li><li>哈希表：定一个数组叫做record，大小为26，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。O(n) O(1)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isAnagram</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>t</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>record</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>26</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>record</span><span class=p>[</span><span class=nx>v</span> <span class=o>-</span> <span class=nb>rune</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>)]</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>record</span><span class=p>[</span><span class=nx>v</span> <span class=o>-</span> <span class=nb>rune</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>)]</span> <span class=o>--</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>record</span> <span class=o>==</span> <span class=p>[</span><span class=mi>26</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=32-两个数组的交集>3.2 两个数组的交集<a hidden class=anchor aria-hidden=true href=#32-两个数组的交集>#</a></h2><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>没有限制数值的大小就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solultion</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>intersection</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>(</span><span class=n>nums1</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>nums1</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>num</span><span class=p>:</span> <span class=n>nums2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>num</span><span class=p>)</span> <span class=o>!=</span> <span class=n>nums</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>res</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>res</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// O(n + m) m是最后要把set转成vector
</span></span></span><span class=line><span class=cl><span class=c1>// O(n)
</span></span></span></code></pre></td></tr></table></div></div><p>go:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>intersection</span><span class=p>(</span><span class=nx>nums1</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums2</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>set</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>struct</span><span class=p>{},</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// map模拟set
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>[</span><span class=nx>v</span><span class=p>];</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>set</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if exists in the last array, insert into res, and delete this set value.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>[</span><span class=nx>v</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>delete</span><span class=p>(</span><span class=nx>set</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span> <span class=c1>// delete(map, key)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// v2: use array when the number of data is small
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>intersection</span><span class=p>(</span><span class=nx>nums1</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums2</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1001</span><span class=p>,</span> <span class=mi>1001</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>count2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1001</span><span class=p>,</span> <span class=mi>1001</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>count1</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>count2</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>count1</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+</span> <span class=nx>count2</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=33-快乐树>3.3 快乐树<a hidden class=anchor aria-hidden=true href=#33-快乐树>#</a></h2><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后<strong>重复</strong>这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p></blockquote><p>思路：判断sum是否重复出现过</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getSum</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>10</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>/=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isHappy</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>unordered_set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>set</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>getSum</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>set</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>sum</span><span class=p>)</span> <span class=o>!=</span> <span class=n>set</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// sum出现过，死循环了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// O(logn) O(logn)
</span></span></span></code></pre></td></tr></table></div></div><p>go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getSum</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=p>(</span><span class=nx>n</span> <span class=o>%</span> <span class=mi>10</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=nx>n</span> <span class=o>%</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=o>/=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isHappy</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>!=</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>m</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span><span class=p>,</span> <span class=nx>m</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=nf>getSum</span><span class=p>(</span><span class=nx>n</span><span class=p>),</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=34-两数之和>3.4 两数之和<a hidden class=anchor aria-hidden=true href=#34-两数之和>#</a></h2><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p></blockquote><p><a href=https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html>242. 有效的字母异位词 (opens new window)</a>这道题目是用数组作为哈希表来解决哈希问题，<a href=https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html>349. 两个数组的交集 (opens new window)</a>这道题目是通过set作为哈希表来解决哈希问题。</p><p>强调一下 <strong>什么时候使用哈希法</strong>，<strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p><p>本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。（c++）</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 暴力
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>twoSum</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k1</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>k2</span> <span class=o>:=</span> <span class=nx>k1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>k2</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>k2</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>target</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>k1</span><span class=p>]</span> <span class=o>+</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>k2</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>k1</span><span class=p>,</span> <span class=nx>k2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>twoSum</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>pre</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=nx>target</span> <span class=o>-</span> <span class=nx>v</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>pre</span><span class=p>,</span> <span class=nx>i</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>m</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=35-四数相加ii-经典题目>3.5 四数相加II (经典题目)<a hidden class=anchor aria-hidden=true href=#35-四数相加ii-经典题目>#</a></h2><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p></blockquote><p><strong>这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><ul><li>思路</li></ul><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fourSumCount</span><span class=p>(</span><span class=nx>nums1</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums2</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums3</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums4</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=c1>// k: a+b  v: a+b数值出现的次数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>count</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v1</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v2</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>m</span><span class=p>[</span><span class=nx>v1</span> <span class=o>+</span> <span class=nx>v2</span><span class=p>]</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v3</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v4</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums4</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>count</span> <span class=o>+=</span> <span class=nx>m</span><span class=p>[</span><span class=o>-</span><span class=nx>v3</span><span class=o>-</span><span class=nx>v4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>count</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=36-赎金信>3.6 赎金信<a hidden class=anchor aria-hidden=true href=#36-赎金信>#</a></h2><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(&ldquo;a&rdquo;, &ldquo;b&rdquo;) -> false
canConstruct(&ldquo;aa&rdquo;, &ldquo;ab&rdquo;) -> false
canConstruct(&ldquo;aa&rdquo;, &ldquo;aab&rdquo;) -> true</p></blockquote><p><a href=https://leetcode.cn/problems/ransom-note/description/>https://leetcode.cn/problems/ransom-note/description/</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>canConstruct</span><span class=p>(</span><span class=nx>ransomNote</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>magazine</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>ransomNote</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>magazine</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>cnt</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>26</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>magazine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cnt</span><span class=p>[</span><span class=nx>v</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ransomNote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cnt</span><span class=p>[</span><span class=nx>v</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>cnt</span><span class=p>[</span><span class=nx>v</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=p>]</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=37-三数之和>3.7 三数之和<a hidden class=anchor aria-hidden=true href=#37-三数之和>#</a></h2><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p></blockquote><ul><li>要点：去重</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>threeSum</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sort</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>nums</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// find a+b+c=0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span> <span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 去重a，这里不能是nums[i] == nums[i + 1]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>l</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>r</span> <span class=o>--</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>l</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>r</span><span class=p>])</span> <span class=n>l</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>{</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>l</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>r</span><span class=p>]});</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 去重b和c放在找到一个三元组之后
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>while</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>l</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>r</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span> <span class=n>r</span> <span class=o>--</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>l</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=p>[</span><span class=n>l</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>l</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span> <span class=n>l</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// 找到答案时双指针同时收缩
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>r</span> <span class=o>--</span> <span class=p>,</span> <span class=n>l</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>两数之和 就不能使用双指针法，因为<a href=https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html>1.两数之和 (opens new window)</a>要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p><p>如果<a href=https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html>1.两数之和 (opens new window)</a>要求返回的是数值的话，就可以使用双指针法了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>threeSum</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>n1</span> <span class=o>:=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n1</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>n1</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>n2</span><span class=p>,</span> <span class=nx>n3</span> <span class=o>:=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>n1</span> <span class=o>+</span> <span class=nx>n2</span> <span class=o>+</span> <span class=nx>n3</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>n1</span><span class=p>,</span> <span class=nx>n2</span><span class=p>,</span> <span class=nx>n3</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=o>==</span> <span class=nx>n2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=o>==</span> <span class=nx>n3</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>n1</span> <span class=o>+</span> <span class=nx>n2</span> <span class=o>+</span> <span class=nx>n3</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>l</span> <span class=o>++</span> 
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=38-四数之和>3.8 四数之和<a hidden class=anchor aria-hidden=true href=#38-四数之和>#</a></h2><blockquote><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p></blockquote><p>思路：和三数之和一样使用 <strong>双指针</strong> ，基本思路就是在此基础上加一层for循环。</p><p>细节：不能判断了<code>nums[k] > target</code>就返回，因为target是任意值，遇到负数就不好直接跳出了；</p><p>但可以做剪枝， <code>nums[i] > target && (nums[i] >= 0 || target >= 0)</code></p><p><a href=https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html>15.三数之和 (opens new window)</a>的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。</p><p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><p>对于<a href=https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html>15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p><p>之前我们讲过哈希表的经典题目：<a href=https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html>454.四数相加II (opens new window)</a>，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。</p><p><strong>双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fourSum</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>4</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>j</span> <span class=p>&gt;</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>sum</span> <span class=o>:=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=o>+</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=o>+</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>sum</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>sum</span> <span class=p>&gt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]})</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 去重
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>l</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=o>==</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>r</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 找到答案时，l r同时靠近
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>                    <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=字符串完>字符串（完）<a hidden class=anchor aria-hidden=true href=#字符串完>#</a></h1><h2 id=41-反转字符串>4.1 反转字符串<a hidden class=anchor aria-hidden=true href=#41-反转字符串>#</a></h2><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：
输入：[&ldquo;h&rdquo;,&ldquo;e&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;o&rdquo;]
输出：[&ldquo;o&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;e&rdquo;,&ldquo;h&rdquo;]</p></blockquote><p>思路：</p><p>双指针。字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p><ul><li>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reverseString</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=42-反转2>4.2 反转2<a hidden class=anchor aria-hidden=true href=#42-反转2>#</a></h2><blockquote><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = &ldquo;abcdefg&rdquo;, k = 2
输出: &ldquo;bacdfeg&rdquo;</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reverseStr</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>bs</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>k</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span> <span class=o>+</span> <span class=nx>k</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>bs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>reverse</span><span class=p>(</span><span class=nx>bs</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span> <span class=nx>i</span> <span class=o>+</span> <span class=nx>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>reverse</span><span class=p>(</span><span class=nx>bs</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>bs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reverse</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=43-替换数字>4.3 替换数字<a hidden class=anchor aria-hidden=true href=#43-替换数字>#</a></h2><p>go字符串和C++的区别：</p><ul><li>go中的string类型是不可修改的，需要转换成[]byte</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>bs</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Scanln</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>bs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>bs</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>bs</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=sc>&#39;9&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>bs</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=sc>&#39;0&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>insertNum</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;n&#39;</span><span class=p>,</span><span class=sc>&#39;u&#39;</span><span class=p>,</span><span class=sc>&#39;m&#39;</span><span class=p>,</span><span class=sc>&#39;b&#39;</span><span class=p>,</span><span class=sc>&#39;e&#39;</span><span class=p>,</span><span class=sc>&#39;r&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>bs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>bs</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nb>append</span><span class=p>(</span><span class=nx>insertNum</span><span class=p>,</span> <span class=nx>bs</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>i</span> <span class=p>=</span> <span class=nx>i</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=nx>insertNum</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>bs</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=44-翻转字符串里的单词复杂题目>4.4 翻转字符串里的单词（复杂题目）<a hidden class=anchor aria-hidden=true href=#44-翻转字符串里的单词复杂题目>#</a></h2><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：
输入: &ldquo;the sky is blue&rdquo;
输出: &ldquo;blue is sky the&rdquo;</p><p>示例 2：
输入: " hello world! "
输出: &ldquo;world! hello&rdquo;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：
输入: &ldquo;a good example&rdquo;
输出: &ldquo;example good a&rdquo;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p>思路：</p><ul><li><p>移除多余空格</p></li><li><p>整体翻转</p></li><li><p>单词翻转</p></li></ul><p>要求：不适用辅助空间，空间复杂度O(1)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>func</span> <span class=n>reverseWords</span><span class=p>(</span><span class=n>s</span> <span class=n>string</span><span class=p>)</span> <span class=n>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=n>byte</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>移除前面</span><span class=err>、</span><span class=n>中间</span><span class=err>、</span><span class=n>后面存在的多余空格</span>
</span></span><span class=line><span class=cl>    <span class=n>slow</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=s1>&#39; &#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>slow</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=p>[</span><span class=n>slow</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39; &#39;</span>
</span></span><span class=line><span class=cl>                <span class=n>slow</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=s1>&#39; &#39;</span> <span class=p>{</span> <span class=o>//</span> <span class=n>复制逻辑</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=p>[</span><span class=n>slow</span><span class=p>]</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>slow</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>slow</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>翻转整个字符串</span>
</span></span><span class=line><span class=cl>    <span class=n>reverse</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>翻转每个单词</span>
</span></span><span class=line><span class=cl>    <span class=n>last</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=o>||</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39; &#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>reverse</span><span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>last</span><span class=p>:</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>last</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>string</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=n>reverse</span><span class=p>(</span><span class=n>b</span> <span class=p>[]</span><span class=n>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=p>[</span><span class=n>left</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>right</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span><span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=45-右旋字符串>4.5 右旋字符串<a hidden class=anchor aria-hidden=true href=#45-右旋字符串>#</a></h2><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 &ldquo;abcdefg&rdquo; 和整数 2，函数应该将其转换为 &ldquo;fgabcde&rdquo;。</p></blockquote><p>思路：先整体反转，再局部反转。abcdefg => gf | edcba => fg | abcde</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reverse</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>r</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>l</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=nx>r</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>s</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>k</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Scanln</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Scanln</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>bs</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>reverse</span><span class=p>(</span><span class=nx>bs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>reverse</span><span class=p>(</span><span class=nx>bs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>reverse</span><span class=p>(</span><span class=nx>bs</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>bs</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=46-实现strstr>4.6 实现strStr()<a hidden class=anchor aria-hidden=true href=#46-实现strstr>#</a></h2><blockquote><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack = &ldquo;hello&rdquo;, needle = &ldquo;ll&rdquo; 输出: 2</p><p>示例 2: 输入: haystack = &ldquo;aaaaa&rdquo;, needle = &ldquo;bba&rdquo; 输出: -1</p><p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。</p></blockquote><h3 id=kmp算法>KMP算法：<a hidden class=anchor aria-hidden=true href=#kmp算法>#</a></h3><ul><li>解决字符串匹配问题。<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></li></ul><p>前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>当前不匹配位置i前面（包括i）所有子串中的<strong>最长相等前后缀</strong>的长度，即模式串上重新匹配的位置</p><p>前缀：包含首字母，但不包含尾字母的所有子串 后缀：反之</p><ul><li>为什么用前缀表？</li><li><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong></li></ul><p>e.g. 文本串：aabaabaaf 模式串：aabaaf，其前缀表为：0101<strong>2</strong>0 next数组| prefix数组</p><p>实现：在匹配时，在模式串f处发生冲突，接下来看f<strong>前一位</strong>的next数组值，为2，故跳转到模式串下标为2的位置继续匹配。</p><h3 id=next数组的不同实现>next数组的不同实现<a hidden class=anchor aria-hidden=true href=#next数组的不同实现>#</a></h3><ul><li><p>整体右移，首位添加-1 ： -1 0 1 0 1 <strong>2</strong></p><p>实现：在匹配时，在模式串f处发生冲突，看<strong>f的</strong>next数组值，为2，故跳转到模式串下标为2的位置继续匹配。</p></li><li><p>整体减1： -1 0 -1 0 1 -1</p></li></ul><table><thead><tr><th>子串</th><th>最长相等前后缀长度</th></tr></thead><tbody><tr><td>a</td><td>0</td></tr><tr><td>aa</td><td>1 (a a)</td></tr><tr><td>aab</td><td>0</td></tr><tr><td>aaba</td><td>1 (a a)</td></tr><tr><td>aabaa</td><td>2 (aa aa)</td></tr><tr><td>aabaaf</td><td>0</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 前缀表不减一 or 右移
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>getNext</span><span class=p>(</span><span class=nx>next</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span>  <span class=c1>// j表示 最长相等前后缀长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=p>=</span> <span class=nx>next</span><span class=p>[</span><span class=nx>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>next</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>j</span>  <span class=c1>// next[i]是i（包括i）之前的最长相等前后缀长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>strStr</span><span class=p>(</span><span class=nx>hayStack</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>needle</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>needle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>getNext</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span> <span class=nx>needle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>hayStack</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>hayStack</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>needle</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=p>=</span> <span class=nx>next</span><span class=p>[</span><span class=nx>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>hayStack</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>needle</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>j</span> <span class=o>==</span> <span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>i</span> <span class=o>-</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 减一实现
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getNext</span><span class=p>(</span><span class=nx>next</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>j</span> <span class=o>:=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=p>=</span> <span class=nx>next</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>  <span class=c1>// 回退前一位
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>next</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>strStr</span><span class=p>(</span><span class=nx>hayStack</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>needle</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>needle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>j</span> <span class=o>:=</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1>// 模式串的起始位置 next为-1 因此也为-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>next</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>getNext</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span> <span class=nx>needle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>hayStack</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>hayStack</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>needle</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=p>=</span> <span class=nx>next</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>hayStack</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>needle</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>j</span> <span class=o>==</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>i</span> <span class=o>-</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=47-重复子串>4.7 重复子串<a hidden class=anchor aria-hidden=true href=#47-重复子串>#</a></h2><blockquote><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><ul><li>输入: &ldquo;abab&rdquo;</li><li>输出: True</li><li>解释: 可由子字符串 &ldquo;ab&rdquo; 重复两次构成。</li></ul><p>示例 2:</p><ul><li>输入: &ldquo;aba&rdquo;</li><li>输出: False</li></ul><p>示例 3:</p><ul><li>输入: &ldquo;abcabcabcabc&rdquo;</li><li>输出: True</li><li>解释: 可由子字符串 &ldquo;abc&rdquo; 重复四次构成。 (或者子字符串 &ldquo;abcabc&rdquo; 重复两次构成。</li></ul></blockquote><p>思路：</p><h3 id=1移动匹配>1.移动匹配<a hidden class=anchor aria-hidden=true href=#1移动匹配>#</a></h3><p>判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>repeatedSubstringPattern</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>s</span> <span class=o>+</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>t</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=2kmp>2.KMP<a hidden class=anchor aria-hidden=true href=#2kmp>#</a></h3><p>最小重复子串：因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。</p><ul><li>len % (len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>repeatedSubstringPattern</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>j</span> <span class=o>:=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=p>=</span> <span class=nx>next</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>s</span><span class=p>[</span><span class=nx>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>next</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// next[n-1]+1 最长相同前后缀的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>next</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>n</span><span class=o>%</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=p>(</span><span class=nx>next</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=双指针法完>双指针法（完）<a hidden class=anchor aria-hidden=true href=#双指针法完>#</a></h1><p>1.3 移除元素</p><p>4.1 反转字符串</p><p>4.3 替换数字</p><p>4.4 翻转串里的单词</p><p>2.3 翻转链表</p><p>2.5</p><p>2.6</p><p>2.7</p><p>3.7</p><p>3.8</p><hr><h1 id=栈和队列完>栈和队列（完）<a hidden class=anchor aria-hidden=true href=#栈和队列完>#</a></h1><p>go栈</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// create stack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// push
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// pop
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>val</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>// empty
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>go queue</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// create
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// enqueue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// dequeue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>val</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=c1>// empty
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=61-栈模拟队列>6.1 栈模拟队列<a hidden class=anchor aria-hidden=true href=#61-栈模拟队列>#</a></h2><p>1 queue = 1 输入stack + 1 输出stack</p><ul><li>push：入队 = 入栈</li><li>pop：if输出栈空，就将输入栈中数据<strong>all</strong>导入输出栈，再从输出栈pop；if输出栈不空，就直接pop</li><li>empty：if输入栈和输出栈都为空了，则模拟的队列为空。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ------------stack-------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyStack</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)[</span><span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>s</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)[:</span><span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Peek</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)[</span><span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Size</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ------------queue-------------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyQueue</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>stackIn</span> <span class=o>*</span><span class=nx>MyStack</span>
</span></span><span class=line><span class=cl>    <span class=nx>stackOut</span> <span class=o>*</span><span class=nx>MyStack</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=nx>MyQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>stackIn</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>MyStack</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>        <span class=nx>stackOut</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>MyStack</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>stackIn</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nf>fillStackOut</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackOut</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Peek</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nf>fillStackOut</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackOut</span><span class=p>.</span><span class=nf>Peek</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackIn</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackOut</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 填充输出栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>fillStackOut</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackOut</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>!</span><span class=nx>this</span><span class=p>.</span><span class=nx>stackIn</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>val</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>stackIn</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>this</span><span class=p>.</span><span class=nx>stackOut</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Your MyQueue object will be instantiated and called as such:
</span></span></span><span class=line><span class=cl><span class=cm> * obj := Constructor();
</span></span></span><span class=line><span class=cl><span class=cm> * obj.Push(x);
</span></span></span><span class=line><span class=cl><span class=cm> * param_2 := obj.Pop();
</span></span></span><span class=line><span class=cl><span class=cm> * param_3 := obj.Peek();
</span></span></span><span class=line><span class=cl><span class=cm> * param_4 := obj.Empty();
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=62-队列模拟栈>6.2 队列模拟栈<a hidden class=anchor aria-hidden=true href=#62-队列模拟栈>#</a></h2><p>一个队列就可以模拟栈 （如果非要用两个队列，另一个队列仅起到保存元素的作用）</p><ul><li>push：=入栈</li><li>pop：将队头元素重新加入队列尾，再弹出</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyStack</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=nx>MyStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>n</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>val</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Top</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nf>Pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>  <span class=c1>// pop完要重新添加回去
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>val</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Your MyStack object will be instantiated and called as such:
</span></span></span><span class=line><span class=cl><span class=cm> * obj := Constructor();
</span></span></span><span class=line><span class=cl><span class=cm> * obj.Push(x);
</span></span></span><span class=line><span class=cl><span class=cm> * param_2 := obj.Pop();
</span></span></span><span class=line><span class=cl><span class=cm> * param_3 := obj.Top();
</span></span></span><span class=line><span class=cl><span class=cm> * param_4 := obj.Empty();
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=63-括号匹配>6.3 括号匹配<a hidden class=anchor aria-hidden=true href=#63-括号匹配>#</a></h2><p>在写代码之前要分析好有哪几种不匹配的情况:</p><ul><li><p>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。</p></li><li><p>第二种情况，括号没有多余，但是 括号的类型没有匹配上。</p></li><li><p>第三种情况，字符串里右方向的括号多余了，所以不匹配。</p></li></ul><p>还有一些技巧，在匹配左括号的时候，<strong>右括号先入栈</strong>，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// O(n) O(n)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>stk</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>rune</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;[&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=sc>&#39;]&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;(&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=sc>&#39;)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;{&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=sc>&#39;}&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>rune</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果是右括号，如果栈空 或 栈里没有可以匹配的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nx>stk</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1>// pop
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 遍历完了看时候有剩余
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=64-删除字符串中的所有相邻重复项>6.4 删除字符串中的所有相邻重复项<a hidden class=anchor aria-hidden=true href=#64-删除字符串中的所有相邻重复项>#</a></h2><blockquote><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：&ldquo;abbaca&rdquo;</li><li>输出：&ldquo;ca&rdquo;</li><li>解释：例如，在 &ldquo;abbaca&rdquo; 中，我们可以删除 &ldquo;bb&rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &ldquo;aaca&rdquo;，其中又只有 &ldquo;aa&rdquo; 可以执行重复项删除操作，所以最后的字符串为 &ldquo;ca&rdquo;。</li></ul><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>removeDuplicates</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>rune</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>val</span> <span class=o>!=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[]</span><span class=kt>rune</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span> <span class=c1>// 将栈中元素放到result字符串汇总
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 此时字符串需要反转一下
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>l</span><span class=p>,</span> <span class=nx>r</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span><span class=p>[</span><span class=nx>l</span><span class=p>],</span> <span class=nx>res</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=p>=</span> <span class=nx>res</span><span class=p>[</span><span class=nx>r</span><span class=p>],</span> <span class=nx>res</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>l</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=nx>r</span><span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。</p><p>可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。</p><p>此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。</p><p>游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：</p><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p><p>而且<strong>在企业项目开发中，尽量不要使用递归</strong>！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p><h2 id=65-逆波兰式求值>6.5 逆波兰式求值<a hidden class=anchor aria-hidden=true href=#65-逆波兰式求值>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evalRPN</span><span class=p>(</span><span class=nx>tokens</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>token</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tokens</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>token</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// is operation
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>c1</span><span class=p>,</span> <span class=nx>c2</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>],</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>switch</span> <span class=nx>token</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;+&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>c1</span> <span class=o>+</span> <span class=nx>c2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;-&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>c1</span> <span class=o>-</span> <span class=nx>c2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;*&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>c1</span> <span class=o>*</span> <span class=nx>c2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;/&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>c1</span> <span class=o>/</span> <span class=nx>c2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>stack</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=66-滑动窗口最大值-经典单调队列>6.6 滑动窗口最大值 （经典：单调队列）<a hidden class=anchor aria-hidden=true href=#66-滑动窗口最大值-经典单调队列>#</a></h2><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= nums.length</li></ul><p>进阶：你能在线性时间复杂度内解决此题吗？</p></blockquote><p>用一个队列维护当前窗口，随着窗口移动，队列一进一出，希望队头是最大元素。</p><p>要保证队列内元素单调递减（增） –》 <strong>单调队列</strong></p><p>但不需要维护窗口里的所有元素，只需要维护可能成为最大值的元素。如果下一个元素比上一个大，那么上一个出队，保存下一个，直到遇到比上一个小的，上一个元素不动，继续保留小于当前值的最大值。</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// O(n) O(k)
</span></span></span><span class=line><span class=cl><span class=c1>// 封装单调队列的方式解题
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyQueue</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewMyQueue</span><span class=p>()</span> <span class=o>*</span><span class=nx>MyQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>MyQueue</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Front</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Back</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>!</span><span class=nx>m</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>val</span> <span class=p>&gt;</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Back</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>!</span><span class=nx>m</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>val</span> <span class=o>==</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Front</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>maxSlidingWindow</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=o>:=</span> <span class=nf>NewMyQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>length</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 先将前k个元素放入队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>k</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 记录前k个元素的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>k</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 滑动窗口移除最前面的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>queue</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=o>-</span><span class=nx>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 滑动窗口添加最后面的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>queue</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 记录最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=67-前k个高频元素经典优先队列堆>6.7 前k个高频元素（经典：优先队列/堆）<a hidden class=anchor aria-hidden=true href=#67-前k个高频元素经典优先队列堆>#</a></h2><ol><li>统计出现元素的频率 map:[key, value]</li><li>对频率排序 priority queue /</li><li>取前k个频率的元素</li></ol><p>什么是优先级队列呢？</p><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p><p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p><p>为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。</p><p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 快排
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>topKFrequent</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cnt</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cnt</span><span class=p>[</span><span class=nx>val</span><span class=p>]</span> <span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cnt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>cnt</span><span class=p>[</span><span class=nx>res</span><span class=p>[</span><span class=nx>a</span><span class=p>]]</span> <span class=p>&gt;</span> <span class=nx>cnt</span><span class=p>[</span><span class=nx>res</span><span class=p>[</span><span class=nx>b</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span><span class=p>[:</span><span class=nx>k</span><span class=p>]</span>  <span class=c1>// qian k
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 小顶堆
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>topKFrequent</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>map_num</span><span class=o>:=</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//记录每个元素出现的次数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>item</span><span class=o>:=</span><span class=k>range</span> <span class=nx>nums</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>map_num</span><span class=p>[</span><span class=nx>item</span><span class=p>]</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=o>:=&amp;</span><span class=nx>IHeap</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>heap</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//所有元素入堆，堆的长度为k
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>key</span><span class=p>,</span><span class=nx>value</span><span class=o>:=</span><span class=k>range</span> <span class=nx>map_num</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>h</span><span class=p>,[</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=nx>key</span><span class=p>,</span><span class=nx>value</span><span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>Len</span><span class=p>()&gt;</span><span class=nx>k</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=o>:=</span><span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//按顺序返回堆中的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span><span class=nx>i</span><span class=p>&lt;</span><span class=nx>k</span><span class=p>;</span><span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span><span class=p>[</span><span class=nx>k</span><span class=o>-</span><span class=nx>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]=</span><span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>h</span><span class=p>).([</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//构建小顶堆
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>IHeap</span> <span class=p>[][</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>IHeap</span><span class=p>)</span> <span class=nf>Len</span><span class=p>()</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>IHeap</span><span class=p>)</span> <span class=nf>Less</span> <span class=p>(</span><span class=nx>i</span><span class=p>,</span><span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]&lt;</span><span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>IHeap</span><span class=p>)</span> <span class=nf>Swap</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span><span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span><span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>]=</span><span class=nx>h</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span><span class=nx>h</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>IHeap</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kd>interface</span><span class=p>{}){</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>h</span><span class=p>=</span><span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>h</span><span class=p>,</span><span class=nx>x</span><span class=p>.([</span><span class=mi>2</span><span class=p>]</span><span class=kt>int</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>IHeap</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>    <span class=nx>old</span><span class=o>:=*</span><span class=nx>h</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span><span class=o>:=</span><span class=nb>len</span><span class=p>(</span><span class=nx>old</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span><span class=o>:=</span><span class=nx>old</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>h</span><span class=p>=</span><span class=nx>old</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://cloud.tencent.com/developer/article/2412492>Go: 深入理解堆实现及应用-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或小于等于（最小堆）其子节点。Go语言中的堆通过<code>container/heap</code>包实现，该包提供了对数据结构进行堆操作的接口和方法。</p><hr><h1 id=二叉树>二叉树<a hidden class=anchor aria-hidden=true href=#二叉树>#</a></h1><ul><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树</li><li>平衡二叉搜索树 AVL</li></ul><p>二叉树存储：</p><ul><li>链式</li><li>顺序：<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></li></ul><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li></ol><ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul><ol start=2><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>层次遍历（迭代法）</li></ul><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><p>二叉树定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TreeNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>left</span><span class=p>(</span><span class=nb>NULL</span><span class=p>),</span> <span class=n>right</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>TreeNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Val</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Left</span> <span class=o>*</span><span class=nx>TreeNode</span>
</span></span><span class=line><span class=cl>    <span class=nx>Right</span> <span class=o>*</span><span class=nx>TreeNode</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=71-递归遍历>7.1 递归遍历<a hidden class=anchor aria-hidden=true href=#71-递归遍历>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for a binary tree node.
</span></span></span><span class=line><span class=cl><span class=cm> * type TreeNode struct {
</span></span></span><span class=line><span class=cl><span class=cm> *     Val int
</span></span></span><span class=line><span class=cl><span class=cm> *     Left *TreeNode
</span></span></span><span class=line><span class=cl><span class=cm> *     Right *TreeNode
</span></span></span><span class=line><span class=cl><span class=cm> * }
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>preorderTraversal</span><span class=p>(</span><span class=nx>root</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>)</span> <span class=p>(</span><span class=nx>res</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>traversal</span> <span class=kd>func</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>traversal</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>node</span> <span class=o>*</span><span class=nx>TreeNode</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 注意入参
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>  <span class=c1>// 注意终止条件
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 前序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>traversal</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>traversal</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>Right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 中序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// ntraversal(node.Left)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// res = append(res, node.Val)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// traversal(node.Right)
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=c1>// 后序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// traversal(node.Left)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// traversal(node.Right)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// res = append(res, node.Val)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>traversal</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=72-二叉树递归>7.2 二叉树递归<a hidden class=anchor aria-hidden=true href=#72-二叉树递归>#</a></h2><ul><li>确定递归函数入参和返回值</li><li>确定递归退出条件</li><li>确定单次递归内容</li></ul><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><h2 id=73-二叉树迭代>7.3 二叉树迭代<a hidden class=anchor aria-hidden=true href=#73-二叉树迭代>#</a></h2><p>前后序用栈，后序用指针</p><p>stk.Len()</p><p>stk.PushBack(ndoe)</p><p>stk.Back() 返回栈中的最后一个元素，即栈顶元素。</p><p>stk.Remove(stk.Back()) 从栈中移除并返回最后一个元素。这里移除的元素是栈顶元素。</p><p>(*TreeNode) 是类型断言，将移除的元素转换为 *TreeNode 类型。</p><h4 id=统一迭代>统一迭代<a hidden class=anchor aria-hidden=true href=#统一迭代>#</a></h4><hr><h1 id=单调栈完>单调栈（完）<a hidden class=anchor aria-hidden=true href=#单调栈完>#</a></h1><h2 id=739每日温度>739.每日温度<a hidden class=anchor aria-hidden=true href=#739每日温度>#</a></h2><blockquote><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p></blockquote><p>思路：找到右边第一个比自己大的数</p><p>在遍历过程中用栈记录右边第一个比当前大的元素，O(n). 栈中只存对应元素下标即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 暴力
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>dailyTemperatures</span><span class=p>(</span><span class=nx>t</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>);</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>t</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>j</span> <span class=o>-</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>  <span class=c1>// 找到第一个就退出
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>j</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 如果找完了都没有
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 最后一日肯定是0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 单调栈(增)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>dailyTemperatures</span><span class=p>(</span><span class=nx>t</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>stk</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span>  <span class=c1>// 初始化栈顶元素为第一个下标索引0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>top</span> <span class=o>:=</span> <span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1>// 当前栈顶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>t</span><span class=p>[</span><span class=nx>top</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>t</span><span class=p>[</span><span class=nx>top</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span><span class=p>[</span><span class=nx>top</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span> <span class=o>-</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>                <span class=nx>stk</span> <span class=p>=</span> <span class=nx>stl</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=c1>// pop
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>top</span> <span class=p>=</span> <span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=c1>// 更新栈顶
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 单调栈(递减)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>dailyTemperatures</span><span class=p>(</span><span class=nx>t</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=p>:</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>stk</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 栈不空且当前遍历元素 v 破坏了栈的单调性
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>v</span> <span class=p>&gt;</span> <span class=nx>t</span><span class=p>[</span><span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=p>{</span>  <span class=c1>// 大于当前栈顶，就pop，更新
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>top</span> <span class=o>:=</span> <span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nx>stk</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span><span class=p>[</span><span class=nx>top</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span> <span class=o>-</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=496下一个更大元素-i>496.下一个更大元素 I<a hidden class=anchor aria-hidden=true href=#496下一个更大元素-i>#</a></h2><blockquote><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]</p></blockquote><p>没有重复元素，可以用map来做映射，可以根据数值快速找下标，并且可以判断nums2[i]是否在nums1中出现过。</p><ul><li><p>res数组默认值为-1（找不到）。</p></li><li><p>遍历哪个数组呢？要在nums2里找比1里对应位置元素大的，所以遍历nums2</p></li><li><p>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况：此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p></li><li><p>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况：如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于</p></li><li><p>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况：此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p></li></ul><p>判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>nextGreaterElement</span><span class=p>(</span><span class=nx>nums1</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>nums2</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>res</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>mp</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mp</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// nums2下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums2</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>nums2</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>nums2</span><span class=p>[</span><span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>            <span class=nx>top</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>[</span><span class=nx>nums2</span><span class=p>[</span><span class=nx>top</span><span class=p>]];</span> <span class=nx>ok</span> <span class=p>{</span> <span class=c1>// 看map里是否存在这个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>index</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>[</span><span class=nx>nums2</span><span class=p>[</span><span class=nx>top</span><span class=p>]]</span> <span class=c1>// 根据map找到nums2[top] 在 nums1中的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>res</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums2</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>  <span class=c1>// &lt;=
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=503下一个更大元素-ii>503.下一个更大元素 II<a hidden class=anchor aria-hidden=true href=#503下一个更大元素-ii>#</a></h2><blockquote><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><ul><li>输入: [1,2,1]</li><li>输出: [2,-1,2]</li><li>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</li></ul><p>提示:</p><ul><li>1 &lt;= nums.length &lt;= 10^4</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li></ul></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>nextGreaterElements</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nums</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 单调递减，存储数组下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>stk</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span> <span class=o>%</span> <span class=nx>n</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>index</span> <span class=o>:=</span> <span class=nx>stk</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>stk</span> <span class=p>=</span> <span class=nx>stk</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stk</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span> <span class=o>%</span> <span class=nx>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>stk</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stk</span><span class=p>,</span> <span class=nx>i</span> <span class=o>%</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=42-接雨水经典常问>42. 接雨水（经典常问）<a hidden class=anchor aria-hidden=true href=#42-接雨水经典常问>#</a></h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img loading=lazy src=algorithm.assets/20210713205038.png alt=img></p><ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul><h4 id=暴力双指针>暴力双指针<a hidden class=anchor aria-hidden=true href=#暴力双指针>#</a></h4><p>按列计算：宽度一定是1，再求每一列的雨水高度。每一列的雨水有多高取决于两侧柱子中最短的一个。</p><ul><li>注意第一个和最后一个柱子不接雨水。</li><li>在for中求左右两边最高的柱子。</li><li>最后计算该列的雨水高度: 当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>trap</span><span class=p>(</span><span class=nx>height</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>sum</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>h</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>height</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>ml</span><span class=p>,</span> <span class=nx>mr</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>r</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>r</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>height</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>mr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>mr</span> <span class=p>=</span> <span class=nx>height</span><span class=p>[</span><span class=nx>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>l</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>l</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>l</span> <span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>height</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>ml</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>ml</span> <span class=p>=</span> <span class=nx>height</span><span class=p>[</span><span class=nx>l</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>min</span><span class=p>(</span><span class=nx>ml</span><span class=p>,</span> <span class=nx>mr</span><span class=p>)</span> <span class=o>-</span> <span class=nx>h</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>sum</span> <span class=o>+=</span> <span class=nb>min</span><span class=p>(</span><span class=nx>ml</span><span class=p>,</span> <span class=nx>mr</span><span class=p>)</span> <span class=o>-</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 时间复杂度为O(n^2)，空间复杂度为O(1)
</span></span></span></code></pre></td></tr></table></div></div><h4 id=双指针优化>双指针优化<a hidden class=anchor aria-hidden=true href=#双指针优化>#</a></h4><p>为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。</p><p>当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。</p><p>即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p><p>从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p><h4 id=单调栈>单调栈<a hidden class=anchor aria-hidden=true href=#单调栈>#</a></h4><p>单调栈就是保持栈内元素有序。我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。</p><p>【单调栈是按行计算】</p><p>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。</p><p>遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>trap</span><span class=p>(</span><span class=nx>height</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>sum</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>height</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// 第一个柱子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>height</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>height</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>height</span><span class=p>[</span><span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>mid</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>h</span> <span class=o>:=</span> <span class=nb>min</span><span class=p>(</span><span class=nx>height</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>height</span><span class=p>[</span><span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]])</span> <span class=o>-</span> <span class=nx>height</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=nx>w</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>-</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>h</span> <span class=o>*</span> <span class=nx>w</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=84-柱状图中的最大矩形>84. 柱状图中的最大矩形<a hidden class=anchor aria-hidden=true href=#84-柱状图中的最大矩形>#</a></h2><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>输入：heights = [2,1,5,6,2,3]
</span></span><span class=line><span class=cl>输出：10
</span></span><span class=line><span class=cl>解释：最大的矩形为图中红色区域，面积为 10
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=algorithm.assets/image-20240916210121908.png alt=image-20240916210121908></p></blockquote><p>【与接雨水的区别】要记录每个柱子左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 暴力双指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>largestRectangleArea</span><span class=p>(</span><span class=nx>height</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>minl</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>minr</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>minl</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>t</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>height</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=nx>height</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>,</span> <span class=nx>minl</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span> <span class=p>=</span> <span class=nx>minl</span><span class=p>[</span><span class=nx>t</span><span class=p>],</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>minr</span><span class=p>[</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>t</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>height</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=nx>height</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>,</span> <span class=nx>minr</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span> <span class=p>=</span> <span class=nx>minr</span><span class=p>[</span><span class=nx>t</span><span class=p>],</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>s</span> <span class=o>:=</span> <span class=nx>height</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=nx>minr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>-</span> <span class=nx>minl</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=p>=</span> <span class=nb>max</span><span class=p>(</span><span class=nx>sum</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=单调栈-1>单调栈<a hidden class=anchor aria-hidden=true href=#单调栈-1>#</a></h4><p><a href=https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html>42. 接雨水 (opens new window)</a>是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。</p><p><strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p><p>注：在height数组头尾加一个0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>largestRectangleArea</span><span class=p>(</span><span class=nx>heights</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>res</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>heights</span> <span class=p>=</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>},</span> <span class=nx>heights</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>heights</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>heights</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>heights</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>heights</span><span class=p>[</span><span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=p>&gt;</span> <span class=nx>heights</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>mid</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>left</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>sum</span> <span class=o>:=</span> <span class=nx>heights</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=nx>i</span> <span class=o>-</span> <span class=nx>left</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>sum</span> <span class=p>&gt;</span> <span class=nx>res</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span> <span class=p>=</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=贪心>贪心<a hidden class=anchor aria-hidden=true href=#贪心>#</a></h1><hr><h1 id=dp>DP<a hidden class=anchor aria-hidden=true href=#dp>#</a></h1><ul><li>基础题</li><li>背包：01、完全、多重</li><li>打家劫舍系列</li><li>股票问题</li><li>子序列问题</li></ul><p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><p>问题分解：</p><ul><li>确定dp数组以及下标的含义</li><li>确定状态转移方程（递推公式）</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><blockquote><p>如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p></blockquote><h2 id=509-斐波那契数入门>509. 斐波那契数（入门）<a hidden class=anchor aria-hidden=true href=#509-斐波那契数入门>#</a></h2><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li></ul><p>提示：</p><ul><li>0 &lt;= n &lt;= 30</li></ul></blockquote><p>思路：</p><ul><li>确定dp数组及下表的意义：dp[i] 定义为第i个数的斐波那契数值</li><li>递推公式：题目给了 dp[i] = dp[i - 1] + dp[i - 2]</li><li>初始化：题目给了 dp[0] = 0, dp[1] = 1</li><li>遍历顺序：从公式看出，dp[i] 依赖 dp[i - 1]和dp[i - 2]，所以是从前到后遍历</li><li>举例推导dp数组：N = 10时，dp数组应该是：0 1 1 2 3 5 8 13 21 34 55</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 递归
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>fib</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>fib</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=nf>fib</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// dp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>fib</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>dp0</span><span class=p>,</span> <span class=nx>dp1</span><span class=p>,</span> <span class=nx>dp</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp</span> <span class=p>=</span> <span class=nx>dp0</span> <span class=o>+</span> <span class=nx>dp1</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp0</span><span class=p>,</span> <span class=nx>dp1</span> <span class=p>=</span> <span class=nx>dp1</span><span class=p>,</span> <span class=nx>dp</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dp</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=70-爬楼梯>70. 爬楼梯<a hidden class=anchor aria-hidden=true href=#70-爬楼梯>#</a></h2><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul></blockquote><p>思路：</p><ol><li>dp[i]: 爬到第i层时，有dp[i]种方法</li><li>dp[i] = dp[i - 1] + dp[i - 2]</li><li>不考虑dp[0], dp[1] = 1, dp[2] = 2, 从3开始递推</li><li>顺序：从前到后</li><li>举例：n = 5时， dp数组：1 2 3 5 8</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>climbStairs</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>dp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>dp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=746-最小花费爬楼梯>746. 最小花费爬楼梯<a hidden class=anchor aria-hidden=true href=#746-最小花费爬楼梯>#</a></h2><blockquote><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p></blockquote><p>思路：</p><ol><li><p>dp[i] ： 到达第i个台阶所花费的最少费用</p></li><li><p>dp[i] = dp[i - 1] + cost[i - 1], dp[i - 1] = dp[i - 2] + cost[i - 2].</p><p>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</p></li><li><p>初始化：根据题目意思，dp[0] = dp[1] = 0 (因为从0或1开题跳都可以，意思就是不计费)</p></li><li><p>遍历顺序：从前到后</p></li><li><p>举例推导：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</p><p>0 0 1 2 2 3 3 4 4 5 6</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>minCostClimbingStairs</span><span class=p>(</span><span class=nx>cost</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>f</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>cost</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>f</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>cost</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>f</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>min</span><span class=p>(</span><span class=nx>f</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=nx>cost</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=nx>f</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=nx>cost</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>f</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>cost</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=62-不同路径>62. 不同路径<a hidden class=anchor aria-hidden=true href=#62-不同路径>#</a></h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><ul><li>dp[i ] [j] : 表示从（0,0）出发到（i,j)的不同路径数</li><li>公式：dp[ i ] [ j ] = dp[i] [j - 1] + dp[i - 1] [j] （从左边和上边来的）</li><li>初始化：dp[i] [0] = 1, dp[0] [j] = 1</li><li>遍历顺序：从左到右一层层遍历即可</li><li>举例： <img loading=lazy src=algorithm.assets/image-20240920140241761.png alt=image-20240920140241761></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>uniquePaths</span><span class=p>(</span><span class=nx>m</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>dp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>m</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>+</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 优化：二维简化到一维，滚动数组 T: O(mn), S: O(mn) -&gt; O(n)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 数论做法：对于m行n列的矩形，走到终点都需要m+n-2步。在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。C_(m+m-2)^(m-1)
</span></span></span><span class=line><span class=cl><span class=c1>//需要在计算分子的时候，不断除以分母
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>uniquePaths</span><span class=p>(</span><span class=nx>m</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>numerator</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>denominator</span> <span class=o>:=</span> <span class=nx>m</span> <span class=o>-</span> <span class=mi>1</span> <span class=c1>// fenmu
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cnt</span> <span class=o>:=</span> <span class=nx>m</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>m</span> <span class=o>+</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>cnt</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>numerator</span> <span class=o>*=</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>denominator</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>numerator</span> <span class=o>%</span> <span class=nx>denominator</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>numerator</span> <span class=o>/=</span> <span class=nx>denominator</span>
</span></span><span class=line><span class=cl>            <span class=nx>denominator</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>cnt</span> <span class=o>--</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>numerator</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// O(m) O(1)
</span></span></span></code></pre></td></tr></table></div></div><p><strong>求组合的时候，要防止两个int相乘溢出！</strong> 所以不能把算式的分子都算出来，分母都算出来再做除法。</p><h2 id=数位dp>数位DP<a hidden class=anchor aria-hidden=true href=#数位dp>#</a></h2><p>数的大小和复杂度没什么关系，数位变化有关。</p><ul><li><p>f[i, mask, isLimit, isNum]</p><p>返回从i开始填数字，i前面的数字的集合是mask，共构造出的特殊数的数量；is_limit表示前面填的数是否都是n对应位置上的，if true，则当前位之多为s[i], 否则至多为’9’; is_num表示前面是否填了数字（是否跳过），if true则当前可以从0开始，false可以跳过或从1开始。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>mask</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>is_limit</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>is_num</span> <span class=kt>bool</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>集合可以用二进制表示，二进制从低到高第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 对应的二进制数为 1101 (2)</p><p>设集合对应的二进制数为 x。本题需要用到两个位运算操作：</p><p>判断元素 d 是否在集合中：x &#187; d & 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。
把元素 d 添加到集合中：将 x 更新为 x | (1 &#171; d)。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://erica423.github.io/tags/%E6%8A%80%E6%9C%AF/>技术</a></li></ul><nav class=paginav><a class=prev href=https://erica423.github.io/posts/first/><span class=title>« Prev</span><br><span>使用Github Actions实现Hugo静态博客自动部署</span>
</a><a class=next href=https://erica423.github.io/posts/project/><span class=title>Next »</span><br><span>项目经验</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://erica423.github.io/>Erica-Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>